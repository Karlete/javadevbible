<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thread Pools & ExecutorService - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#advanced">Advanced Java</a> / Thread Pools & ExecutorService
            </nav>
            <h1>Thread Pools & ExecutorService</h1>
            <p class="topic-subtitle">Efficient Thread Management</p>
            <a href="../../index.html" class="back-btn">← Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What is a Thread Pool?</h2>
            <p>Imagine a restaurant with a kitchen staff. You could hire a new chef for every single order that comes in, then fire them when done (wasteful!). Or you could have a team of chefs ready to cook whenever orders arrive (efficient!). That's what a <strong>thread pool</strong> does - it maintains a group of reusable worker threads.</p>

            <h3>The Problem with Creating Threads Manually</h3>
            <pre><code><span class="comment">// BAD: Creating 1000 threads - expensive and wasteful!</span>
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {
    <span class="class-name">Thread</span> t = <span class="keyword">new</span> <span class="class-name">Thread</span>(() -> processTask());
    t.start();  <span class="comment">// Creates a new thread EVERY time</span>
}

<span class="comment">Problems:</span>
<span class="comment">❌ Creating threads is expensive (time + memory)</span>
<span class="comment">❌ 1000 threads running at once = system overload</span>
<span class="comment">❌ Thread creation/destruction overhead</span>
<span class="comment">❌ Hard to manage and control</span></code></pre>

            <h3>The Solution: Thread Pool</h3>
            <pre><code><span class="comment">// GOOD: Reuse a pool of 10 threads for 1000 tasks</span>
<span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">10</span>);

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {
    executor.submit(() -> processTask());  <span class="comment">// Reuses existing threads!</span>
}

executor.shutdown();

<span class="comment">Benefits:</span>
<span class="comment">✅ Only 10 threads created</span>
<span class="comment">✅ Threads are reused for multiple tasks</span>
<span class="comment">✅ Controlled resource usage</span>
<span class="comment">✅ Better performance</span></code></pre>

            <h3>How Thread Pools Work</h3>
            <pre><code><span class="comment">┌─────────────────────────────┐</span>
<span class="comment">│     Task Queue              │  ← Tasks waiting to be executed</span>
<span class="comment">│  [Task1][Task2][Task3]...  │</span>
<span class="comment">└─────────────────────────────┘</span>
              ↓ ↓ ↓
<span class="comment">    ┌──────┐  ┌──────┐  ┌──────┐</span>
<span class="comment">    │Thread│  │Thread│  │Thread│  ← Worker threads (reusable)</span>
<span class="comment">    │  1   │  │  2   │  │  3   │</span>
<span class="comment">    └──────┘  └──────┘  └──────┘</span>

<span class="comment">1. Submit tasks to the pool</span>
<span class="comment">2. Tasks wait in queue</span>
<span class="comment">3. Available thread picks up task from queue</span>
<span class="comment">4. Thread executes task</span>
<span class="comment">5. Thread goes back to pool (ready for next task)</span></code></pre>
        </section>

        <section class="content-section">
            <h2>ExecutorService - The Thread Pool Interface</h2>
            <p><strong>ExecutorService</strong> is Java's high-level API for managing thread pools. Think of it as a professional task manager for your threads.</p>

            <h3>Creating Thread Pools - Different Types</h3>

            <h4>1. Fixed Thread Pool</h4>
            <pre><code><span class="comment">// Creates a pool with exactly N threads</span>
<span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">5</span>);

<span class="comment">Use when: You know how many threads you need</span>
<span class="comment">Example: Web server with 100 worker threads</span></code></pre>

            <h4>2. Cached Thread Pool</h4>
            <pre><code><span class="comment">// Creates threads as needed, reuses idle threads</span>
<span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newCachedThreadPool();

<span class="comment">Use when: Many short-lived tasks</span>
<span class="comment">Example: Processing quick API calls</span>
<span class="comment">Warning: Can create too many threads if tasks pile up!</span></code></pre>

            <h4>3. Single Thread Executor</h4>
            <pre><code><span class="comment">// Only ONE thread executes tasks sequentially</span>
<span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newSingleThreadExecutor();

<span class="comment">Use when: Tasks must execute in order</span>
<span class="comment">Example: Writing to a log file (one at a time)</span></code></pre>

            <h4>4. Scheduled Thread Pool</h4>
            <pre><code><span class="comment">// Schedule tasks to run after delay or periodically</span>
<span class="class-name">ScheduledExecutorService</span> executor = <span class="class-name">Executors</span>.newScheduledThreadPool(<span class="number">3</span>);

<span class="comment">Use when: Need scheduled/delayed execution</span>
<span class="comment">Example: Backup database every hour</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Complete Example - Fixed Thread Pool</h2>

            <pre><code><span class="keyword">import</span> java.util.concurrent.*;

<span class="keyword">public class</span> <span class="class-name">ThreadPoolExample</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="comment">// Create pool with 3 worker threads</span>
        <span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">3</span>);

        <span class="comment">// Submit 10 tasks to the pool</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= <span class="number">10</span>; i++) {
            <span class="keyword">int</span> taskNumber = i;
            executor.submit(() -> {
                <span class="class-name">String</span> threadName = <span class="class-name">Thread</span>.currentThread().getName();
                <span class="class-name">System</span>.out.println(threadName + <span class="string">": Executing Task "</span> + taskNumber);

                <span class="keyword">try</span> {
                    <span class="class-name">Thread</span>.sleep(<span class="number">2000</span>);  <span class="comment">// Simulate work</span>
                } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span> e) {
                    e.printStackTrace();
                }

                <span class="class-name">System</span>.out.println(threadName + <span class="string">": Completed Task "</span> + taskNumber);
            });
        }

        <span class="comment">// Shutdown the pool</span>
        executor.shutdown();  <span class="comment">// No new tasks accepted, existing tasks complete</span>

        <span class="keyword">try</span> {
            <span class="comment">// Wait for all tasks to finish (max 1 minute)</span>
            <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, <span class="class-name">TimeUnit</span>.SECONDS)) {
                executor.shutdownNow();  <span class="comment">// Force shutdown</span>
            }
        } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span> e) {
            executor.shutdownNow();
        }

        <span class="class-name">System</span>.out.println(<span class="string">"All tasks completed!"</span>);
    }
}</code></pre>

            <p><strong>Output:</strong></p>
            <pre><code>pool-1-thread-1: Executing Task 1
pool-1-thread-2: Executing Task 2
pool-1-thread-3: Executing Task 3
<span class="comment">... 2 seconds ...</span>
pool-1-thread-1: Completed Task 1
pool-1-thread-2: Completed Task 2
pool-1-thread-3: Completed Task 3
pool-1-thread-1: Executing Task 4  <span class="comment">← Thread 1 reused!</span>
pool-1-thread-2: Executing Task 5
pool-1-thread-3: Executing Task 6
<span class="comment">... continues until all 10 tasks done ...</span>
All tasks completed!</code></pre>

            <p><strong>Notice:</strong> Only 3 threads handle all 10 tasks! Threads are reused efficiently.</p>
        </section>

        <section class="content-section">
            <h2>submit() vs execute() - What's the Difference?</h2>

            <h3>execute() - Fire and Forget</h3>
            <pre><code><span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">5</span>);

executor.execute(() -> {
    <span class="class-name">System</span>.out.println(<span class="string">"Task executed"</span>);
});

<span class="comment">// Returns void - no way to get result or check status</span>
<span class="comment">// Use when: You don't need the result</span></code></pre>

            <h3>submit() - Get a Future</h3>
            <pre><code><span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">5</span>);

<span class="class-name">Future</span>&lt;<span class="class-name">Integer</span>&gt; future = executor.submit(() -> {
    <span class="class-name">Thread</span>.sleep(<span class="number">1000</span>);
    <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// Return a result</span>
});

<span class="comment">// Returns Future - can get result later</span>
<span class="class-name">Integer</span> result = future.get();  <span class="comment">// Blocks until task completes</span>
<span class="class-name">System</span>.out.println(<span class="string">"Result: "</span> + result);  <span class="comment">// 42</span>

<span class="comment">// Use when: You need the result or want to check status</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Working with Future - Getting Results</h2>

            <pre><code><span class="keyword">import</span> java.util.concurrent.*;

<span class="keyword">public class</span> <span class="class-name">FutureExample</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) <span class="keyword">throws</span> <span class="class-name">Exception</span> {
        <span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">3</span>);

        <span class="comment">// Submit a task that returns a result</span>
        <span class="class-name">Future</span>&lt;<span class="class-name">String</span>&gt; future = executor.submit(() -> {
            <span class="class-name">System</span>.out.println(<span class="string">"Task started"</span>);
            <span class="class-name">Thread</span>.sleep(<span class="number">3000</span>);  <span class="comment">// Simulate long operation</span>
            <span class="keyword">return</span> <span class="string">"Task completed successfully!"</span>;
        });

        <span class="class-name">System</span>.out.println(<span class="string">"Main thread continues..."</span>);

        <span class="comment">// Check if task is done</span>
        <span class="keyword">if</span> (!future.isDone()) {
            <span class="class-name">System</span>.out.println(<span class="string">"Task is still running..."</span>);
        }

        <span class="comment">// Get result - BLOCKS until task completes</span>
        <span class="class-name">String</span> result = future.get();  <span class="comment">// Waits for completion</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Result: "</span> + result);

        <span class="comment">// Get with timeout - don't wait forever!</span>
        <span class="keyword">try</span> {
            <span class="class-name">String</span> result2 = future.get(<span class="number">5</span>, <span class="class-name">TimeUnit</span>.SECONDS);
        } <span class="keyword">catch</span> (<span class="class-name">TimeoutException</span> e) {
            <span class="class-name">System</span>.out.println(<span class="string">"Task took too long!"</span>);
            future.cancel(<span class="keyword">true</span>);  <span class="comment">// Cancel the task</span>
        }

        executor.shutdown();
    }
}</code></pre>

            <h3>Future Methods</h3>
            <ul>
                <li><code>get()</code> - Wait for task to complete and get result</li>
                <li><code>get(timeout, unit)</code> - Wait with timeout</li>
                <li><code>isDone()</code> - Check if task completed</li>
                <li><code>cancel()</code> - Cancel the task</li>
                <li><code>isCancelled()</code> - Check if task was cancelled</li>
            </ul>
        </section>

        <section class="content-section">
            <h2>Scheduled Executor - Running Tasks Periodically</h2>

            <h3>Schedule Once (After Delay)</h3>
            <pre><code><span class="class-name">ScheduledExecutorService</span> scheduler = <span class="class-name">Executors</span>.newScheduledThreadPool(<span class="number">1</span>);

<span class="comment">// Run task after 5 seconds delay</span>
scheduler.schedule(() -> {
    <span class="class-name">System</span>.out.println(<span class="string">"Task executed after 5 seconds"</span>);
}, <span class="number">5</span>, <span class="class-name">TimeUnit</span>.SECONDS);

scheduler.shutdown();</code></pre>

            <h3>Schedule Repeatedly (Fixed Rate)</h3>
            <pre><code><span class="class-name">ScheduledExecutorService</span> scheduler = <span class="class-name">Executors</span>.newScheduledThreadPool(<span class="number">1</span>);

<span class="comment">// Run task every 10 seconds, starting after 0 second delay</span>
scheduler.scheduleAtFixedRate(() -> {
    <span class="class-name">System</span>.out.println(<span class="string">"Heartbeat: "</span> + <span class="keyword">new</span> <span class="class-name">Date</span>());
}, <span class="number">0</span>, <span class="number">10</span>, <span class="class-name">TimeUnit</span>.SECONDS);

<span class="comment">// Runs every 10 seconds regardless of task duration</span>
<span class="comment">// Time between task START times = 10 seconds</span></code></pre>

            <h3>Schedule with Fixed Delay</h3>
            <pre><code><span class="class-name">ScheduledExecutorService</span> scheduler = <span class="class-name">Executors</span>.newScheduledThreadPool(<span class="number">1</span>);

<span class="comment">// Wait 5 seconds AFTER task completes, then run again</span>
scheduler.scheduleWithFixedDelay(() -> {
    <span class="class-name">System</span>.out.println(<span class="string">"Processing batch..."</span>);
    <span class="class-name">Thread</span>.sleep(<span class="number">2000</span>);  <span class="comment">// Task takes 2 seconds</span>
}, <span class="number">0</span>, <span class="number">5</span>, <span class="class-name">TimeUnit</span>.SECONDS);

<span class="comment">// Time between task END and next START = 5 seconds</span>
<span class="comment">// Total cycle: 2s (task) + 5s (delay) = 7 seconds</span></code></pre>

            <h3>Practical Example - Database Backup</h3>
            <pre><code><span class="class-name">ScheduledExecutorService</span> scheduler = <span class="class-name">Executors</span>.newScheduledThreadPool(<span class="number">1</span>);

<span class="comment">// Backup database every hour</span>
scheduler.scheduleAtFixedRate(() -> {
    <span class="class-name">System</span>.out.println(<span class="string">"Starting database backup..."</span>);
    backupDatabase();
    <span class="class-name">System</span>.out.println(<span class="string">"Backup completed!"</span>);
}, <span class="number">0</span>, <span class="number">1</span>, <span class="class-name">TimeUnit</span>.HOURS);</code></pre>
        </section>

        <section class="content-section">
            <h2>Shutdown Methods - Stopping Executors</h2>

            <h3>1. shutdown() - Graceful Shutdown</h3>
            <pre><code>executor.shutdown();
<span class="comment">// ✅ Existing tasks complete</span>
<span class="comment">// ❌ New tasks rejected</span>
<span class="comment">// Waits for tasks to finish naturally</span></code></pre>

            <h3>2. shutdownNow() - Immediate Shutdown</h3>
            <pre><code><span class="class-name">List</span>&lt;<span class="class-name">Runnable</span>&gt; notExecuted = executor.shutdownNow();
<span class="comment">// ❌ Running tasks interrupted</span>
<span class="comment">// ❌ Waiting tasks not started</span>
<span class="comment">// Returns list of tasks that never ran</span></code></pre>

            <h3>3. awaitTermination() - Wait for Completion</h3>
            <pre><code>executor.shutdown();
<span class="keyword">try</span> {
    <span class="comment">// Wait up to 60 seconds for tasks to complete</span>
    <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, <span class="class-name">TimeUnit</span>.SECONDS)) {
        executor.shutdownNow();  <span class="comment">// Force shutdown after timeout</span>
    }
} <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span> e) {
    executor.shutdownNow();
}</code></pre>

            <h3>Best Practice - Proper Shutdown Pattern</h3>
            <pre><code><span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">5</span>);

<span class="keyword">try</span> {
    <span class="comment">// Submit your tasks</span>
    executor.submit(() -> doWork());

} <span class="keyword">finally</span> {
    <span class="comment">// Always shutdown in finally block!</span>
    executor.shutdown();
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, <span class="class-name">TimeUnit</span>.SECONDS)) {
            executor.shutdownNow();
        }
    } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span> e) {
        executor.shutdownNow();
        <span class="class-name">Thread</span>.currentThread().interrupt();
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Practical Example - Web Scraper</h2>

            <pre><code><span class="keyword">import</span> java.util.concurrent.*;
<span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> <span class="class-name">WebScraper</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) <span class="keyword">throws</span> <span class="class-name">Exception</span> {
        <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; urls = <span class="class-name">Arrays</span>.asList(
            <span class="string">"https://example.com/page1"</span>,
            <span class="string">"https://example.com/page2"</span>,
            <span class="string">"https://example.com/page3"</span>,
            <span class="string">"https://example.com/page4"</span>,
            <span class="string">"https://example.com/page5"</span>
        );

        <span class="comment">// Pool of 3 threads to scrape 5 URLs</span>
        <span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">3</span>);
        <span class="class-name">List</span>&lt;<span class="class-name">Future</span>&lt;<span class="class-name">String</span>&gt;&gt; futures = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();

        <span class="comment">// Submit all scraping tasks</span>
        <span class="keyword">for</span> (<span class="class-name">String</span> url : urls) {
            <span class="class-name">Future</span>&lt;<span class="class-name">String</span>&gt; future = executor.submit(() -> scrapeWebsite(url));
            futures.add(future);
        }

        <span class="comment">// Collect all results</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < futures.size(); i++) {
            <span class="class-name">String</span> content = futures.get(i).get();  <span class="comment">// Wait for result</span>
            <span class="class-name">System</span>.out.println(<span class="string">"Scraped: "</span> + urls.get(i) + <span class="string">" - Length: "</span> + content.length());
        }

        executor.shutdown();
        <span class="class-name">System</span>.out.println(<span class="string">"All pages scraped!"</span>);
    }

    <span class="keyword">private static</span> <span class="class-name">String</span> <span class="function">scrapeWebsite</span>(<span class="class-name">String</span> url) {
        <span class="class-name">System</span>.out.println(<span class="string">"Scraping: "</span> + url);
        <span class="keyword">try</span> {
            <span class="class-name">Thread</span>.sleep(<span class="number">2000</span>);  <span class="comment">// Simulate network delay</span>
        } <span class="keyword">catch</span> (<span class="class-name">InterruptedException</span> e) {}
        <span class="keyword">return</span> <span class="string">"Content from "</span> + url;  <span class="comment">// Simulated content</span>
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Best Practices</h2>

            <div class="info-box tip">
                <div class="info-box-title">Thread Pool Best Practices</div>
                <ul>
                    <li>✅ <strong>Always shutdown executors:</strong> Use try-finally to ensure cleanup</li>
                    <li>✅ <strong>Size pools appropriately:</strong> CPU-bound = cores, I/O-bound = more threads</li>
                    <li>✅ <strong>Use submit() over execute():</strong> Better error handling with Future</li>
                    <li>✅ <strong>Handle InterruptedException:</strong> Don't ignore it!</li>
                    <li>✅ <strong>Use timeouts with get():</strong> Prevent infinite waiting</li>
                    <li>✅ <strong>Name thread pools:</strong> Easier debugging</li>
                    <li>✅ <strong>Monitor pool health:</strong> Check queue sizes, rejected tasks</li>
                    <li>❌ <strong>Don't create unlimited pools:</strong> CachedThreadPool can be dangerous</li>
                    <li>❌ <strong>Don't forget to shutdown:</strong> Threads keep JVM alive</li>
                    <li>❌ <strong>Don't use Thread directly:</strong> Use ExecutorService instead</li>
                </ul>
            </div>

            <h3>Choosing Pool Size</h3>
            <pre><code><span class="comment">// CPU-intensive tasks (calculations, data processing)</span>
<span class="keyword">int</span> cpuCores = <span class="class-name">Runtime</span>.getRuntime().availableProcessors();
<span class="class-name">ExecutorService</span> cpuPool = <span class="class-name">Executors</span>.newFixedThreadPool(cpuCores);

<span class="comment">// I/O-intensive tasks (network, file operations)</span>
<span class="class-name">ExecutorService</span> ioPool = <span class="class-name">Executors</span>.newFixedThreadPool(cpuCores * <span class="number">2</span>);</code></pre>
        </section>

        <section class="content-section">
            <h2>Why It Matters</h2>
            <ul>
                <li><strong>Performance:</strong> Reusing threads is much faster than creating new ones</li>
                <li><strong>Resource Management:</strong> Prevents system overload from too many threads</li>
                <li><strong>Scalability:</strong> Handle thousands of tasks with limited resources</li>
                <li><strong>Simplicity:</strong> Easier to manage than manual thread creation</li>
                <li><strong>Professional Standard:</strong> Industry best practice for concurrent programming</li>
            </ul>

            <div class="info-box note">
                <div class="info-box-title">Remember</div>
                <p>Thread pools are like having a skilled team ready to work, rather than hiring and training someone new for every single task. Much more efficient!</p>
            </div>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="multithreading.html" class="related-link">Multithreading & Concurrency</a>
                <a href="synchronization.html" class="related-link">Synchronization Mechanisms</a>
                <a href="../fundamentals/lambda-streams.html" class="related-link">Lambda & Streams</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
