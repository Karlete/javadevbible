<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annotations - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#advanced">Advanced Java</a> / Annotations
            </nav>
            <h1>Annotations</h1>
            <p class="topic-subtitle">Metadata to Add Information to Your Code</p>
            <a href="../../index.html" class="back-btn">‚Üê Back to Index</a>
        </div>
    </header>

    <main class="topic-content">

            <section class="content-section">
                <h2>What Are Annotations?</h2>
                <p><strong>Think of annotations like sticky notes or labels you put on your code:</strong></p>
                <ul>
                    <li>üìù A sticky note on a method: "@Override - Remember to implement this properly!"</li>
                    <li>‚ö†Ô∏è A warning label: "@Deprecated - Don't use this anymore!"</li>
                    <li>üè∑Ô∏è A tag on a class: "@Entity - This is a database table!"</li>
                </ul>

                <div class="info-box">
                    <p><strong>What Is an Annotation?</strong></p>
                    <p>An annotation is <strong>metadata</strong> (data about data) that you attach to your code. It doesn't change what your code does by itself, but it gives information to:</p>
                    <ul>
                        <li>The Java compiler (to check for errors)</li>
                        <li>Build tools (like Maven or Gradle)</li>
                        <li>Frameworks (like Spring or Hibernate)</li>
                        <li>Your own code (via Reflection)</li>
                    </ul>
                </div>

                <p><strong>Basic Syntax:</strong></p>
                <div class="code-block">
                    <pre><code>@AnnotationName
public class MyClass {
    @AnnotationName
    private String field;

    @AnnotationName
    public void method() { }
}</code></pre>
                </div>
                <p>Annotations start with <code>@</code> and can be placed on classes, methods, fields, parameters, etc.</p>
            </section>

            <section class="content-section">
                <h2>Built-In Annotations (Java Provides)</h2>

                <h3>1. @Override - "I'm replacing a parent method"</h3>
                <div class="code-block">
                    <pre><code>class Animal {
    public void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    @Override  // Tells compiler: "I'm overriding makeSound()"
    public void makeSound() {
        System.out.println("Woof!");
    }

    // Typo in method name? Compiler catches it!
    @Override
    public void makeSoud() {  // ‚ùå ERROR: Method doesn't override anything
        System.out.println("Woof!");
    }
}</code></pre>
                </div>
                <p><strong>Why use it?</strong> The compiler verifies you're actually overriding. Catches typos and signature mistakes!</p>

                <h3>2. @Deprecated - "Don't use this anymore"</h3>
                <div class="code-block">
                    <pre><code>public class Calculator {
    @Deprecated  // Old method, don't use!
    public int add(int a, int b) {
        return a + b;
    }

    // New improved method
    public long addNumbers(long a, long b) {
        return a + b;
    }
}

// Usage
Calculator calc = new Calculator();
calc.add(5, 10);  // ‚ö†Ô∏è Warning: 'add(int, int)' is deprecated</code></pre>
                </div>
                <p><strong>What happens?</strong> Compiler shows warnings, but code still works. It's a gentle nudge to use the new method.</p>

                <h3>3. @SuppressWarnings - "I know what I'm doing"</h3>
                <div class="code-block">
                    <pre><code>@SuppressWarnings("unchecked")  // Hide unchecked warnings
public void oldCode() {
    List list = new ArrayList();  // Raw type - normally warns
    list.add("Hello");
}

@SuppressWarnings({"unused", "deprecation"})  // Multiple warnings
public void legacyMethod() {
    int unusedVariable = 10;
    Date date = new Date(2024, 1, 1);  // Deprecated constructor
}</code></pre>
                </div>
                <p><strong>Common values:</strong> "unchecked", "deprecation", "unused", "rawtypes"</p>

                <h3>4. @FunctionalInterface - "This interface has exactly one method"</h3>
                <div class="code-block">
                    <pre><code>@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);  // One abstract method

    // Can have default/static methods
    default void print(int result) {
        System.out.println("Result: " + result);
    }
}

// Use with lambda
Calculator add = (a, b) -> a + b;
System.out.println(add.calculate(5, 3));  // 8</code></pre>
                </div>
                <p><strong>Purpose:</strong> Ensures interface can be used with lambdas. Compiler errors if you add a second abstract method.</p>

                <h3>5. @SafeVarargs - "Trust me, varargs is safe"</h3>
                <div class="code-block">
                    <pre><code>@SafeVarargs  // Suppresses heap pollution warning
public static <T> void printAll(T... items) {
    for (T item : items) {
        System.out.println(item);
    }
}

printAll("Hello", "World", "!");  // Works fine</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Creating Custom Annotations</h2>
                <p>You can create your own annotations! Here's how:</p>

                <h3>Example 1: Simple Annotation</h3>
                <div class="code-block">
                    <pre><code>// Define annotation
public @interface Author {
    String name();
    String date();
}

// Use annotation
@Author(name = "Alice", date = "2024-01-15")
public class MyClass {
    // class code
}</code></pre>
                </div>

                <h3>Example 2: Annotation with Default Values</h3>
                <div class="code-block">
                    <pre><code>public @interface Test {
    String name() default "Test";
    int timeout() default 5000;  // milliseconds
    boolean enabled() default true;
}

// Usage - can omit defaults
@Test
public void testMethod1() { }

@Test(name = "Custom Test", timeout = 10000)
public void testMethod2() { }

@Test(enabled = false)  // This test is disabled
public void testMethod3() { }</code></pre>
                </div>

                <h3>Example 3: Single-Value Annotation</h3>
                <div class="code-block">
                    <pre><code>public @interface Version {
    String value();  // Special name "value"
}

// Can use shorthand syntax
@Version("1.0")  // Instead of @Version(value = "1.0")
public class Product { }</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Meta-Annotations (Annotations on Annotations)</h2>
                <p>These annotations control how your custom annotations behave:</p>

                <h3>1. @Retention - "How long should this annotation live?"</h3>
                <div class="code-block">
                    <pre><code>import java.lang.annotation.*;

// Lives only in source code (discarded after compilation)
@Retention(RetentionPolicy.SOURCE)
public @interface MySourceAnnotation { }

// Lives in .class file but not at runtime
@Retention(RetentionPolicy.CLASS)
public @interface MyClassAnnotation { }

// Lives at runtime (can read with Reflection)
@Retention(RetentionPolicy.RUNTIME)  // ‚úÖ Most common!
public @interface MyRuntimeAnnotation { }</code></pre>
                </div>

                <div class="info-box">
                    <p><strong>Retention Policies:</strong></p>
                    <ul>
                        <li><strong>SOURCE:</strong> Only in .java files (e.g., @Override)</li>
                        <li><strong>CLASS:</strong> In .class files but JVM discards it (default)</li>
                        <li><strong>RUNTIME:</strong> Available at runtime via Reflection (most useful!)</li>
                    </ul>
                </div>

                <h3>2. @Target - "Where can this annotation be used?"</h3>
                <div class="code-block">
                    <pre><code>import java.lang.annotation.*;

// Can only be used on methods
@Target(ElementType.METHOD)
public @interface Test { }

// Can be used on classes and interfaces
@Target({ElementType.TYPE})
public @interface Entity { }

// Can be used on fields
@Target(ElementType.FIELD)
public @interface Column { }

// Can be used anywhere!
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
public @interface Custom { }</code></pre>
                </div>

                <p><strong>Common ElementTypes:</strong></p>
                <ul>
                    <li><code>TYPE</code> - Classes, interfaces, enums</li>
                    <li><code>METHOD</code> - Methods</li>
                    <li><code>FIELD</code> - Fields/attributes</li>
                    <li><code>PARAMETER</code> - Method parameters</li>
                    <li><code>CONSTRUCTOR</code> - Constructors</li>
                    <li><code>LOCAL_VARIABLE</code> - Local variables</li>
                    <li><code>ANNOTATION_TYPE</code> - Other annotations</li>
                </ul>

                <h3>3. @Documented - "Show in JavaDoc"</h3>
                <div class="code-block">
                    <pre><code>@Documented  // Will appear in generated documentation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Important { }</code></pre>
                </div>

                <h3>4. @Inherited - "Subclasses inherit this"</h3>
                <div class="code-block">
                    <pre><code>@Inherited  // Subclasses automatically get this annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Auditable { }

@Auditable
class Parent { }

class Child extends Parent { }  // Child is also @Auditable!</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Real-World Example: Custom Annotation</h2>
                <p>Let's create a complete example with annotation processing:</p>

                <div class="code-block">
                    <pre><code>import java.lang.annotation.*;

// 1. Define annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Performance {
    String description() default "Performance test";
    int iterations() default 1000;
}

// 2. Use annotation
public class Calculator {
    @Performance(description = "Testing addition", iterations = 10000)
    public int add(int a, int b) {
        return a + b;
    }

    @Performance(iterations = 5000)
    public int multiply(int a, int b) {
        return a * b;
    }

    public int subtract(int a, int b) {
        return a - b;  // No annotation
    }
}

// 3. Process annotation with Reflection
import java.lang.reflect.Method;

public class PerformanceTester {
    public static void testClass(Class<?> clazz) throws Exception {
        Object obj = clazz.getDeclaredConstructor().newInstance();

        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Performance.class)) {
                Performance perf = method.getAnnotation(Performance.class);

                System.out.println("Testing: " + perf.description());
                System.out.println("Iterations: " + perf.iterations());

                long start = System.nanoTime();
                for (int i = 0; i < perf.iterations(); i++) {
                    method.invoke(obj, 5, 3);
                }
                long end = System.nanoTime();

                System.out.println("Time: " + (end - start) / 1_000_000 + " ms");
                System.out.println("---");
            }
        }
    }

    public static void main(String[] args) throws Exception {
        testClass(Calculator.class);
    }
}</code></pre>
                </div>

                <p><strong>Output:</strong></p>
                <div class="code-block">
                    <pre><code>Testing: Testing addition
Iterations: 10000
Time: 2 ms
---
Testing: Performance test
Iterations: 5000
Time: 1 ms
---</code></pre>
                </div>

                <p><strong>What happened?</strong></p>
                <ol>
                    <li>We created @Performance annotation with description and iterations</li>
                    <li>We applied it to some methods (not all)</li>
                    <li>We used Reflection to find methods with @Performance</li>
                    <li>We read annotation values and ran performance tests</li>
                    <li>Methods without @Performance were skipped</li>
                </ol>
            </section>

            <section class="content-section">
                <h2>Framework Examples (How Others Use Annotations)</h2>

                <h3>Spring Framework</h3>
                <div class="code-block">
                    <pre><code>@RestController  // This is a REST API controller
@RequestMapping("/api/users")
public class UserController {

    @Autowired  // Inject dependency automatically
    private UserService userService;

    @GetMapping("/{id}")  // Handle GET /api/users/123
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }

    @PostMapping  // Handle POST /api/users
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}</code></pre>
                </div>
                <p>Spring reads these annotations and automatically configures routing, dependency injection, and more!</p>

                <h3>JUnit Testing</h3>
                <div class="code-block">
                    <pre><code>public class CalculatorTest {

    @BeforeEach  // Runs before each test
    public void setUp() {
        System.out.println("Setting up test...");
    }

    @Test  // This is a test method
    public void testAddition() {
        assertEquals(5, 2 + 3);
    }

    @Test
    @Disabled("Not ready yet")  // Skip this test
    public void testDivision() {
        assertEquals(2, 4 / 2);
    }

    @AfterEach  // Runs after each test
    public void tearDown() {
        System.out.println("Cleaning up...");
    }
}</code></pre>
                </div>

                <h3>Hibernate/JPA</h3>
                <div class="code-block">
                    <pre><code>@Entity  // This class maps to a database table
@Table(name = "users")
public class User {

    @Id  // Primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name", length = 50, nullable = false)
    private String username;

    @Column(unique = true)
    private String email;

    @OneToMany(mappedBy = "user")  // One user has many orders
    private List<Order> orders;

    // getters/setters
}</code></pre>
                </div>
                <p>Hibernate reads these annotations and creates database tables, handles relationships, etc.</p>

                <h3>Lombok (Code Generation)</h3>
                <div class="code-block">
                    <pre><code>@Data  // Generates getters, setters, toString, equals, hashCode
@NoArgsConstructor  // Generates no-argument constructor
@AllArgsConstructor  // Generates constructor with all fields
public class Product {
    private Long id;
    private String name;
    private double price;
}

// You get ALL this for free (at compile time):
// - Getters: getId(), getName(), getPrice()
// - Setters: setId(), setName(), setPrice()
// - toString(), equals(), hashCode()
// - new Product() constructor
// - new Product(id, name, price) constructor</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Reading Annotations with Reflection</h2>
                <p>Here's how to check and read annotations at runtime:</p>

                <div class="code-block">
                    <pre><code>import java.lang.reflect.*;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@interface Info {
    String author();
    int version() default 1;
}

@Info(author = "Alice", version = 2)
class MyClass {
    @Info(author = "Bob")
    private String field;

    @Info(author = "Charlie", version = 3)
    public void method() { }
}

public class AnnotationReader {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = MyClass.class;

        // Check if class has annotation
        if (clazz.isAnnotationPresent(Info.class)) {
            Info info = clazz.getAnnotation(Info.class);
            System.out.println("Class author: " + info.author());
            System.out.println("Class version: " + info.version());
        }

        // Read field annotations
        Field field = clazz.getDeclaredField("field");
        if (field.isAnnotationPresent(Info.class)) {
            Info info = field.getAnnotation(Info.class);
            System.out.println("Field author: " + info.author());
        }

        // Read method annotations
        Method method = clazz.getMethod("method");
        Info info = method.getAnnotation(Info.class);
        System.out.println("Method author: " + info.author());
        System.out.println("Method version: " + info.version());

        // Get all annotations on a class
        Annotation[] annotations = clazz.getAnnotations();
        for (Annotation ann : annotations) {
            System.out.println("Found: " + ann);
        }
    }
}</code></pre>
                </div>

                <p><strong>Output:</strong></p>
                <div class="code-block">
                    <pre><code>Class author: Alice
Class version: 2
Field author: Bob
Method author: Charlie
Method version: 3
Found: @Info(author="Alice", version=2)</code></pre>
                </div>

                <p><strong>Key methods:</strong></p>
                <ul>
                    <li><code>isAnnotationPresent(Class)</code> - Check if annotation exists</li>
                    <li><code>getAnnotation(Class)</code> - Get specific annotation</li>
                    <li><code>getAnnotations()</code> - Get all annotations</li>
                    <li><code>getDeclaredAnnotations()</code> - Get annotations (excluding inherited)</li>
                </ul>
            </section>

            <section class="content-section">
                <h2>Repeating Annotations (Java 8+)</h2>
                <p>You can apply the same annotation multiple times:</p>

                <div class="code-block">
                    <pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Schedules.class)  // Enable repeating
public @interface Schedule {
    String day();
    String time();
}

// Container annotation (required for @Repeatable)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Schedules {
    Schedule[] value();
}

// Usage - apply multiple times!
public class TaskRunner {
    @Schedule(day = "Monday", time = "9:00 AM")
    @Schedule(day = "Wednesday", time = "2:00 PM")
    @Schedule(day = "Friday", time = "4:00 PM")
    public void runBackup() {
        System.out.println("Running backup...");
    }
}

// Reading
Method method = TaskRunner.class.getMethod("runBackup");
Schedule[] schedules = method.getAnnotationsByType(Schedule.class);
for (Schedule s : schedules) {
    System.out.println(s.day() + " at " + s.time());
}</code></pre>
                </div>

                <p><strong>Output:</strong></p>
                <div class="code-block">
                    <pre><code>Monday at 9:00 AM
Wednesday at 2:00 PM
Friday at 4:00 PM</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Annotation Processing (Compile-Time)</h2>
                <p>Advanced: Process annotations during compilation to generate code!</p>

                <div class="info-box">
                    <p><strong>How It Works:</strong></p>
                    <ol>
                        <li>You create an annotation processor (extends AbstractProcessor)</li>
                        <li>During compilation, processor scans for annotations</li>
                        <li>Processor generates new Java files or resources</li>
                        <li>Generated code is compiled along with your code</li>
                    </ol>
                    <p>This is how Lombok, MapStruct, and other code generators work!</p>
                </div>

                <div class="code-block">
                    <pre><code>// Simple example (actual processors are more complex)
@SupportedAnnotationTypes("com.example.Builder")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class BuilderProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations,
                          RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(Builder.class)) {
            // Generate builder class code
            String builderCode = generateBuilder(element);
            // Write to file
            writeJavaFile(builderCode);
        }
        return true;
    }
}</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Best Practices</h2>

                <div class="best-practices">
                    <h3>‚úÖ DO:</h3>
                    <ul>
                        <li><strong>Use @Override always</strong> - Catches typos and signature mistakes</li>
                        <li><strong>Make annotations RUNTIME if using Reflection</strong> - Otherwise can't read them</li>
                        <li><strong>Provide default values</strong> - Makes annotations easier to use</li>
                        <li><strong>Specify @Target precisely</strong> - Prevents misuse</li>
                        <li><strong>Document your annotations</strong> - Explain what they do and how to use them</li>
                        <li><strong>Keep annotations simple</strong> - Don't add too many parameters</li>
                        <li><strong>Use meaningful names</strong> - @Test is better than @T</li>
                    </ul>

                    <h3>‚ùå DON'T:</h3>
                    <ul>
                        <li><strong>Don't put logic in annotations</strong> - They're metadata, not code</li>
                        <li><strong>Don't abuse @SuppressWarnings</strong> - Fix warnings instead of hiding them</li>
                        <li><strong>Don't create annotations for everything</strong> - Only when truly needed</li>
                        <li><strong>Don't forget @Retention</strong> - Default is CLASS (not RUNTIME!)</li>
                        <li><strong>Don't make annotations too complex</strong> - Keep them simple and focused</li>
                    </ul>
                </div>
            </section>

            <section class="content-section">
                <h2>Common Use Cases</h2>

                <h3>1. Validation</h3>
                <div class="code-block">
                    <pre><code>public class User {
    @NotNull
    @Size(min = 3, max = 50)
    private String username;

    @Email
    private String email;

    @Min(18)
    @Max(150)
    private int age;
}</code></pre>
                </div>

                <h3>2. Dependency Injection</h3>
                <div class="code-block">
                    <pre><code>@Component
public class UserService {
    @Autowired
    private UserRepository repository;

    @PostConstruct
    public void init() {
        // Runs after construction
    }
}</code></pre>
                </div>

                <h3>3. Testing</h3>
                <div class="code-block">
                    <pre><code>@RunWith(MockitoJUnitRunner.class)
public class ServiceTest {
    @Mock
    private Repository repository;

    @InjectMocks
    private Service service;

    @Test
    public void testMethod() {
        // test code
    }
}</code></pre>
                </div>

                <h3>4. REST APIs</h3>
                <div class="code-block">
                    <pre><code>@RestController
public class API {
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return findUser(id);
    }

    @PostMapping("/users")
    @ResponseStatus(HttpStatus.CREATED)
    public User create(@RequestBody User user) {
        return save(user);
    }
}</code></pre>
                </div>
            </section>

            <section class="content-section">
                <h2>Summary</h2>
                <div class="info-box">
                    <ul>
                        <li><strong>Annotations</strong> are metadata (@Something) attached to code elements</li>
                        <li><strong>Built-in:</strong> @Override, @Deprecated, @SuppressWarnings, @FunctionalInterface</li>
                        <li><strong>Custom:</strong> Use <code>public @interface Name { }</code> to create your own</li>
                        <li><strong>@Retention:</strong> Controls lifetime (SOURCE, CLASS, RUNTIME)</li>
                        <li><strong>@Target:</strong> Controls where annotation can be used</li>
                        <li><strong>Frameworks:</strong> Spring, Hibernate, JUnit use annotations extensively</li>
                        <li><strong>Reflection:</strong> Read annotations at runtime with <code>getAnnotation()</code></li>
                        <li><strong>Processors:</strong> Can generate code at compile-time</li>
                        <li><strong>Purpose:</strong> Reduce boilerplate, configure frameworks, validate code</li>
                    </ul>
                </div>
            </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="reflection.html" class="related-link">Reflection API</a>
                <a href="../fundamentals/oop-basics.html" class="related-link">OOP Basics</a>
                <a href="design-patterns.html" class="related-link">Design Patterns</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>