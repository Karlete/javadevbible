<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is an Application Server? - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#servers">Application Servers</a> / What is an Application Server?
            </nav>
            <h1>What is an Application Server?</h1>
            <p class="topic-subtitle">Understanding the runtime environment for your Java applications</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>Introduction: Where Does Your Code Actually Run?</h2>
            <p>When you write a Java web application, you create classes, controllers, services, and HTML templates. But have you ever wondered: <strong>what actually runs your code?</strong> When a user visits your website, something needs to:</p>
            <ul>
                <li>Listen for incoming HTTP requests on a network port</li>
                <li>Parse the HTTP protocol and extract the request details</li>
                <li>Route the request to your code</li>
                <li>Execute your code and get the response</li>
                <li>Send the HTTP response back to the user's browser</li>
            </ul>

            <p>This "something" is an <strong>Application Server</strong> (or a simpler variant called a <strong>Web Server</strong> or <strong>Servlet Container</strong>). It's the runtime environment that hosts your application and handles all the low-level networking, protocol parsing, and lifecycle management so you can focus on writing business logic.</p>

            <h3>A Simple Analogy: The Restaurant</h3>
            <p>Think of deploying a web application like opening a restaurant:</p>
            <ul>
                <li><strong>Your Application (The Menu & Recipes):</strong> This is what YOU create—the dishes, recipes, and dining experience. In software terms, your controllers, services, business logic.</li>
                <li><strong>The Application Server (The Restaurant Building):</strong> The physical infrastructure—kitchen equipment, tables, plumbing, electricity, ventilation. You don't build these from scratch; you rent or buy a space that has them.</li>
                <li><strong>HTTP Requests (Customers):</strong> People come to the door wanting food. The building receives them.</li>
                <li><strong>The Server's Role:</strong> The building provides everything needed to serve customers—you just provide the food and service.</li>
            </ul>

            <div class="info-box">
                <p><strong>An Application Server</strong> is software that provides the runtime environment for applications. For Java web applications, it:</p>
                <ul>
                    <li><strong>Listens</strong> for incoming network connections (typically HTTP on port 80/443 or 8080)</li>
                    <li><strong>Manages</strong> the lifecycle of your application (loading, starting, stopping)</li>
                    <li><strong>Provides</strong> services like connection pooling, transactions, security, and more</li>
                    <li><strong>Executes</strong> your code when requests arrive</li>
                    <li><strong>Handles</strong> multiple concurrent users efficiently</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Web Server vs Application Server vs Servlet Container</h2>
            <p>These terms are often used interchangeably, but they have distinct meanings. Understanding the differences helps you choose the right tool.</p>

            <h3>Web Server</h3>
            <p>A <strong>Web Server</strong> serves static content (HTML, CSS, JavaScript, images) and handles HTTP protocol basics. It's like a file server that speaks HTTP.</p>
            <pre><code><span class="comment">// Web servers serve STATIC content</span>
<span class="comment">// They read files from disk and send them over HTTP</span>

User requests: GET /index.html
Web server: Reads /var/www/index.html from disk
Web server: Sends file content back with HTTP headers

<span class="comment">// Examples of pure web servers:</span>
<span class="comment">// - Apache HTTP Server (httpd)</span>
<span class="comment">// - Nginx</span>
<span class="comment">// - Microsoft IIS (for static content)</span>

<span class="comment">// Web servers are FAST for static files</span>
<span class="comment">// But they can't run your Java code!</span></code></pre>

            <h3>Servlet Container (Web Container)</h3>
            <p>A <strong>Servlet Container</strong> extends the web server concept by adding the ability to run Java Servlets. It implements the Java Servlet specification, allowing dynamic content generation.</p>
            <pre><code><span class="comment">// Servlet containers can run Java code!</span>
<span class="comment">// They implement the Servlet specification</span>

User requests: GET /api/users
Servlet container:
  1. Parses HTTP request
  2. Creates HttpServletRequest object
  3. Finds matching Servlet (@WebServlet or mapping in web.xml)
  4. Calls servlet.service(request, response)
  5. Your Java code executes!
  6. Sends HttpServletResponse back to user

<span class="comment">// Examples of Servlet containers:</span>
<span class="comment">// - Apache Tomcat (most popular)</span>
<span class="comment">// - Eclipse Jetty</span>
<span class="comment">// - Undertow (used in WildFly)</span>

<span class="comment">// Servlet containers implement:</span>
<span class="comment">// - Jakarta Servlet specification</span>
<span class="comment">// - Jakarta Server Pages (JSP)</span>
<span class="comment">// - Jakarta WebSocket</span></code></pre>

            <h3>Application Server (Full Jakarta EE)</h3>
            <p>A <strong>Full Application Server</strong> includes everything a servlet container has, PLUS additional enterprise services defined by the Jakarta EE (formerly Java EE) specification.</p>
            <pre><code><span class="comment">// Application servers provide the FULL Jakarta EE stack</span>

<span class="comment">// Everything in a Servlet Container, PLUS:</span>
<span class="comment">// - EJB (Enterprise JavaBeans) container</span>
<span class="comment">// - JPA (Java Persistence API) integration</span>
<span class="comment">// - JTA (Java Transaction API)</span>
<span class="comment">// - JMS (Java Message Service)</span>
<span class="comment">// - CDI (Contexts and Dependency Injection)</span>
<span class="comment">// - JAX-RS (RESTful Web Services)</span>
<span class="comment">// - Jakarta Security</span>
<span class="comment">// - And much more...</span>

<span class="comment">// Examples of full application servers:</span>
<span class="comment">// - WildFly (formerly JBoss)</span>
<span class="comment">// - Payara (GlassFish fork)</span>
<span class="comment">// - IBM WebSphere Liberty</span>
<span class="comment">// - Oracle WebLogic</span>
<span class="comment">// - Apache TomEE (Tomcat + EE)</span></code></pre>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Web Server</th>
                        <th>Servlet Container</th>
                        <th>Application Server</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Static Content</strong></td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Servlets/JSP</strong></td>
                        <td>No</td>
                        <td>Yes</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><strong>EJB</strong></td>
                        <td>No</td>
                        <td>No</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><strong>JMS</strong></td>
                        <td>No</td>
                        <td>No</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><strong>JTA Transactions</strong></td>
                        <td>No</td>
                        <td>No</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Examples</strong></td>
                        <td>Nginx, Apache</td>
                        <td>Tomcat, Jetty</td>
                        <td>WildFly, WebLogic</td>
                    </tr>
                    <tr>
                        <td><strong>Complexity</strong></td>
                        <td>Low</td>
                        <td>Medium</td>
                        <td>High</td>
                    </tr>
                    <tr>
                        <td><strong>Resource Usage</strong></td>
                        <td>Low</td>
                        <td>Medium</td>
                        <td>High</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="content-section">
            <h2>What About Spring Boot?</h2>
            <p>If you've used Spring Boot, you might be confused—you don't deploy to an external server; you just run a JAR file! This is because Spring Boot takes a different approach: <strong>embedded servers</strong>.</p>

            <h3>Traditional Deployment (External Server)</h3>
            <pre><code><span class="comment">// Traditional approach: Deploy WAR to external server</span>

<span class="comment">// 1. You build a WAR file</span>
mvn package
<span class="comment">// Output: myapp.war</span>

<span class="comment">// 2. You have a server installed separately</span>
<span class="comment">//    /opt/tomcat/</span>

<span class="comment">// 3. You deploy by copying WAR to server</span>
cp myapp.war /opt/tomcat/webapps/

<span class="comment">// 4. Server detects and deploys your app</span>
<span class="comment">//    Available at: http://localhost:8080/myapp</span>

<span class="comment">// The server exists OUTSIDE your application</span>
┌─────────────────────────────────────────┐
│           TOMCAT SERVER                  │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │ myapp   │ │ other   │ │ another │   │
│  │  .war   │ │  .war   │ │  .war   │   │
│  └─────────┘ └─────────┘ └─────────┘   │
│                                         │
│  One server hosts MULTIPLE applications │
└─────────────────────────────────────────┘</code></pre>

            <h3>Spring Boot (Embedded Server)</h3>
            <pre><code><span class="comment">// Spring Boot approach: Server is INSIDE your application</span>

<span class="comment">// 1. You build an executable JAR</span>
mvn package
<span class="comment">// Output: myapp.jar (includes Tomcat inside!)</span>

<span class="comment">// 2. You just run it!</span>
java -jar myapp.jar
<span class="comment">// Available at: http://localhost:8080</span>

<span class="comment">// The server is EMBEDDED in your application</span>
┌─────────────────────────────────────────┐
│              myapp.jar                   │
│  ┌─────────────────────────────────┐    │
│  │     YOUR APPLICATION CODE       │    │
│  │   (Controllers, Services, etc.) │    │
│  └─────────────────────────────────┘    │
│  ┌─────────────────────────────────┐    │
│  │     EMBEDDED TOMCAT             │    │
│  │   (Inside your JAR file!)       │    │
│  └─────────────────────────────────┘    │
│                                         │
│  Self-contained, runs anywhere with JVM │
└─────────────────────────────────────────┘</code></pre>

            <h3>Why Embedded Servers Became Popular</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>External Server</th>
                        <th>Embedded Server (Spring Boot)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Deployment</strong></td>
                        <td>Copy WAR to server</td>
                        <td>Just run the JAR</td>
                    </tr>
                    <tr>
                        <td><strong>Configuration</strong></td>
                        <td>Server + App configured separately</td>
                        <td>All in one place</td>
                    </tr>
                    <tr>
                        <td><strong>Server Version</strong></td>
                        <td>Whatever's installed on server</td>
                        <td>You control it (in pom.xml)</td>
                    </tr>
                    <tr>
                        <td><strong>Multiple Apps</strong></td>
                        <td>Many apps on one server</td>
                        <td>One app per process</td>
                    </tr>
                    <tr>
                        <td><strong>Docker Friendly</strong></td>
                        <td>More complex</td>
                        <td>Very easy</td>
                    </tr>
                    <tr>
                        <td><strong>Cloud Native</strong></td>
                        <td>Traditional</td>
                        <td>Modern, 12-factor</td>
                    </tr>
                    <tr>
                        <td><strong>Startup Time</strong></td>
                        <td>Server already running</td>
                        <td>Server starts with app</td>
                    </tr>
                </tbody>
            </table>

            <div class="info-box note">
                <div class="info-box-title">Modern Reality</div>
                <p>Today, most new Java applications use <strong>embedded servers</strong> (Spring Boot, Quarkus, Micronaut). External application servers are still used in large enterprises with existing infrastructure, or when you need full Jakarta EE features that embedded servers don't provide.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>How an Application Server Handles Requests</h2>
            <p>Let's trace what happens when a user requests a page from your Java web application:</p>

            <pre><code><span class="comment">// User types: http://myapp.com/products/123</span>
<span class="comment">// Here's what happens inside the application server:</span>

┌─────────────────────────────────────────────────────────────────────┐
│                     APPLICATION SERVER                               │
│                                                                      │
│  1. CONNECTOR (Listens on port 8080)                                │
│     ┌─────────────────────────────────────────────────────────┐     │
│     │  - Accepts TCP connection from browser                   │     │
│     │  - Reads raw bytes from network                         │     │
│     │  - Parses HTTP protocol                                 │     │
│     │  - Creates internal request object                       │     │
│     └─────────────────────────────────────────────────────────┘     │
│                              │                                       │
│                              ▼                                       │
│  2. ENGINE (Request Processing)                                      │
│     ┌─────────────────────────────────────────────────────────┐     │
│     │  - Determines which Host (virtual host) handles request │     │
│     │  - Determines which Context (application) handles it    │     │
│     │  - Determines which Servlet handles the URL pattern     │     │
│     └─────────────────────────────────────────────────────────┘     │
│                              │                                       │
│                              ▼                                       │
│  3. FILTER CHAIN                                                     │
│     ┌─────────────────────────────────────────────────────────┐     │
│     │  Security Filter → Logging Filter → CORS Filter → ...   │     │
│     └─────────────────────────────────────────────────────────┘     │
│                              │                                       │
│                              ▼                                       │
│  4. YOUR SERVLET (or Spring Controller)                              │
│     ┌─────────────────────────────────────────────────────────┐     │
│     │  @GetMapping("/products/{id}")                          │     │
│     │  public Product getProduct(@PathVariable Long id) {     │     │
│     │      return productService.findById(id);                │     │
│     │  }                                                       │     │
│     └─────────────────────────────────────────────────────────┘     │
│                              │                                       │
│                              ▼                                       │
│  5. RESPONSE (travels back through filters, connector, to browser)  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘</code></pre>

            <h3>Key Components Explained</h3>
            <ul>
                <li><strong>Connector:</strong> The network listener. Handles TCP connections and HTTP parsing. You can have multiple connectors (HTTP on 8080, HTTPS on 8443, etc.)</li>
                <li><strong>Engine:</strong> The request processor. Routes requests to the correct application and servlet.</li>
                <li><strong>Host:</strong> Virtual host support. One server can handle requests for multiple domains (app1.com, app2.com).</li>
                <li><strong>Context:</strong> Your application. Each WAR file becomes a context.</li>
                <li><strong>Servlet:</strong> Your code that handles specific URL patterns.</li>
            </ul>
        </section>

        <section class="content-section">
            <h2>Services Provided by Application Servers</h2>
            <p>Application servers do much more than just route HTTP requests. They provide many services that your application can use:</p>

            <h3>1. Connection Pooling</h3>
            <pre><code><span class="comment">// Problem: Creating database connections is SLOW (100-500ms each)</span>
<span class="comment">// Solution: Server maintains a pool of ready connections</span>

<span class="comment">// Without pooling:</span>
<span class="keyword">public</span> List&lt;User&gt; getUsers() {
    Connection conn = DriverManager.getConnection(url, user, pass); <span class="comment">// SLOW!</span>
    <span class="comment">// ... query ...</span>
    conn.close(); <span class="comment">// Connection destroyed, next request creates new one</span>
}

<span class="comment">// With pooling (configured in server):</span>
<span class="annotation">@Resource</span>
DataSource dataSource;  <span class="comment">// Server manages the pool</span>

<span class="keyword">public</span> List&lt;User&gt; getUsers() {
    Connection conn = dataSource.getConnection(); <span class="comment">// FAST! Gets existing connection</span>
    <span class="comment">// ... query ...</span>
    conn.close(); <span class="comment">// Returns to pool, doesn't destroy</span>
}

<span class="comment">// Server configuration (context.xml in Tomcat):</span>
&lt;Resource name="jdbc/mydb"
          type="javax.sql.DataSource"
          maxTotal="100"           <span class="comment">&lt;!-- Max 100 connections --&gt;</span>
          maxIdle="30"             <span class="comment">&lt;!-- Keep 30 ready --&gt;</span>
          maxWaitMillis="10000"/&gt;  <span class="comment">&lt;!-- Wait max 10s for connection --&gt;</span></code></pre>

            <h3>2. Thread Management</h3>
            <pre><code><span class="comment">// Server manages a thread pool for handling requests</span>

<span class="comment">// Each request gets a thread from the pool</span>
<span class="comment">// You don't create threads manually!</span>

┌─────────────────────────────────────────┐
│           THREAD POOL                    │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐        │
│  │ T1│ │ T2│ │ T3│ │...│ │T200│        │
│  └───┘ └───┘ └───┘ └───┘ └───┘        │
│    │     │     │                        │
│    ▼     ▼     ▼                        │
│  Req1  Req2  Req3   (requests assigned) │
└─────────────────────────────────────────┘

<span class="comment">// Tomcat default: 200 threads max</span>
<span class="comment">// If 201 requests come simultaneously, one waits</span>

<span class="comment">// Configuration (server.xml):</span>
&lt;Connector port="8080"
           maxThreads="200"
           minSpareThreads="10"
           acceptCount="100"/&gt;</code></pre>

            <h3>3. Session Management</h3>
            <pre><code><span class="comment">// Server tracks user sessions across requests</span>

<span class="annotation">@GetMapping</span>(<span class="string">"/cart"</span>)
<span class="keyword">public</span> Cart getCart(HttpSession session) {
    <span class="comment">// Server automatically:</span>
    <span class="comment">// 1. Reads JSESSIONID cookie from request</span>
    <span class="comment">// 2. Looks up session data in memory</span>
    <span class="comment">// 3. Provides it to your code</span>

    Cart cart = (Cart) session.getAttribute(<span class="string">"cart"</span>);
    <span class="keyword">return</span> cart;
}

<span class="comment">// Session configuration (web.xml):</span>
&lt;session-config&gt;
    &lt;session-timeout&gt;30&lt;/session-timeout&gt;  <span class="comment">&lt;!-- 30 minutes --&gt;</span>
    &lt;cookie-config&gt;
        &lt;http-only&gt;true&lt;/http-only&gt;
        &lt;secure&gt;true&lt;/secure&gt;
    &lt;/cookie-config&gt;
&lt;/session-config&gt;</code></pre>

            <h3>4. Security</h3>
            <pre><code><span class="comment">// Server can handle authentication and authorization</span>

<span class="comment">// web.xml security configuration:</span>
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;

&lt;login-config&gt;
    &lt;auth-method&gt;FORM&lt;/auth-method&gt;
    &lt;form-login-config&gt;
        &lt;form-login-page&gt;/login.html&lt;/form-login-page&gt;
        &lt;form-error-page&gt;/error.html&lt;/form-error-page&gt;
    &lt;/form-login-config&gt;
&lt;/login-config&gt;</code></pre>

            <h3>5. JNDI (Java Naming and Directory Interface)</h3>
            <pre><code><span class="comment">// Server provides a registry for looking up resources</span>
<span class="comment">// Your app doesn't hardcode connection strings!</span>

<span class="comment">// In your code - just look up by name:</span>
<span class="annotation">@Resource</span>(name = <span class="string">"jdbc/productionDB"</span>)
DataSource dataSource;

<span class="comment">// Server configures the ACTUAL connection:</span>
<span class="comment">// Development server → points to dev database</span>
<span class="comment">// Production server → points to production database</span>
<span class="comment">// Same code, different configuration!</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Popular Application Servers</h2>

            <h3>Servlet Containers (Lightweight)</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Server</th>
                        <th>Description</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Apache Tomcat</strong></td>
                        <td>Most popular, reference implementation</td>
                        <td>Most Java web apps, Spring Boot default</td>
                    </tr>
                    <tr>
                        <td><strong>Eclipse Jetty</strong></td>
                        <td>Lightweight, embeddable, fast startup</td>
                        <td>Microservices, embedded scenarios</td>
                    </tr>
                    <tr>
                        <td><strong>Undertow</strong></td>
                        <td>High performance, non-blocking</td>
                        <td>High-concurrency applications</td>
                    </tr>
                </tbody>
            </table>

            <h3>Full Application Servers (Jakarta EE)</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Server</th>
                        <th>Description</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>WildFly</strong></td>
                        <td>Free, open source, formerly JBoss AS</td>
                        <td>Full Jakarta EE, enterprise apps</td>
                    </tr>
                    <tr>
                        <td><strong>Payara</strong></td>
                        <td>GlassFish fork, production-focused</td>
                        <td>Jakarta EE with support options</td>
                    </tr>
                    <tr>
                        <td><strong>IBM WebSphere Liberty</strong></td>
                        <td>Commercial, modular, fast</td>
                        <td>Enterprise, IBM ecosystem</td>
                    </tr>
                    <tr>
                        <td><strong>Oracle WebLogic</strong></td>
                        <td>Commercial, full-featured</td>
                        <td>Large enterprise, Oracle ecosystem</td>
                    </tr>
                    <tr>
                        <td><strong>Apache TomEE</strong></td>
                        <td>Tomcat + Jakarta EE</td>
                        <td>Familiar Tomcat with EE features</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="content-section">
            <h2>Choosing the Right Server</h2>

            <div class="best-practices">
                <h3>Use a Servlet Container (Tomcat/Jetty) when:</h3>
                <ul>
                    <li>Building with Spring Boot (embedded server)</li>
                    <li>You don't need EJB or JMS</li>
                    <li>You want lightweight and simple</li>
                    <li>Building microservices</li>
                    <li>Deploying to containers (Docker, Kubernetes)</li>
                </ul>

                <h3>Use a Full Application Server when:</h3>
                <ul>
                    <li>Required by company policy/infrastructure</li>
                    <li>Need full Jakarta EE features (EJB, JMS, etc.)</li>
                    <li>Multiple applications sharing resources</li>
                    <li>Enterprise support contracts required</li>
                    <li>Migrating legacy Java EE applications</li>
                </ul>

                <h3>Use Embedded Server (Spring Boot) when:</h3>
                <ul>
                    <li>Building new applications</li>
                    <li>Want simple deployment (just run JAR)</li>
                    <li>Building for the cloud</li>
                    <li>Want to control server version</li>
                    <li>Doing microservices architecture</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Summary</h2>
            <div class="info-box">
                <ul>
                    <li><strong>Application Server:</strong> Runtime environment that hosts and executes your Java web applications</li>
                    <li><strong>Web Server:</strong> Serves static content only (Nginx, Apache HTTP Server)</li>
                    <li><strong>Servlet Container:</strong> Runs Servlets/JSP (Tomcat, Jetty)</li>
                    <li><strong>Full Application Server:</strong> Complete Jakarta EE implementation (WildFly, WebLogic)</li>
                    <li><strong>Embedded Server:</strong> Server packaged inside your application (Spring Boot approach)</li>
                    <li><strong>Services:</strong> Connection pooling, thread management, sessions, security, JNDI</li>
                    <li><strong>Modern Trend:</strong> Embedded servers for cloud-native, microservices applications</li>
                </ul>
            </div>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="tomcat.html" class="related-link">Tomcat Overview</a>
                <a href="servlet-container.html" class="related-link">Servlet Containers</a>
                <a href="war-jar.html" class="related-link">WAR vs JAR</a>
                <a href="../jakarta-ee/servlets-jsp.html" class="related-link">Servlets & JSP</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
