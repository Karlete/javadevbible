<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client-Server Architecture - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#web-concepts">Web Concepts</a> / Client-Server Architecture
            </nav>
            <h1>Client-Server Architecture</h1>
            <p class="topic-subtitle">The foundation of modern web applications</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What is Client-Server Architecture?</h2>
            <p>The <strong>Client-Server Architecture</strong> is one of the most fundamental concepts in computing and the backbone of nearly every application you use today. Whether you're checking email, browsing social media, shopping online, or using a banking app, you're interacting with client-server systems.</p>

            <p>At its core, this architecture divides computing tasks between two distinct roles: <strong>clients</strong> that request services, and <strong>servers</strong> that provide them. This separation of concerns has revolutionized how we build software, enabling the internet as we know it.</p>

            <h3>A Simple Analogy: The Restaurant</h3>
            <p>Understanding client-server architecture becomes intuitive when you think of it like dining at a restaurant:</p>
            <ul>
                <li><strong>Client (Customer):</strong> You, the diner, make requests. "I'd like a margherita pizza with extra cheese." You don't need to know how to make pizza or where the ingredients come fromâ€”you just need to know how to order.</li>
                <li><strong>Server (Kitchen):</strong> The kitchen receives your order, has all the ingredients, equipment, and expertise to prepare it, and sends back the finished dish. The kitchen can serve many customers simultaneously.</li>
                <li><strong>Network (Waiter):</strong> The waiter carries messages between you and the kitchen. They speak a "protocol"â€”taking your order in a standard format, delivering it to the kitchen, and bringing back your food.</li>
                <li><strong>Menu (API):</strong> The menu defines what you can order and how to order it. You can't ask for something that's not on the menu (unless the restaurant is very accommodating!).</li>
            </ul>

            <div class="info-box">
                <p><strong>Client-Server Architecture</strong> is a distributed computing model where:</p>
                <ul>
                    <li><strong>Clients</strong> are programs that request services or resources. They initiate communication and present information to users.</li>
                    <li><strong>Servers</strong> are programs that provide services or resources. They wait for requests, process them, and return results.</li>
                    <li><strong>Network</strong> is the communication medium that connects them, using standardized protocols (usually HTTP/HTTPS for web applications).</li>
                    <li><strong>Protocol</strong> is the agreed-upon "language" and rules for communication (like HTTP, WebSocket, or gRPC).</li>
                </ul>
            </div>

            <h3>The Fundamental Communication Pattern</h3>
            <p>Every client-server interaction follows a simple pattern: <strong>request and response</strong>. The client asks for something, and the server provides it (or explains why it can't).</p>

            <pre><code><span class="comment">// The fundamental flow of client-server communication:</span>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         Request          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   â”‚          â”‚
â”‚  CLIENT  â”‚     "GET /users"         â”‚  SERVER  â”‚
â”‚ (Browser)â”‚                          â”‚  (Java)  â”‚
â”‚          â”‚  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        Response          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 [User Data]

<span class="comment">// Key characteristics:</span>
<span class="comment">// 1. Client ALWAYS initiates - server never contacts client first (in HTTP)</span>
<span class="comment">// 2. Server can handle MANY clients simultaneously</span>
<span class="comment">// 3. Client and server can be on different machines, different continents</span>
<span class="comment">// 4. Communication happens over a network using agreed protocols</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Why Client-Server? A Brief History</h2>
            <p>Before client-server architecture, computing was dominated by <strong>mainframe systems</strong> where a single powerful computer did all the processing, and users accessed it through "dumb terminals" that could only display text.</p>

            <p>The evolution happened in stages:</p>

            <h3>1960s-70s: Mainframe Era</h3>
            <pre><code><span class="comment">// All processing on one central computer</span>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MAINFRAME                      â”‚
â”‚         (Does ALL the computing work)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†‘           â†‘           â†‘
   [Terminal]  [Terminal]  [Terminal]
   (Display    (Display    (Display
     only)       only)       only)

<span class="comment">// Problems: Expensive, single point of failure, limited scalability</span></code></pre>

            <h3>1980s-90s: Client-Server Revolution</h3>
            <pre><code><span class="comment">// Processing distributed between client and server</span>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client  â”‚     â”‚  Client  â”‚     â”‚  Client  â”‚
â”‚    PC    â”‚     â”‚    PC    â”‚     â”‚    PC    â”‚
â”‚(Has own  â”‚     â”‚(Has own  â”‚     â”‚(Has own  â”‚
â”‚   CPU)   â”‚     â”‚   CPU)   â”‚     â”‚   CPU)   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚               â”‚               â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
              â”‚   SERVER    â”‚
              â”‚ (Shared     â”‚
              â”‚  resources) â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="comment">// Benefits: Cheaper, more scalable, distributed processing</span></code></pre>

            <h3>2000s-Present: Web and Cloud Era</h3>
            <pre><code><span class="comment">// Thin clients (browsers) with powerful server infrastructure</span>

   ğŸ“±        ğŸ’»        ğŸ–¥ï¸        ğŸ“º
  Mobile    Laptop   Desktop    Smart TV
    â”‚          â”‚         â”‚         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
              â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
              â”‚  INTERNET â”‚
              â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                    â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               â”‚               â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
â”‚Server â”‚     â”‚ Server  â”‚    â”‚ Server  â”‚
â”‚Clusterâ”‚     â”‚ Cluster â”‚    â”‚ Cluster â”‚
â”‚(AWS)  â”‚     â”‚(Google) â”‚    â”‚(Azure)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="comment">// Modern reality: Multiple clients, distributed servers, cloud infrastructure</span></code></pre>

            <p>This evolution happened because of several factors:</p>
            <ul>
                <li><strong>Cost reduction:</strong> Personal computers became affordable</li>
                <li><strong>Network improvements:</strong> Faster, more reliable networks</li>
                <li><strong>Scalability needs:</strong> More users required distributed processing</li>
                <li><strong>User experience:</strong> Rich interfaces needed client-side processing</li>
            </ul>
        </section>

        <section class="content-section">
            <h2>Understanding Roles: Who is the Client? Who is the Server?</h2>
            <p>One common source of confusion is understanding what constitutes a "client" and what constitutes a "server." The answer depends on <strong>perspective and context</strong>â€”the same machine can be both!</p>

            <div class="info-box note">
                <div class="info-box-title">Key Insight</div>
                <p><strong>Client and server are ROLES, not physical machines.</strong> The same computer can act as a client in one interaction and a server in another. What matters is who initiates the request and who responds.</p>
            </div>

            <pre><code><span class="comment">// Example: Your Java backend is BOTH client and server</span>

                    Acts as SERVER                Acts as CLIENT
                    (for browsers)                (for database)
                          â”‚                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          â”‚ Request â”‚                                       â”‚ Request â”‚          â”‚
â”‚  Browser â”‚ â”€â”€â”€â”€â”€â”€â–¶ â”‚           JAVA APPLICATION            â”‚ â”€â”€â”€â”€â”€â”€â–¶ â”‚ Database â”‚
â”‚ (Client) â”‚         â”‚                                       â”‚         â”‚ (Server) â”‚
â”‚          â”‚ â—€â”€â”€â”€â”€â”€â”€ â”‚                                       â”‚ â—€â”€â”€â”€â”€â”€â”€ â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Responseâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Responseâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="comment">// The Java app RECEIVES requests from browsers (it's the server)</span>
<span class="comment">// The Java app SENDS requests to database (it's the client)</span>

<span class="comment">// In microservices, this gets even more complex:</span>
User Service â”€â”€â”€â”€â”€â”€â–¶ Order Service â”€â”€â”€â”€â”€â”€â–¶ Payment Service
  (client)            (server/client)         (server)</code></pre>

            <p>This dual nature is essential in modern distributed systems. Your Spring Boot application:</p>
            <ul>
                <li><strong>Acts as a SERVER</strong> when handling HTTP requests from browsers or mobile apps</li>
                <li><strong>Acts as a CLIENT</strong> when querying databases, calling external APIs, or communicating with other microservices</li>
            </ul>
        </section>

        <section class="content-section">
            <h2>Key Components in Detail</h2>

            <h3>The Client</h3>
            <p>A <strong>client</strong> is any program or device that initiates requests to a server. Clients are responsible for:</p>
            <ul>
                <li><strong>User interface:</strong> Presenting data in a human-readable form</li>
                <li><strong>Input handling:</strong> Collecting user actions (clicks, typing, gestures)</li>
                <li><strong>Request formation:</strong> Translating user actions into server requests</li>
                <li><strong>Response processing:</strong> Receiving and displaying server responses</li>
                <li><strong>Local processing:</strong> Performing operations that don't need server involvement</li>
            </ul>

            <pre><code><span class="comment">// Types of clients in the Java ecosystem:</span>

<span class="comment">// 1. WEB BROWSER (Chrome, Firefox, Safari, Edge)</span>
<span class="comment">//    The most common client for web applications</span>
<span class="comment">//    - Renders HTML, CSS for visual presentation</span>
<span class="comment">//    - Executes JavaScript for interactivity</span>
<span class="comment">//    - Makes HTTP/HTTPS requests via fetch() or XMLHttpRequest</span>
<span class="comment">//    - Handles cookies, local storage, session management</span>

<span class="comment">// 2. MOBILE APPLICATION (Android, iOS)</span>
<span class="comment">//    Native apps that communicate with backend servers</span>
<span class="comment">//    - Android: Java/Kotlin with Retrofit, OkHttp</span>
<span class="comment">//    - iOS: Swift/Objective-C with URLSession</span>
<span class="comment">//    - Cross-platform: React Native, Flutter</span>

<span class="comment">// 3. DESKTOP APPLICATION</span>
<span class="comment">//    Standalone programs that may need server connectivity</span>
<span class="comment">//    - JavaFX applications</span>
<span class="comment">//    - Electron apps (VS Code, Slack desktop)</span>
<span class="comment">//    - Native Windows/Mac/Linux applications</span>

<span class="comment">// 4. ANOTHER SERVER (Server-to-Server / Backend-to-Backend)</span>
<span class="comment">//    In microservices, servers call other servers</span>
<span class="comment">//    - Using RestTemplate, WebClient, Feign in Spring</span>
<span class="comment">//    - gRPC for high-performance communication</span>

<span class="comment">// 5. COMMAND LINE TOOLS (curl, wget, httpie)</span>
<span class="comment">//    Useful for testing and automation</span>
curl -X GET https://api.example.com/users \
     -H "Authorization: Bearer token123"

<span class="comment">// 6. IOT DEVICES (Internet of Things)</span>
<span class="comment">//    Smart devices that report data to servers</span>
<span class="comment">//    - Temperature sensors, smart home devices</span>
<span class="comment">//    - Often use MQTT or lightweight HTTP</span></code></pre>

            <h3>The Server</h3>
            <p>A <strong>server</strong> is a program (and often the machine running it) that waits for incoming requests and provides responses. Think of it as a tireless worker that's always "listening" for someone to ask for help.</p>

            <p>Server responsibilities include:</p>
            <ul>
                <li><strong>Listening:</strong> Constantly waiting for incoming connections on specified ports</li>
                <li><strong>Authentication:</strong> Verifying who is making the request</li>
                <li><strong>Authorization:</strong> Checking if they're allowed to do what they're asking</li>
                <li><strong>Business logic:</strong> Processing requests according to application rules</li>
                <li><strong>Data management:</strong> Reading from and writing to databases</li>
                <li><strong>Response generation:</strong> Creating and sending appropriate responses</li>
                <li><strong>Concurrent handling:</strong> Managing multiple client requests simultaneously</li>
            </ul>

            <pre><code><span class="comment">// What a server actually does - step by step:</span>

<span class="comment">// 1. SERVER STARTUP</span>
<span class="comment">//    The server binds to a port and starts listening</span>
<span class="comment">//    Port 8080 for HTTP development, 443 for HTTPS production</span>

@SpringBootApplication
<span class="keyword">public class</span> <span class="class-name">MyApplication</span> {
    <span class="keyword">public static void</span> main(String[] args) {
        SpringApplication.run(MyApplication.<span class="keyword">class</span>, args);
        <span class="comment">// Server is now listening on port 8080</span>
        <span class="comment">// It will wait here indefinitely for requests</span>
    }
}

<span class="comment">// 2. REQUEST ARRIVES</span>
<span class="comment">//    A client connects and sends an HTTP request</span>
<span class="comment">//    Spring automatically routes it to the right method</span>

<span class="annotation">@RestController</span>
<span class="keyword">public class</span> <span class="class-name">UserController</span> {

    <span class="annotation">@GetMapping</span>(<span class="string">"/users"</span>)
    <span class="keyword">public</span> List&lt;User&gt; getUsers() {
        <span class="comment">// 3. PROCESSING</span>
        <span class="comment">//    - Authenticate (who is this?)</span>
        <span class="comment">//    - Authorize (can they do this?)</span>
        <span class="comment">//    - Execute business logic</span>
        <span class="comment">//    - Access database if needed</span>

        <span class="comment">// 4. RESPONSE</span>
        <span class="comment">//    - Create response object</span>
        <span class="comment">//    - Serialize to JSON</span>
        <span class="comment">//    - Send back to client</span>
        <span class="keyword">return</span> userService.findAll();
    }
}

<span class="comment">// Common Java server technologies:</span>
<span class="comment">// - Spring Boot (most popular, convention over configuration)</span>
<span class="comment">// - Jakarta EE (enterprise standard, formerly Java EE)</span>
<span class="comment">// - Quarkus (cloud-native, fast startup)</span>
<span class="comment">// - Micronaut (low memory footprint, compile-time DI)</span></code></pre>

            <h3>The Network</h3>
            <p>The <strong>network</strong> is the communication medium that allows clients and servers to exchange messages. For most web development, you'll work with networks through the <strong>HTTP protocol</strong>, but understanding the underlying layers helps when debugging issues.</p>

            <p>Network communication is organized in <strong>layers</strong>, each with a specific responsibility. This is called the <strong>OSI model</strong> (simplified to 4 layers in TCP/IP):</p>

            <pre><code><span class="comment">// The network stack - how data travels from your browser to a server</span>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  APPLICATION LAYER (HTTP, HTTPS, WebSocket, gRPC)                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  This is where YOU work as a developer                              â”‚
â”‚  - HTTP requests and responses                                      â”‚
â”‚  - JSON/XML data formats                                            â”‚
â”‚  - Headers, cookies, authentication tokens                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TRANSPORT LAYER (TCP, UDP)                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Ensures reliable delivery of data                                  â”‚
â”‚  - TCP: Reliable, ordered delivery (used by HTTP)                   â”‚
â”‚  - UDP: Fast but unreliable (used by video streaming, gaming)       â”‚
â”‚  - Ports: Identifies which application gets the data                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NETWORK LAYER (IP - Internet Protocol)                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Handles addressing and routing                                     â”‚
â”‚  - IP addresses: 192.168.1.1 (IPv4) or 2001:db8::1 (IPv6)          â”‚
â”‚  - Routers use this to forward packets                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PHYSICAL/LINK LAYER (Ethernet, WiFi, Fiber)                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Actual transmission of bits over physical medium                   â”‚
â”‚  - MAC addresses                                                    â”‚
â”‚  - Electrical signals, light pulses, radio waves                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="comment">// What happens when you visit https://myapp.com/users:</span>

1. Browser creates HTTP request (Application Layer)
2. Request is wrapped in TCP packet (Transport Layer)
   - Source port: 54321 (random high port)
   - Destination port: 443 (HTTPS)
3. TCP packet wrapped in IP packet (Network Layer)
   - Source IP: Your computer's IP
   - Destination IP: myapp.com's IP (resolved via DNS)
4. IP packet sent over your network (Physical Layer)
   - WiFi, Ethernet, etc.
5. Packets hop through routers across the internet
6. Arrives at server, unpacked layer by layer
7. Server processes request, sends response back the same way</code></pre>

            <h3>Ports: The Apartment Numbers of the Internet</h3>
            <p>A <strong>port</strong> is like an apartment number. The IP address gets you to the building (the server), but the port tells you which apartment (application) to deliver to.</p>

            <pre><code><span class="comment">// Common ports you should know:</span>

Port 80    â†’  HTTP (unencrypted web traffic)
Port 443   â†’  HTTPS (encrypted web traffic)
Port 8080  â†’  Common development server port
Port 3000  â†’  Common for Node.js, React dev servers
Port 5432  â†’  PostgreSQL database
Port 3306  â†’  MySQL database
Port 27017 â†’  MongoDB
Port 6379  â†’  Redis

<span class="comment">// Your Spring Boot app typically runs on:</span>
http://localhost:8080   <span class="comment">// During development</span>
https://myapp.com:443   <span class="comment">// In production (443 is default for HTTPS)</span>

<span class="comment">// A single server can run multiple applications on different ports:</span>
Server IP: 192.168.1.100
â”œâ”€â”€ Port 8080 â†’ User Service
â”œâ”€â”€ Port 8081 â†’ Order Service
â”œâ”€â”€ Port 8082 â†’ Payment Service
â””â”€â”€ Port 5432 â†’ PostgreSQL Database</code></pre>
        </section>

        <section class="content-section">
            <h2>How It Works in Practice</h2>

            <pre><code><span class="comment">// Step-by-step: User clicks "View Profile"</span>

<span class="comment">// 1. CLIENT: Browser creates HTTP request</span>
GET /api/users/123 HTTP/1.1
Host: myapp.com
Accept: application/json
Authorization: Bearer eyJhbGc...

<span class="comment">// 2. NETWORK: Request travels over internet</span>
<span class="comment">//    DNS resolves myapp.com â†’ 203.0.113.50</span>
<span class="comment">//    TCP connection established</span>
<span class="comment">//    Request sent to server</span>

<span class="comment">// 3. SERVER: Java application receives request</span>
<span class="annotation">@GetMapping</span>(<span class="string">"/api/users/{id}"</span>)
<span class="keyword">public</span> ResponseEntity&lt;User&gt; getUser(<span class="annotation">@PathVariable</span> Long id) {
    <span class="comment">// Validate authentication</span>
    <span class="comment">// Query database</span>
    User user = userRepository.findById(id)
        .orElseThrow(() -> <span class="keyword">new</span> NotFoundException());
    <span class="keyword">return</span> ResponseEntity.ok(user);
}

<span class="comment">// 4. SERVER: Creates HTTP response</span>
HTTP/1.1 200 OK
Content-Type: application/json

{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com"
}

<span class="comment">// 5. CLIENT: Browser receives and renders data</span>
<span class="comment">//    JavaScript processes JSON</span>
<span class="comment">//    Updates the UI</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Architecture Patterns</h2>

            <h3>Two-Tier Architecture</h3>
            <pre><code><span class="comment">// Direct client-to-database (legacy, simple apps)</span>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLIENT  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ DATABASE â”‚
â”‚ (Desktop â”‚              â”‚ (MySQL)  â”‚
â”‚   App)   â”‚  â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="comment">// Problems:</span>
<span class="comment">// - Business logic in client (hard to maintain)</span>
<span class="comment">// - Security risks (direct DB access)</span>
<span class="comment">// - Tight coupling</span></code></pre>

            <h3>Three-Tier Architecture (Most Common)</h3>
            <pre><code><span class="comment">// Client â†’ Server â†’ Database</span>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLIENT  â”‚       â”‚  SERVER  â”‚       â”‚ DATABASE â”‚
â”‚ (Browser)â”‚ â”€â”€â”€â”€â–¶ â”‚ (Spring  â”‚ â”€â”€â”€â”€â–¶ â”‚ (Postgre â”‚
â”‚          â”‚       â”‚   Boot)  â”‚       â”‚   SQL)   â”‚
â”‚          â”‚ â—€â”€â”€â”€â”€ â”‚          â”‚ â—€â”€â”€â”€â”€ â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                   â”‚
         Presentation       Business
            Layer            Logic
         (Controllers)     (Services)</code></pre>

            <h3>N-Tier / Microservices</h3>
            <pre><code><span class="comment">// Multiple specialized services</span>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          â”‚       â”‚            API Gateway              â”‚
â”‚  CLIENT  â”‚ â”€â”€â”€â”€â–¶ â”‚         (Authentication)            â”‚
â”‚          â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼             â–¼             â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   User   â”‚ â”‚  Order   â”‚ â”‚ Payment  â”‚
              â”‚ Service  â”‚ â”‚ Service  â”‚ â”‚ Service  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚             â”‚             â”‚
                    â–¼             â–¼             â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  User DB â”‚ â”‚ Order DB â”‚ â”‚Payment DBâ”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
        </section>

        <section class="content-section">
            <h2>Java Client-Server Example</h2>

            <h3>Server Side (Spring Boot)</h3>
            <pre><code><span class="comment">// ProductController.java</span>
<span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/api/products"</span>)
<span class="keyword">public class</span> <span class="class-name">ProductController</span> {

    <span class="keyword">private final</span> ProductService productService;

    <span class="comment">// GET /api/products - List all products</span>
    <span class="annotation">@GetMapping</span>
    <span class="keyword">public</span> List&lt;Product&gt; getAllProducts() {
        <span class="keyword">return</span> productService.findAll();
    }

    <span class="comment">// GET /api/products/123 - Get specific product</span>
    <span class="annotation">@GetMapping</span>(<span class="string">"/{id}"</span>)
    <span class="keyword">public</span> Product getProduct(<span class="annotation">@PathVariable</span> Long id) {
        <span class="keyword">return</span> productService.findById(id);
    }

    <span class="comment">// POST /api/products - Create new product</span>
    <span class="annotation">@PostMapping</span>
    <span class="keyword">public</span> Product createProduct(<span class="annotation">@RequestBody</span> Product product) {
        <span class="keyword">return</span> productService.save(product);
    }

    <span class="comment">// PUT /api/products/123 - Update product</span>
    <span class="annotation">@PutMapping</span>(<span class="string">"/{id}"</span>)
    <span class="keyword">public</span> Product updateProduct(
            <span class="annotation">@PathVariable</span> Long id,
            <span class="annotation">@RequestBody</span> Product product) {
        <span class="keyword">return</span> productService.update(id, product);
    }

    <span class="comment">// DELETE /api/products/123 - Delete product</span>
    <span class="annotation">@DeleteMapping</span>(<span class="string">"/{id}"</span>)
    <span class="keyword">public void</span> deleteProduct(<span class="annotation">@PathVariable</span> Long id) {
        productService.delete(id);
    }
}</code></pre>

            <h3>Client Side (Java HttpClient)</h3>
            <pre><code><span class="comment">// Java 11+ HttpClient as a client</span>
<span class="keyword">public class</span> <span class="class-name">ProductClient</span> {

    <span class="keyword">private final</span> HttpClient httpClient = HttpClient.newHttpClient();
    <span class="keyword">private final</span> String baseUrl = <span class="string">"http://localhost:8080/api/products"</span>;
    <span class="keyword">private final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();

    <span class="comment">// GET request - Fetch all products</span>
    <span class="keyword">public</span> List&lt;Product&gt; getAllProducts() <span class="keyword">throws</span> Exception {
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl))
            .GET()
            .header(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>)
            .build();

        HttpResponse&lt;String&gt; response = httpClient.send(
            request, HttpResponse.BodyHandlers.ofString()
        );

        <span class="keyword">return</span> mapper.readValue(
            response.body(),
            <span class="keyword">new</span> TypeReference&lt;List&lt;Product&gt;&gt;() {}
        );
    }

    <span class="comment">// POST request - Create a product</span>
    <span class="keyword">public</span> Product createProduct(Product product) <span class="keyword">throws</span> Exception {
        String json = mapper.writeValueAsString(product);

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl))
            .POST(HttpRequest.BodyPublishers.ofString(json))
            .header(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
            .build();

        HttpResponse&lt;String&gt; response = httpClient.send(
            request, HttpResponse.BodyHandlers.ofString()
        );

        <span class="keyword">return</span> mapper.readValue(response.body(), Product.<span class="keyword">class</span>);
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Stateless vs Stateful Servers</h2>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Stateless</th>
                        <th>Stateful</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Memory</strong></td>
                        <td>No client data stored</td>
                        <td>Remembers client state</td>
                    </tr>
                    <tr>
                        <td><strong>Scalability</strong></td>
                        <td>Easy to scale horizontally</td>
                        <td>Requires sticky sessions</td>
                    </tr>
                    <tr>
                        <td><strong>Example</strong></td>
                        <td>REST APIs with JWT</td>
                        <td>WebSocket connections</td>
                    </tr>
                    <tr>
                        <td><strong>Request handling</strong></td>
                        <td>Any server can handle</td>
                        <td>Same server required</td>
                    </tr>
                </tbody>
            </table>

            <pre><code><span class="comment">// STATELESS: Each request contains all needed info</span>
<span class="annotation">@GetMapping</span>(<span class="string">"/api/profile"</span>)
<span class="keyword">public</span> User getProfile(<span class="annotation">@RequestHeader</span>(<span class="string">"Authorization"</span>) String token) {
    <span class="comment">// Token contains user identity - no server-side session needed</span>
    Long userId = jwtService.extractUserId(token);
    <span class="keyword">return</span> userService.findById(userId);
}

<span class="comment">// STATEFUL: Server remembers the session</span>
<span class="annotation">@GetMapping</span>(<span class="string">"/api/profile"</span>)
<span class="keyword">public</span> User getProfile(HttpSession session) {
    <span class="comment">// Server stores session data - must hit same server</span>
    Long userId = (Long) session.getAttribute(<span class="string">"userId"</span>);
    <span class="keyword">return</span> userService.findById(userId);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Benefits and Challenges</h2>

            <div class="best-practices">
                <h3>Benefits:</h3>
                <ul>
                    <li><strong>Separation of concerns:</strong> UI separate from business logic</li>
                    <li><strong>Scalability:</strong> Add more servers to handle load</li>
                    <li><strong>Maintainability:</strong> Update server without changing clients</li>
                    <li><strong>Security:</strong> Centralized data protection</li>
                    <li><strong>Multi-platform:</strong> One server, many client types</li>
                </ul>

                <h3>Challenges:</h3>
                <ul>
                    <li><strong>Network dependency:</strong> Requires connectivity</li>
                    <li><strong>Latency:</strong> Network round-trips add delay</li>
                    <li><strong>Single point of failure:</strong> Server down = app down</li>
                    <li><strong>Complexity:</strong> More moving parts to manage</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Summary</h2>
            <div class="info-box">
                <ul>
                    <li><strong>Client:</strong> Initiates requests (browser, mobile app, other servers)</li>
                    <li><strong>Server:</strong> Processes requests and returns responses</li>
                    <li><strong>Network:</strong> Carries messages using protocols (HTTP)</li>
                    <li><strong>Three-tier:</strong> Client â†’ Server â†’ Database (most common)</li>
                    <li><strong>Stateless:</strong> Preferred for scalability (REST + JWT)</li>
                    <li><strong>Java servers:</strong> Spring Boot, Jakarta EE handle the heavy lifting</li>
                </ul>
            </div>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="server-vs-client.html" class="related-link">Server vs Client Execution</a>
                <a href="http.html" class="related-link">HTTP Protocol</a>
                <a href="rest-principles.html" class="related-link">RESTful APIs</a>
                <a href="request-response.html" class="related-link">Request/Response Cycle</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
