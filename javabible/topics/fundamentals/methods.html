<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Methods & Functions - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Methods & Functions
            </nav>
            <h1>Methods & Functions</h1>
            <p class="topic-subtitle">Defining and Using Methods in Java</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What Are Methods?</h2>
            <p>Methods are the fundamental building blocks of behavior in Java programs. While variables store data, methods define what your program can <em>do</em> with that data. A method is essentially a named block of code that performs a specific task, and can be invoked (called) whenever that task needs to be performed. This simple concept is one of the most powerful tools in programming, enabling you to write code once and reuse it throughout your application.</p>

            <p>In Java, methods are always defined inside classes&mdash;there are no standalone functions like in C or Python. This is because Java is a purely object-oriented language where everything revolves around objects and the classes that define them. When you call <code>System.out.println()</code>, you're actually calling the <code>println</code> method on the <code>out</code> object, which belongs to the <code>System</code> class. Understanding this structure helps you see how methods fit into Java's object-oriented paradigm.</p>

            <p>The concept of methods (or their equivalents, called functions, procedures, or subroutines in other languages) dates back to the earliest days of computing. In the 1950s and 60s, programmers realized that writing the same code multiple times was wasteful and error-prone. Methods emerged as a way to encapsulate reusable logic. Java inherited this concept from C and C++, but added object-oriented semantics. Every method in Java belongs to a class, can access the object's state, and participates in the inheritance hierarchy.</p>

            <p>Methods provide several key benefits that make them indispensable in software development. <strong>Reusability</strong> means you write code once and call it many times. <strong>Abstraction</strong> hides complex implementation details behind simple interfaces. <strong>Modularity</strong> breaks large problems into smaller, manageable pieces. <strong>Testability</strong> allows you to verify individual pieces of functionality in isolation. <strong>Maintainability</strong> means fixing a bug in one method automatically fixes it everywhere that method is used.</p>

            <p>Modern Java has expanded what methods can do significantly. Java 8 introduced lambda expressions and method references, allowing methods to be passed as arguments and returned as values. Default methods in interfaces let you add new functionality without breaking existing implementations. Records (Java 14+) automatically generate methods like <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code>. Understanding methods deeply is essential not just for basic Java programming, but for leveraging these advanced features effectively.</p>

            <h3>Real-World Analogy</h3>
            <p>Think of methods as specialized workers in a factory:</p>
            <ul>
                <li><strong>Method Name</strong> = Worker's job title ("Painter", "Assembler", "Inspector")</li>
                <li><strong>Parameters</strong> = Materials the worker receives (parts, colors, specifications)</li>
                <li><strong>Return Value</strong> = The finished product the worker produces</li>
                <li><strong>Method Body</strong> = The actual work performed</li>
                <li><strong>Calling a Method</strong> = Asking a worker to do their job</li>
            </ul>
            <p>Just as you don't need to know exactly how a painter mixes colors to ask them to paint a wall, you don't need to know a method's implementation details to use it&mdash;you just need to know what it does, what it needs, and what it returns.</p>

            <div class="info-box note">
                <div class="info-box-title">Key Terminology</div>
                <ul>
                    <li><strong>Method Declaration</strong> &ndash; Defining what the method does</li>
                    <li><strong>Method Signature</strong> &ndash; Name + parameter types (uniquely identifies a method)</li>
                    <li><strong>Method Invocation/Call</strong> &ndash; Executing the method</li>
                    <li><strong>Parameters</strong> &ndash; Variables declared in method definition</li>
                    <li><strong>Arguments</strong> &ndash; Actual values passed when calling the method</li>
                    <li><strong>Return Type</strong> &ndash; The type of value the method gives back</li>
                    <li><strong>void</strong> &ndash; Special return type meaning "no return value"</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Under the Hood: How Method Calls Work</h2>
            <p>Understanding what happens when you call a method helps you write better code and debug issues. Each method call creates a new "stack frame" containing local variables and execution context.</p>

            <pre><code><span class="comment">/*
 * Method Call Stack - Visual Explanation
 * =======================================
 *
 *  When you call a method, Java:
 *  1. Creates a new stack frame
 *  2. Copies argument values to parameters
 *  3. Executes the method body
 *  4. Returns the result (if any)
 *  5. Destroys the stack frame
 *
 *  Example: calculateTotal(100.0, 5)
 *
 *  ┌────────────────────────────────────────────────────────────────────────┐
 *  │                            CALL STACK                                   │
 *  │                                                                         │
 *  │  Step 1: main() is running                                              │
 *  │  ┌─────────────────────────────────────────────────────────────────┐   │
 *  │  │ main()                                                           │   │
 *  │  │   double result = calculateTotal(100.0, 5);  ← About to call    │   │
 *  │  └─────────────────────────────────────────────────────────────────┘   │
 *  │                                                                         │
 *  │  Step 2: calculateTotal() frame pushed onto stack                       │
 *  │  ┌─────────────────────────────────────────────────────────────────┐   │
 *  │  │ calculateTotal(double price, int quantity)                       │   │
 *  │  │   price = 100.0    ← Argument copied                            │   │
 *  │  │   quantity = 5     ← Argument copied                            │   │
 *  │  │   subtotal = 500.0 ← Local variable created                     │   │
 *  │  │   return 500.0;    ← About to return                            │   │
 *  │  └─────────────────────────────────────────────────────────────────┘   │
 *  │  ┌─────────────────────────────────────────────────────────────────┐   │
 *  │  │ main()                                                           │   │
 *  │  │   (waiting for calculateTotal to return)                         │   │
 *  │  └─────────────────────────────────────────────────────────────────┘   │
 *  │                                                                         │
 *  │  Step 3: calculateTotal() returns, frame popped                         │
 *  │  ┌─────────────────────────────────────────────────────────────────┐   │
 *  │  │ main()                                                           │   │
 *  │  │   double result = 500.0;  ← Return value stored                 │   │
 *  │  └─────────────────────────────────────────────────────────────────┘   │
 *  │                                                                         │
 *  └────────────────────────────────────────────────────────────────────────┘
 *
 *  KEY INSIGHTS:
 *  - Each method call creates a new isolated frame
 *  - Local variables only exist within their frame
 *  - When method returns, its frame is destroyed
 *  - Stack grows DOWN (newer frames on top)
 *  - StackOverflowError = too many nested calls (stack ran out of space)
 */</span></code></pre>

            <h3>Pass by Value: Java's Calling Convention</h3>
            <p>Java always passes arguments <strong>by value</strong>. For primitives, this means the value is copied. For objects, the reference (address) is copied&mdash;but the object itself is not.</p>

            <pre><code><span class="comment">// Primitives: value is copied - original unchanged</span>
<span class="keyword">public void</span> <span class="function">tryToChange</span>(<span class="keyword">int</span> x) {
    x = <span class="number">999</span>;  <span class="comment">// Only changes the local copy!</span>
}

<span class="keyword">int</span> original = <span class="number">10</span>;
tryToChange(original);
<span class="class-name">System</span>.out.println(original);  <span class="comment">// Still 10!</span>

<span class="comment">// Objects: reference is copied - can modify object's contents</span>
<span class="keyword">public void</span> <span class="function">modifyList</span>(<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; list) {
    list.add(<span class="string">"new item"</span>);  <span class="comment">// Modifies the actual list!</span>
    list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();  <span class="comment">// Only changes local reference</span>
}

<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; myList = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
myList.add(<span class="string">"original"</span>);
modifyList(myList);
<span class="class-name">System</span>.out.println(myList);  <span class="comment">// [original, new item]</span></code></pre>

            <pre><code><span class="comment">/*
 * Pass by Value Visualization
 * ===========================
 *
 * PRIMITIVE (int):
 *
 *   Before call:              Inside method:
 *   ┌──────────┐             ┌──────────┐
 *   │ original │             │ x (copy) │
 *   │    10    │    ───►     │    10    │ → modified to 999
 *   └──────────┘             └──────────┘
 *        ↓                         ↓
 *   Still 10 after!           Discarded on return
 *
 *
 * OBJECT REFERENCE (List):
 *
 *   Stack:                                 Heap:
 *   ┌──────────┐                          ┌─────────────────┐
 *   │ myList   │ ────────────────────────►│ ArrayList       │
 *   │  0x100   │                          │ ["original"]    │
 *   └──────────┘                          └─────────────────┘
 *        │                                       ▲
 *        │ (copy reference)                      │
 *        ▼                                       │
 *   ┌──────────┐                                 │
 *   │ list     │ ────────────────────────────────┘
 *   │  0x100   │   (same object!)
 *   └──────────┘
 *
 *   list.add() modifies the shared object
 *   list = new ArrayList() only changes local 'list' reference
 */</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Understanding Pass by Value</div>
                <p>Remember: Java is <strong>always</strong> pass by value. What gets copied is:</p>
                <ul>
                    <li>For primitives: the actual value (5, 3.14, true)</li>
                    <li>For objects: the reference value (the memory address, like 0x100)</li>
                </ul>
                <p>You can modify an object's contents through a method parameter, but you cannot make the caller's variable point to a different object.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Method Anatomy: Complete Breakdown</h2>

            <pre><code><span class="comment">/*
 * Complete Method Declaration
 * ===========================
 *
 *  ┌──── Access Modifier: public, private, protected, (default)
 *  │  ┌── Optional Modifiers: static, final, abstract, synchronized, native
 *  │  │         ┌── Return Type: any type or void
 *  │  │         │         ┌── Method Name: follows naming conventions
 *  │  │         │         │           ┌── Parameter List: (type name, type name, ...)
 *  │  │         │         │           │                    ┌── Throws Clause (optional)
 *  │  │         │         │           │                    │
 *  ▼  ▼         ▼         ▼           ▼                    ▼
 */</span>
<span class="keyword">public static</span> <span class="class-name">String</span> <span class="function">formatCurrency</span>(<span class="keyword">double</span> amount, <span class="class-name">String</span> symbol) <span class="keyword">throws</span> <span class="class-name">IllegalArgumentException</span> {
    <span class="comment">// Method body</span>
    <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) {
        <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Amount cannot be negative"</span>);
    }
    <span class="keyword">return</span> <span class="class-name">String</span>.format(<span class="string">"%s%.2f"</span>, symbol, amount);
}</code></pre>

            <h3>Access Modifiers in Methods</h3>
            <table>
                <tr>
                    <th>Modifier</th>
                    <th>Same Class</th>
                    <th>Same Package</th>
                    <th>Subclass</th>
                    <th>Everywhere</th>
                </tr>
                <tr>
                    <td><code>public</code></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td><code>protected</code></td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>(default)</td>
                    <td>Yes</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td><code>private</code></td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>No</td>
                    <td>No</td>
                </tr>
            </table>

            <h3>Return Types</h3>
            <pre><code><span class="comment">// void - no return value</span>
<span class="keyword">public void</span> <span class="function">printMessage</span>(<span class="class-name">String</span> msg) {
    <span class="class-name">System</span>.out.println(msg);
    <span class="comment">// implicit return at end</span>
}

<span class="comment">// Primitive return types</span>
<span class="keyword">public int</span> <span class="function">add</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
    <span class="keyword">return</span> a + b;
}

<span class="keyword">public boolean</span> <span class="function">isAdult</span>(<span class="keyword">int</span> age) {
    <span class="keyword">return</span> age >= <span class="number">18</span>;
}

<span class="comment">// Object return types</span>
<span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getFullName</span>(<span class="class-name">String</span> first, <span class="class-name">String</span> last) {
    <span class="keyword">return</span> first + <span class="string">" "</span> + last;
}

<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getNames</span>() {
    <span class="keyword">return</span> <span class="class-name">List</span>.of(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);
}

<span class="comment">// Array return type</span>
<span class="keyword">public int</span>[] <span class="function">getScores</span>() {
    <span class="keyword">return new int</span>[]{<span class="number">90</span>, <span class="number">85</span>, <span class="number">95</span>};
}

<span class="comment">// Generic return type</span>
<span class="keyword">public</span> &lt;T&gt; T <span class="function">getFirst</span>(<span class="class-name">List</span>&lt;T&gt; items) {
    <span class="keyword">return</span> items.isEmpty() ? <span class="keyword">null</span> : items.get(<span class="number">0</span>);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Method Parameters: Deep Dive</h2>

            <h3>Basic Parameters</h3>
            <pre><code><span class="comment">// Single parameter</span>
<span class="keyword">public void</span> <span class="function">greet</span>(<span class="class-name">String</span> name) {
    <span class="class-name">System</span>.out.println(<span class="string">"Hello, "</span> + name);
}

<span class="comment">// Multiple parameters</span>
<span class="keyword">public double</span> <span class="function">calculateBMI</span>(<span class="keyword">double</span> weightKg, <span class="keyword">double</span> heightM) {
    <span class="keyword">return</span> weightKg / (heightM * heightM);
}

<span class="comment">// Mixed types</span>
<span class="keyword">public</span> <span class="class-name">String</span> <span class="function">createOrder</span>(<span class="class-name">String</span> product, <span class="keyword">int</span> quantity, <span class="keyword">double</span> price, <span class="keyword">boolean</span> express) {
    <span class="keyword">double</span> total = quantity * price;
    <span class="keyword">if</span> (express) total += <span class="number">9.99</span>;
    <span class="keyword">return</span> <span class="class-name">String</span>.format(<span class="string">"Order: %d x %s = $%.2f"</span>, quantity, product, total);
}</code></pre>

            <h3>Variable Arguments (Varargs)</h3>
            <pre><code><span class="comment">// Varargs - variable number of arguments</span>
<span class="keyword">public int</span> <span class="function">sum</span>(<span class="keyword">int</span>... numbers) {
    <span class="keyword">int</span> total = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> n : numbers) {
        total += n;
    }
    <span class="keyword">return</span> total;
}

<span class="comment">// Calling with different number of arguments</span>
<span class="keyword">int</span> a = sum();                  <span class="comment">// 0</span>
<span class="keyword">int</span> b = sum(<span class="number">5</span>);                 <span class="comment">// 5</span>
<span class="keyword">int</span> c = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);           <span class="comment">// 6</span>
<span class="keyword">int</span> d = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 15</span>

<span class="comment">// Can pass an array directly</span>
<span class="keyword">int</span>[] arr = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};
<span class="keyword">int</span> e = sum(arr);               <span class="comment">// 60</span>

<span class="comment">// Varargs with other parameters (varargs must be last!)</span>
<span class="keyword">public</span> <span class="class-name">String</span> <span class="function">format</span>(<span class="class-name">String</span> template, <span class="class-name">Object</span>... args) {
    <span class="keyword">return</span> <span class="class-name">String</span>.format(template, args);
}

format(<span class="string">"Name: %s, Age: %d"</span>, <span class="string">"Alice"</span>, <span class="number">30</span>);  <span class="comment">// "Name: Alice, Age: 30"</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Varargs Rules</div>
                <ul>
                    <li>Only one varargs parameter per method</li>
                    <li>Must be the <strong>last</strong> parameter</li>
                    <li>Internally treated as an array</li>
                    <li>Can be called with zero arguments</li>
                </ul>
            </div>

            <h3>Final Parameters</h3>
            <pre><code><span class="comment">// final parameter cannot be reassigned inside the method</span>
<span class="keyword">public void</span> <span class="function">process</span>(<span class="keyword">final</span> <span class="class-name">String</span> input) {
    <span class="comment">// input = "modified";  // ERROR: cannot assign to final</span>
    <span class="class-name">System</span>.out.println(input.toUpperCase());  <span class="comment">// OK to call methods on it</span>
}

<span class="comment">// Useful in lambdas and inner classes (implicitly final)</span>
<span class="keyword">public void</span> <span class="function">useLambda</span>(<span class="class-name">String</span> message) {
    <span class="comment">// message is effectively final here</span>
    <span class="class-name">Runnable</span> r = () -> <span class="class-name">System</span>.out.println(message);
    r.run();
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Method Overloading</h2>
            <p>Method overloading allows multiple methods with the same name but different parameter lists. The compiler determines which version to call based on the arguments provided.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Printer</span> {

    <span class="comment">// Overload 1: no parameters</span>
    <span class="keyword">public void</span> <span class="function">print</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Empty"</span>);
    }

    <span class="comment">// Overload 2: String parameter</span>
    <span class="keyword">public void</span> <span class="function">print</span>(<span class="class-name">String</span> message) {
        <span class="class-name">System</span>.out.println(message);
    }

    <span class="comment">// Overload 3: int parameter</span>
    <span class="keyword">public void</span> <span class="function">print</span>(<span class="keyword">int</span> number) {
        <span class="class-name">System</span>.out.println(<span class="string">"Number: "</span> + number);
    }

    <span class="comment">// Overload 4: two parameters</span>
    <span class="keyword">public void</span> <span class="function">print</span>(<span class="class-name">String</span> message, <span class="keyword">int</span> times) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) {
            <span class="class-name">System</span>.out.println(message);
        }
    }

    <span class="comment">// Overload 5: different parameter order</span>
    <span class="keyword">public void</span> <span class="function">print</span>(<span class="keyword">int</span> times, <span class="class-name">String</span> message) {
        print(message, times);  <span class="comment">// Delegate to other overload</span>
    }
}

<span class="comment">// Usage - compiler picks correct overload</span>
<span class="class-name">Printer</span> p = <span class="keyword">new</span> <span class="class-name">Printer</span>();
p.print();                     <span class="comment">// Overload 1</span>
p.print(<span class="string">"Hello"</span>);             <span class="comment">// Overload 2</span>
p.print(<span class="number">42</span>);                   <span class="comment">// Overload 3</span>
p.print(<span class="string">"Hi"</span>, <span class="number">3</span>);             <span class="comment">// Overload 4</span>
p.print(<span class="number">3</span>, <span class="string">"Hi"</span>);             <span class="comment">// Overload 5</span></code></pre>

            <h3>Overloading Resolution Rules</h3>
            <pre><code><span class="comment">// When multiple overloads could match, Java picks the "most specific"</span>

<span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">Object</span> obj) {
    <span class="class-name">System</span>.out.println(<span class="string">"Object version"</span>);
}

<span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">String</span> str) {
    <span class="class-name">System</span>.out.println(<span class="string">"String version"</span>);
}

<span class="keyword">public void</span> <span class="function">process</span>(<span class="keyword">int</span> num) {
    <span class="class-name">System</span>.out.println(<span class="string">"int version"</span>);
}

<span class="keyword">public void</span> <span class="function">process</span>(<span class="keyword">long</span> num) {
    <span class="class-name">System</span>.out.println(<span class="string">"long version"</span>);
}

<span class="comment">// Calls:</span>
process(<span class="string">"hello"</span>);    <span class="comment">// String version (String is more specific than Object)</span>
process(<span class="number">10</span>);          <span class="comment">// int version (exact match)</span>
process(<span class="number">10L</span>);         <span class="comment">// long version (exact match)</span>

<span class="comment">// Widening: smaller types can widen to larger</span>
<span class="keyword">short</span> s = <span class="number">5</span>;
process(s);           <span class="comment">// int version (short widens to int)</span>

<span class="comment">// Autoboxing happens after widening</span>
process(<span class="class-name">Integer</span>.valueOf(<span class="number">10</span>));  <span class="comment">// Object version (Integer → Object)</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">What CAN'T Differ in Overloads</div>
                <ul>
                    <li><strong>Return type alone</strong> &ndash; <code>int foo()</code> and <code>String foo()</code> cannot coexist</li>
                    <li><strong>Access modifiers</strong> &ndash; <code>public void foo()</code> and <code>private void foo()</code> = same signature</li>
                    <li><strong>Parameter names</strong> &ndash; <code>foo(int a)</code> and <code>foo(int b)</code> = same signature</li>
                    <li><strong>throws clause</strong> &ndash; Exception declarations don't affect overloading</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Static vs Instance Methods</h2>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Counter</span> {
    <span class="comment">// Instance variable - each Counter has its own</span>
    <span class="keyword">private int</span> count = <span class="number">0</span>;

    <span class="comment">// Static variable - shared by all Counter instances</span>
    <span class="keyword">private static int</span> totalCounters = <span class="number">0</span>;

    <span class="comment">// Constructor</span>
    <span class="keyword">public</span> <span class="function">Counter</span>() {
        totalCounters++;  <span class="comment">// Static context can access static members</span>
    }

    <span class="comment">// INSTANCE METHOD - operates on a specific Counter object</span>
    <span class="keyword">public void</span> <span class="function">increment</span>() {
        count++;  <span class="comment">// Accesses instance variable</span>
    }

    <span class="comment">// INSTANCE METHOD - needs an object to call</span>
    <span class="keyword">public int</span> <span class="function">getCount</span>() {
        <span class="keyword">return</span> count;  <span class="comment">// Returns this object's count</span>
    }

    <span class="comment">// STATIC METHOD - belongs to the class, not instances</span>
    <span class="keyword">public static int</span> <span class="function">getTotalCounters</span>() {
        <span class="keyword">return</span> totalCounters;  <span class="comment">// Can only access static members</span>
    }

    <span class="comment">// STATIC METHOD - utility that doesn't need object state</span>
    <span class="keyword">public static int</span> <span class="function">add</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
        <span class="keyword">return</span> a + b;  <span class="comment">// Pure function, no state</span>
    }
}

<span class="comment">// Usage</span>
<span class="class-name">Counter</span> c1 = <span class="keyword">new</span> <span class="class-name">Counter</span>();
<span class="class-name">Counter</span> c2 = <span class="keyword">new</span> <span class="class-name">Counter</span>();

<span class="comment">// Instance methods - need an object</span>
c1.increment();
c1.increment();
c2.increment();

<span class="class-name">System</span>.out.println(c1.getCount());  <span class="comment">// 2</span>
<span class="class-name">System</span>.out.println(c2.getCount());  <span class="comment">// 1</span>

<span class="comment">// Static methods - called on class, not object</span>
<span class="class-name">System</span>.out.println(<span class="class-name">Counter</span>.getTotalCounters());  <span class="comment">// 2</span>
<span class="class-name">System</span>.out.println(<span class="class-name">Counter</span>.add(<span class="number">5</span>, <span class="number">3</span>));            <span class="comment">// 8</span></code></pre>

            <h3>When to Use Static</h3>
            <table>
                <tr>
                    <th>Use Static When...</th>
                    <th>Use Instance When...</th>
                </tr>
                <tr>
                    <td>Method doesn't need object state</td>
                    <td>Method reads/writes object fields</td>
                </tr>
                <tr>
                    <td>Utility/helper functions</td>
                    <td>Method behavior varies per object</td>
                </tr>
                <tr>
                    <td>Factory methods</td>
                    <td>Method is part of object's behavior</td>
                </tr>
                <tr>
                    <td>Constants (<code>public static final</code>)</td>
                    <td>Method needs polymorphism</td>
                </tr>
                <tr>
                    <td>Entry point (<code>main</code>)</td>
                    <td>Method implements an interface</td>
                </tr>
            </table>

            <pre><code><span class="comment">// Common static method patterns</span>

<span class="comment">// Factory method</span>
<span class="keyword">public static</span> <span class="class-name">User</span> <span class="function">createGuest</span>() {
    <span class="keyword">return new</span> <span class="class-name">User</span>(<span class="string">"guest"</span>, <span class="string">"guest@example.com"</span>);
}

<span class="comment">// Utility method</span>
<span class="keyword">public static boolean</span> <span class="function">isValidEmail</span>(<span class="class-name">String</span> email) {
    <span class="keyword">return</span> email != <span class="keyword">null</span> && email.contains(<span class="string">"@"</span>);
}

<span class="comment">// Converter</span>
<span class="keyword">public static double</span> <span class="function">celsiusToFahrenheit</span>(<span class="keyword">double</span> celsius) {
    <span class="keyword">return</span> celsius * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span>;
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Method Best Practices</h2>

            <h3>Good vs Bad Method Design</h3>
            <pre><code><span class="comment">// ❌ BAD: Method does too many things</span>
<span class="keyword">public void</span> <span class="function">processUserData</span>(<span class="class-name">String</span> data) {
    <span class="comment">// Validates data</span>
    <span class="comment">// Parses data</span>
    <span class="comment">// Saves to database</span>
    <span class="comment">// Sends email notification</span>
    <span class="comment">// Logs the action</span>
    <span class="comment">// Updates statistics</span>
}

<span class="comment">// ✅ GOOD: Single Responsibility - one method, one task</span>
<span class="keyword">public boolean</span> <span class="function">validateUserData</span>(<span class="class-name">String</span> data) { ... }
<span class="keyword">public</span> <span class="class-name">User</span> <span class="function">parseUserData</span>(<span class="class-name">String</span> data) { ... }
<span class="keyword">public void</span> <span class="function">saveUser</span>(<span class="class-name">User</span> user) { ... }
<span class="keyword">public void</span> <span class="function">notifyUser</span>(<span class="class-name">User</span> user) { ... }

<span class="comment">// Then compose them:</span>
<span class="keyword">public void</span> <span class="function">registerUser</span>(<span class="class-name">String</span> data) {
    <span class="keyword">if</span> (validateUserData(data)) {
        <span class="class-name">User</span> user = parseUserData(data);
        saveUser(user);
        notifyUser(user);
    }
}</code></pre>

            <pre><code><span class="comment">// ❌ BAD: Method name doesn't describe what it does</span>
<span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">String</span> s) { ... }
<span class="keyword">public int</span> <span class="function">calc</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) { ... }
<span class="keyword">public</span> <span class="class-name">User</span> <span class="function">get</span>(<span class="keyword">int</span> id) { ... }

<span class="comment">// ✅ GOOD: Clear, descriptive names (verb + noun)</span>
<span class="keyword">public void</span> <span class="function">sendEmailNotification</span>(<span class="class-name">String</span> recipient) { ... }
<span class="keyword">public int</span> <span class="function">calculateMonthlyPayment</span>(<span class="keyword">int</span> principal, <span class="keyword">int</span> months) { ... }
<span class="keyword">public</span> <span class="class-name">User</span> <span class="function">findUserById</span>(<span class="keyword">int</span> userId) { ... }

<span class="comment">// ✅ GOOD: Boolean methods ask questions</span>
<span class="keyword">public boolean</span> <span class="function">isValid</span>() { ... }
<span class="keyword">public boolean</span> <span class="function">hasPermission</span>(<span class="class-name">String</span> action) { ... }
<span class="keyword">public boolean</span> <span class="function">canEdit</span>(<span class="class-name">Document</span> doc) { ... }</code></pre>

            <pre><code><span class="comment">// ❌ BAD: Too many parameters</span>
<span class="keyword">public</span> <span class="class-name">Order</span> <span class="function">createOrder</span>(<span class="class-name">String</span> product, <span class="keyword">int</span> quantity, <span class="keyword">double</span> price,
        <span class="class-name">String</span> customer, <span class="class-name">String</span> address, <span class="class-name">String</span> city, <span class="class-name">String</span> zip,
        <span class="keyword">boolean</span> express, <span class="class-name">String</span> coupon, <span class="keyword">double</span> discount) { ... }

<span class="comment">// ✅ GOOD: Use an object to group related parameters</span>
<span class="keyword">public</span> <span class="class-name">Order</span> <span class="function">createOrder</span>(<span class="class-name">OrderRequest</span> request) { ... }

<span class="comment">// ✅ GOOD: Or use builder pattern</span>
<span class="class-name">Order</span> order = <span class="class-name">Order</span>.builder()
    .product(<span class="string">"Widget"</span>)
    .quantity(<span class="number">5</span>)
    .customer(customer)
    .shippingAddress(address)
    .express(<span class="keyword">true</span>)
    .build();</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Method Design Guidelines</div>
                <ul>
                    <li><strong>Keep methods short</strong> &ndash; Ideally under 20 lines</li>
                    <li><strong>One level of abstraction</strong> &ndash; Don't mix high and low-level operations</li>
                    <li><strong>Limit parameters to 3-4</strong> &ndash; Use objects for more</li>
                    <li><strong>Avoid side effects</strong> &ndash; Methods should be predictable</li>
                    <li><strong>Return early</strong> &ndash; Handle error cases first</li>
                    <li><strong>Use meaningful return values</strong> &ndash; Don't return null when empty collection is better</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls and How to Avoid Them</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Missing Return Statement</div>
                <pre><code><span class="comment">// ❌ ERROR: Not all paths return a value</span>
<span class="keyword">public int</span> <span class="function">getValue</span>(<span class="keyword">boolean</span> condition) {
    <span class="keyword">if</span> (condition) {
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="comment">// ERROR: missing return statement</span>
}

<span class="comment">// ✅ CORRECT: All paths return a value</span>
<span class="keyword">public int</span> <span class="function">getValue</span>(<span class="keyword">boolean</span> condition) {
    <span class="keyword">if</span> (condition) {
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// Default case</span>
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Modifying Parameters (Unexpected Side Effects)</div>
                <pre><code><span class="comment">// ❌ SURPRISING: Modifies the caller's list!</span>
<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getSortedCopy</span>(<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; items) {
    <span class="class-name">Collections</span>.sort(items);  <span class="comment">// Sorts the original list!</span>
    <span class="keyword">return</span> items;
}

<span class="comment">// ✅ CORRECT: Returns a new sorted list, original unchanged</span>
<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getSortedCopy</span>(<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; items) {
    <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; copy = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;(items);
    <span class="class-name">Collections</span>.sort(copy);
    <span class="keyword">return</span> copy;
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Returning null Instead of Empty</div>
                <pre><code><span class="comment">// ❌ BAD: Caller must check for null</span>
<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findUsers</span>(<span class="class-name">String</span> query) {
    <span class="keyword">if</span> (query == <span class="keyword">null</span>) {
        <span class="keyword">return null</span>;  <span class="comment">// Forces null checks everywhere!</span>
    }
    <span class="comment">// ...</span>
}

<span class="comment">// ✅ GOOD: Return empty collection</span>
<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findUsers</span>(<span class="class-name">String</span> query) {
    <span class="keyword">if</span> (query == <span class="keyword">null</span>) {
        <span class="keyword">return</span> <span class="class-name">Collections</span>.emptyList();  <span class="comment">// Safe to iterate!</span>
    }
    <span class="comment">// ...</span>
}

<span class="comment">// ✅ ALTERNATIVE: Use Optional for single values</span>
<span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findUserById</span>(<span class="keyword">int</span> id) {
    <span class="class-name">User</span> user = database.find(id);
    <span class="keyword">return</span> <span class="class-name">Optional</span>.ofNullable(user);
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 4: Infinite Recursion</div>
                <pre><code><span class="comment">// ❌ WRONG: No base case = StackOverflowError</span>
<span class="keyword">public int</span> <span class="function">factorial</span>(<span class="keyword">int</span> n) {
    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);  <span class="comment">// Never stops!</span>
}

<span class="comment">// ✅ CORRECT: Always have a base case</span>
<span class="keyword">public int</span> <span class="function">factorial</span>(<span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Base case stops recursion</span>
    }
    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 5: Overloading Confusion with Nulls and Varargs</div>
                <pre><code><span class="comment">// Ambiguous overloads</span>
<span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">String</span> s) { }
<span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">Integer</span> n) { }

process(<span class="keyword">null</span>);  <span class="comment">// ERROR: Ambiguous - both match null!</span>

<span class="comment">// Fix: Cast to specify which overload</span>
process((<span class="class-name">String</span>) <span class="keyword">null</span>);

<span class="comment">// Varargs ambiguity</span>
<span class="keyword">public void</span> <span class="function">log</span>(<span class="class-name">String</span>... messages) { }
<span class="keyword">public void</span> <span class="function">log</span>(<span class="class-name">String</span> level, <span class="class-name">String</span>... messages) { }

log(<span class="string">"message"</span>);  <span class="comment">// Which one? First with one arg, or second with level and empty varargs?</span></code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Common Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Q1: What is the difference between method overloading and overriding?</div>
                <p><strong>Answer:</strong> Overloading is having multiple methods with the same name but different parameters in the same class (compile-time polymorphism). Overriding is redefining a parent class's method in a subclass with the same signature (runtime polymorphism). Overloading is resolved at compile time based on reference type; overriding is resolved at runtime based on actual object type.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q2: Is Java pass by value or pass by reference?</div>
                <p><strong>Answer:</strong> Java is <strong>always</strong> pass by value. For primitives, the value is copied. For objects, the reference (memory address) is copied, not the object itself. You can modify an object's state through the copied reference, but you cannot make the caller's variable point to a different object.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q3: Can we overload the main() method?</div>
                <p><strong>Answer:</strong> Yes, you can overload main() with different parameters. However, the JVM only calls <code>public static void main(String[] args)</code> as the entry point. Other overloaded versions are just regular methods that must be called explicitly.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q4: What is a static method and when should you use it?</div>
                <p><strong>Answer:</strong> A static method belongs to the class rather than instances. It cannot access instance variables or use 'this'. Use static methods for utility functions that don't depend on object state (like Math.sqrt()), factory methods, and the main() entry point.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q5: Can a method return multiple values?</div>
                <p><strong>Answer:</strong> Not directly. Workarounds include: returning an array or collection, returning a custom object/record, using output parameters (modifying a passed object), or returning a Pair/Tuple class. In Java 14+, records make returning multiple values clean: <code>record Result(int value, String message) {}</code></p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q6: What is the covariant return type?</div>
                <p><strong>Answer:</strong> Covariant return types (Java 5+) allow an overriding method to return a subtype of the declared return type. If parent returns <code>Object</code>, child can return <code>String</code>. This doesn't apply to primitives and helps make APIs more specific in subclasses.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Troubleshooting Guide</h2>

            <h3>Error: "Missing return statement"</h3>
            <pre><code><span class="comment">// Problem: Not all code paths return a value</span>
<span class="keyword">public int</span> <span class="function">getMax</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
    <span class="keyword">if</span> (a > b) {
        <span class="keyword">return</span> a;
    }
    <span class="comment">// Missing else return!</span>
}

<span class="comment">// Solution: Ensure all paths return</span>
<span class="keyword">public int</span> <span class="function">getMax</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
    <span class="keyword">if</span> (a > b) {
        <span class="keyword">return</span> a;
    }
    <span class="keyword">return</span> b;
}</code></pre>

            <h3>Error: "Non-static method cannot be referenced from static context"</h3>
            <pre><code><span class="comment">// Problem: Calling instance method from static context</span>
<span class="keyword">public class</span> <span class="class-name">Example</span> {
    <span class="keyword">public void</span> <span class="function">instanceMethod</span>() { }

    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        instanceMethod();  <span class="comment">// ERROR!</span>
    }
}

<span class="comment">// Solution: Create an instance or make method static</span>
<span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
    <span class="class-name">Example</span> obj = <span class="keyword">new</span> <span class="class-name">Example</span>();
    obj.instanceMethod();  <span class="comment">// Works!</span>
}</code></pre>

            <h3>Error: "Unreachable statement"</h3>
            <pre><code><span class="comment">// Problem: Code after return is never executed</span>
<span class="keyword">public void</span> <span class="function">method</span>() {
    <span class="keyword">return</span>;
    <span class="class-name">System</span>.out.println(<span class="string">"Never reached"</span>);  <span class="comment">// ERROR!</span>
}

<span class="comment">// Solution: Move code before return or remove dead code</span>
<span class="keyword">public void</span> <span class="function">method</span>() {
    <span class="class-name">System</span>.out.println(<span class="string">"This runs"</span>);
    <span class="keyword">return</span>;
}</code></pre>

            <h3>Runtime: StackOverflowError</h3>
            <pre><code><span class="comment">// Problem: Infinite recursion</span>
<span class="keyword">public void</span> <span class="function">infinite</span>() {
    infinite();  <span class="comment">// Calls itself forever!</span>
}

<span class="comment">// Solution: Add base case to stop recursion</span>
<span class="keyword">public void</span> <span class="function">countdown</span>(<span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) {
        <span class="keyword">return</span>;  <span class="comment">// Base case!</span>
    }
    <span class="class-name">System</span>.out.println(n);
    countdown(n - <span class="number">1</span>);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="static-instance.html">Static vs Instance</a> &ndash; Deep dive into static members</li>
                <li><a href="access-modifiers.html">Access Modifiers</a> &ndash; Controlling method visibility</li>
                <li><a href="lambda-streams.html">Lambda & Streams</a> &ndash; Methods as first-class citizens</li>
                <li><a href="interfaces-abstract.html">Interfaces vs Abstract Classes</a> &ndash; Method contracts</li>
                <li><a href="../advanced/design-patterns.html">Design Patterns</a> &ndash; Method organization patterns</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="variables-datatypes.html" class="related-link">Variables & Data Types</a>
                <a href="access-modifiers.html" class="related-link">Access Modifiers</a>
                <a href="static-instance.html" class="related-link">Static vs Instance</a>
                <a href="constructors.html" class="related-link">Constructors</a>
                <a href="oop-principles.html" class="related-link">OOP Principles</a>
                <a href="lambda-streams.html" class="related-link">Lambda & Streams</a>
                <a href="interfaces-abstract.html" class="related-link">Interfaces vs Abstract Classes</a>
                <a href="exceptions.html" class="related-link">Exception Handling</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
