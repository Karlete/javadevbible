<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Constructors - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Constructors
            </nav>
            <h1>Constructors</h1>
            <p class="topic-subtitle">Initializing Objects in Java</p>
            <a href="../../index.html" class="back-btn">← Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What is a Constructor?</h2>
            <p>Imagine you're building a car in a factory. Before the car leaves the factory, it needs to be set up: install the engine, paint it a color, add seats, fill it with fuel. A <strong>constructor</strong> is like that factory setup process - it prepares an object before you can use it!</p>

            <p>The concept of constructors dates back to the earliest object-oriented languages. Simula 67, the first OO language, introduced the idea of initialization code that runs when an object is created. Java inherited and refined this concept, making constructors a fundamental part of object lifecycle management. Unlike some languages where initialization is optional or implicit, Java enforces that every object must go through its constructor before being used.</p>

            <p>Constructors serve a crucial role in the principle of "object validity" - the idea that an object should never exist in an invalid state. By requiring initialization through constructors, Java ensures that objects are properly set up with valid data from the moment they come into existence. This is foundational to writing robust, bug-free code.</p>

            <h3>Real-World Analogy</h3>
            <p>Think about opening a new bank account:</p>
            <ol>
                <li>You go to the bank and say "I want to create a new account" (<code>new BankAccount()</code>)</li>
                <li>The bank clerk sets up your account with:
                    <ul>
                        <li>Account number</li>
                        <li>Your name</li>
                        <li>Starting balance (maybe $0)</li>
                        <li>Account type</li>
                    </ul>
                </li>
                <li>Now your account is ready to use!</li>
            </ol>

            <p>The <strong>constructor</strong> is step 2 - it sets up the initial state of your object. Without it, your object would be empty and useless!</p>

            <h3>Simple Example - See It in Action</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Dog</span> {
    <span class="class-name">String</span> name;
    <span class="keyword">int</span> age;

    <span class="comment">// This is a CONSTRUCTOR - it runs when you create a Dog object</span>
    <span class="keyword">public</span> <span class="function">Dog</span>(<span class="class-name">String</span> dogName, <span class="keyword">int</span> dogAge) {
        name = dogName;
        age = dogAge;
        <span class="class-name">System</span>.out.println(<span class="string">"A dog named "</span> + name + <span class="string">" was born!"</span>);
    }
}

<span class="comment">// Creating (constructing) a dog object</span>
<span class="class-name">Dog</span> myDog = <span class="keyword">new</span> <span class="class-name">Dog</span>(<span class="string">"Buddy"</span>, <span class="number">3</span>);
<span class="comment">// Output: "A dog named Buddy was born!"</span>

<span class="comment">// The constructor already set up the values!</span>
<span class="class-name">System</span>.out.println(myDog.name);  <span class="comment">// "Buddy"</span>
<span class="class-name">System</span>.out.println(myDog.age);   <span class="comment">// 3</span></code></pre>

            <h3>What Happens Step by Step?</h3>
            <ol>
                <li><strong>Line 1:</strong> <code>Dog myDog = new Dog("Buddy", 3);</code>
                    <ul>
                        <li>Java sees the <code>new</code> keyword</li>
                        <li>Allocates memory for a new Dog object</li>
                        <li><strong>Automatically calls the constructor</strong> with "Buddy" and 3</li>
                    </ul>
                </li>
                <li><strong>Inside Constructor:</strong>
                    <ul>
                        <li>Sets <code>name = "Buddy"</code></li>
                        <li>Sets <code>age = 3</code></li>
                        <li>Prints "A dog named Buddy was born!"</li>
                    </ul>
                </li>
                <li><strong>After Constructor:</strong>
                    <ul>
                        <li>Object is fully set up and ready to use</li>
                        <li>Variable <code>myDog</code> now refers to this object</li>
                    </ul>
                </li>
            </ol>

            <div class="info-box note">
                <div class="info-box-title">Constructor Special Rules</div>
                <ul>
                    <li><strong>Same name as the class:</strong> Constructor must be named exactly like the class (<code>Dog</code> class → <code>Dog()</code> constructor)</li>
                    <li><strong>No return type:</strong> Not even <code>void</code>! It just doesn't have one.</li>
                    <li><strong>Called automatically:</strong> You never call a constructor directly - Java calls it when you use <code>new</code></li>
                    <li><strong>Can be overloaded:</strong> You can have multiple constructors with different parameters</li>
                    <li><strong>Always runs first:</strong> Before any other method can be called on the object</li>
                </ul>
            </div>

            <h3>Constructor vs Regular Method</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Example</span> {
    <span class="comment">// CONSTRUCTOR - no return type, same name as class</span>
    <span class="keyword">public</span> <span class="function">Example</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Constructor called!"</span>);
    }

    <span class="comment">// REGULAR METHOD - has return type, different name</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">regularMethod</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Regular method called!"</span>);
    }
}

<span class="class-name">Example</span> obj = <span class="keyword">new</span> <span class="class-name">Example</span>();  <span class="comment">// Constructor runs automatically</span>
obj.regularMethod();  <span class="comment">// You must call this explicitly</span></code></pre>

            <p>Now let's explore different types of constructors...</p>
        </section>

        <section class="content-section">
            <h2>Under the Hood: Object Creation in the JVM</h2>
            <p>Understanding what happens inside the JVM when you create an object helps explain why constructors work the way they do.</p>

            <h3>Memory Allocation and Initialization Sequence</h3>
            <pre>
┌─────────────────────────────────────────────────────────────────┐
│                   Object Creation Steps                          │
├─────────────────────────────────────────────────────────────────┤
│  1. new Dog("Buddy", 3)                                         │
│     ↓                                                           │
│  2. JVM allocates memory in Heap                                │
│     ┌──────────────────────────┐                                │
│     │  Dog Object (Heap)       │                                │
│     │  ├─ Object Header        │  ← Class pointer, hash, GC    │
│     │  ├─ name = null          │  ← Default values first       │
│     │  └─ age = 0              │                                │
│     └──────────────────────────┘                                │
│     ↓                                                           │
│  3. Instance initializers run (if any)                          │
│     ↓                                                           │
│  4. Constructor body executes                                   │
│     ┌──────────────────────────┐                                │
│     │  Dog Object (Heap)       │                                │
│     │  ├─ Object Header        │                                │
│     │  ├─ name = "Buddy"       │  ← Constructor set values     │
│     │  └─ age = 3              │                                │
│     └──────────────────────────┘                                │
│     ↓                                                           │
│  5. Reference returned to caller                                │
│     myDog ──────────────────────→ [Dog Object]                  │
└─────────────────────────────────────────────────────────────────┘
            </pre>

            <h3>The Complete Initialization Order</h3>
            <p>When creating an object, Java follows this exact sequence:</p>
            <pre><code><span class="keyword">public class</span> <span class="class-name">InitializationDemo</span> {
    <span class="comment">// Step 1: Static variables and blocks (once per class)</span>
    <span class="keyword">private static</span> <span class="class-name">String</span> staticVar = <span class="function">initStatic</span>();

    <span class="keyword">static</span> {
        <span class="class-name">System</span>.out.println(<span class="string">"2. Static block"</span>);
    }

    <span class="keyword">private static</span> <span class="class-name">String</span> <span class="function">initStatic</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"1. Static variable initializer"</span>);
        <span class="keyword">return</span> <span class="string">"static"</span>;
    }

    <span class="comment">// Step 2: Instance variables (per object)</span>
    <span class="keyword">private</span> <span class="class-name">String</span> instanceVar = <span class="function">initInstance</span>();

    <span class="comment">// Step 3: Instance initializer block (per object)</span>
    {
        <span class="class-name">System</span>.out.println(<span class="string">"4. Instance initializer block"</span>);
    }

    <span class="keyword">private</span> <span class="class-name">String</span> <span class="function">initInstance</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"3. Instance variable initializer"</span>);
        <span class="keyword">return</span> <span class="string">"instance"</span>;
    }

    <span class="comment">// Step 4: Constructor body</span>
    <span class="keyword">public</span> <span class="function">InitializationDemo</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"5. Constructor body"</span>);
    }
}

<span class="comment">// Output when creating first object:</span>
<span class="comment">// 1. Static variable initializer</span>
<span class="comment">// 2. Static block</span>
<span class="comment">// 3. Instance variable initializer</span>
<span class="comment">// 4. Instance initializer block</span>
<span class="comment">// 5. Constructor body</span>

<span class="comment">// Output when creating second object:</span>
<span class="comment">// 3. Instance variable initializer   (static already done)</span>
<span class="comment">// 4. Instance initializer block</span>
<span class="comment">// 5. Constructor body</span></code></pre>

            <h3>Bytecode View: What new Actually Does</h3>
            <pre><code><span class="comment">// Java code:</span>
<span class="class-name">Dog</span> myDog = <span class="keyword">new</span> <span class="class-name">Dog</span>(<span class="string">"Buddy"</span>, <span class="number">3</span>);

<span class="comment">// Simplified bytecode:</span>
<span class="comment">// new #2          // Allocate memory for Dog</span>
<span class="comment">// dup             // Duplicate reference on stack</span>
<span class="comment">// ldc "Buddy"     // Push "Buddy" onto stack</span>
<span class="comment">// iconst_3        // Push 3 onto stack</span>
<span class="comment">// invokespecial   // Call Dog.&lt;init&gt;(String, int)</span>
<span class="comment">// astore_1        // Store reference in myDog</span></code></pre>

            <div class="info-box note">
                <div class="info-box-title">The &lt;init&gt; Method</div>
                <p>In bytecode, constructors are compiled into special methods called <code>&lt;init&gt;</code>. This is why constructors can't be called directly like regular methods - they're handled specially by the JVM during object creation.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Default Constructor</h2>
            <p>If you don't define any constructor, Java provides a no-argument default constructor automatically. This is a convenience feature that allows simple classes to be instantiated without explicit constructor code.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Person</span> {
    <span class="class-name">String</span> name;
    <span class="keyword">int</span> age;

    <span class="comment">// No constructor defined - Java provides default constructor</span>
    <span class="comment">// It's equivalent to:</span>
    <span class="comment">// public Person() { }</span>
}

<span class="comment">// Usage</span>
<span class="class-name">Person</span> person = <span class="keyword">new</span> <span class="class-name">Person</span>();  <span class="comment">// Calls default constructor</span>
<span class="comment">// person.name = null (default for String)</span>
<span class="comment">// person.age = 0 (default for int)</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Default Constructor Disappears!</div>
                <p>Once you define ANY constructor, the default constructor is no longer provided. This is a common source of errors:</p>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Person</span> {
    <span class="class-name">String</span> name;

    <span class="comment">// We defined a parameterized constructor</span>
    <span class="keyword">public</span> <span class="function">Person</span>(<span class="class-name">String</span> name) {
        <span class="keyword">this</span>.name = name;
    }
}

<span class="class-name">Person</span> p1 = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Alice"</span>);  <span class="comment">// OK</span>
<span class="class-name">Person</span> p2 = <span class="keyword">new</span> <span class="class-name">Person</span>();          <span class="comment">// ERROR! No default constructor</span></code></pre>
            </div>

            <h3>Default Values for Fields</h3>
            <p>When using the default constructor (or any constructor that doesn't initialize all fields), fields get their type's default value:</p>
            <pre><code><span class="comment">// Default values by type:</span>
<span class="keyword">byte</span>, <span class="keyword">short</span>, <span class="keyword">int</span>, <span class="keyword">long</span>  → <span class="number">0</span>
<span class="keyword">float</span>, <span class="keyword">double</span>            → <span class="number">0.0</span>
<span class="keyword">boolean</span>                  → <span class="keyword">false</span>
<span class="keyword">char</span>                     → <span class="string">'\u0000'</span> (null character)
Object references        → <span class="keyword">null</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Custom Constructors</h2>

            <h3>No-Argument Constructor</h3>
            <p>A no-argument constructor that you define explicitly (as opposed to the default one) lets you set up default values:</p>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Account</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> accountNumber;
    <span class="keyword">private</span> <span class="keyword">double</span> balance;
    <span class="keyword">private</span> <span class="class-name">LocalDateTime</span> createdAt;

    <span class="comment">// No-argument constructor with sensible defaults</span>
    <span class="keyword">public</span> <span class="function">Account</span>() {
        <span class="keyword">this</span>.accountNumber = <span class="function">generateAccountNumber</span>();
        <span class="keyword">this</span>.balance = <span class="number">0.0</span>;
        <span class="keyword">this</span>.createdAt = <span class="class-name">LocalDateTime</span>.now();
    }

    <span class="keyword">private</span> <span class="class-name">String</span> <span class="function">generateAccountNumber</span>() {
        <span class="keyword">return</span> <span class="string">"ACC-"</span> + <span class="class-name">System</span>.currentTimeMillis();
    }
}</code></pre>

            <h3>Parameterized Constructor</h3>
            <p>Parameterized constructors allow callers to provide initial values:</p>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Person</span> {
    <span class="keyword">private final</span> <span class="class-name">String</span> name;      <span class="comment">// final = must be set in constructor</span>
    <span class="keyword">private final</span> <span class="keyword">int</span> birthYear;
    <span class="keyword">private</span> <span class="class-name">String</span> email;

    <span class="comment">// Parameterized constructor - required fields</span>
    <span class="keyword">public</span> <span class="function">Person</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> birthYear) {
        <span class="comment">// Validate inputs - constructors should ensure object validity</span>
        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.isBlank()) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Name cannot be empty"</span>);
        }
        <span class="keyword">if</span> (birthYear < <span class="number">1900</span> || birthYear > <span class="class-name">Year</span>.now().getValue()) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Invalid birth year"</span>);
        }

        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.birthYear = birthYear;
    }

    <span class="comment">// Full constructor - all fields</span>
    <span class="keyword">public</span> <span class="function">Person</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> birthYear, <span class="class-name">String</span> email) {
        <span class="keyword">this</span>(name, birthYear);  <span class="comment">// Delegate to other constructor</span>
        <span class="keyword">this</span>.email = email;
    }
}

<span class="comment">// Usage</span>
<span class="class-name">Person</span> person = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Alice"</span>, <span class="number">1990</span>);
<span class="class-name">Person</span> personWithEmail = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Bob"</span>, <span class="number">1985</span>, <span class="string">"bob@example.com"</span>);</code></pre>
        </section>

        <section class="content-section">
            <h2>Copy Constructor</h2>
            <p>A copy constructor creates a new object as a copy of an existing object. Unlike languages like C++, Java doesn't have automatic copy constructors, but you can implement them yourself:</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Address</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> street;
    <span class="keyword">private</span> <span class="class-name">String</span> city;
    <span class="keyword">private</span> <span class="class-name">String</span> zipCode;

    <span class="comment">// Regular constructor</span>
    <span class="keyword">public</span> <span class="function">Address</span>(<span class="class-name">String</span> street, <span class="class-name">String</span> city, <span class="class-name">String</span> zipCode) {
        <span class="keyword">this</span>.street = street;
        <span class="keyword">this</span>.city = city;
        <span class="keyword">this</span>.zipCode = zipCode;
    }

    <span class="comment">// Copy constructor - creates a deep copy</span>
    <span class="keyword">public</span> <span class="function">Address</span>(<span class="class-name">Address</span> other) {
        <span class="keyword">this</span>.street = other.street;    <span class="comment">// String is immutable, so this is safe</span>
        <span class="keyword">this</span>.city = other.city;
        <span class="keyword">this</span>.zipCode = other.zipCode;
    }
}

<span class="keyword">public class</span> <span class="class-name">Employee</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;
    <span class="keyword">private</span> <span class="class-name">Address</span> address;  <span class="comment">// Mutable object reference</span>
    <span class="keyword">private</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; skills;

    <span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name, <span class="class-name">Address</span> address, <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; skills) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.address = address;
        <span class="keyword">this</span>.skills = skills;
    }

    <span class="comment">// Copy constructor - must handle mutable objects carefully!</span>
    <span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">Employee</span> other) {
        <span class="keyword">this</span>.name = other.name;                      <span class="comment">// String immutable - OK</span>
        <span class="keyword">this</span>.address = <span class="keyword">new</span> <span class="class-name">Address</span>(other.address);   <span class="comment">// Deep copy!</span>
        <span class="keyword">this</span>.skills = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;(other.skills); <span class="comment">// Deep copy!</span>
    }
}

<span class="comment">// Usage</span>
<span class="class-name">Employee</span> original = <span class="keyword">new</span> <span class="class-name">Employee</span>(<span class="string">"Alice"</span>, address, skills);
<span class="class-name">Employee</span> copy = <span class="keyword">new</span> <span class="class-name">Employee</span>(original);  <span class="comment">// Independent copy</span>

<span class="comment">// Changes to copy don't affect original</span>
copy.getAddress().setCity(<span class="string">"New City"</span>);
<span class="class-name">System</span>.out.println(original.getAddress().getCity());  <span class="comment">// Still "Old City"</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Shallow vs Deep Copy</div>
                <p><strong>Shallow copy:</strong> Copies references, not the objects they point to. Changes to referenced objects affect both copies.</p>
                <p><strong>Deep copy:</strong> Creates new copies of all referenced objects. Completely independent objects.</p>
                <pre><code><span class="comment">// WRONG: Shallow copy</span>
<span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">Employee</span> other) {
    <span class="keyword">this</span>.address = other.address;  <span class="comment">// Both point to same Address!</span>
}

<span class="comment">// CORRECT: Deep copy</span>
<span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">Employee</span> other) {
    <span class="keyword">this</span>.address = <span class="keyword">new</span> <span class="class-name">Address</span>(other.address);  <span class="comment">// New Address object</span>
}</code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Constructor Overloading</h2>
            <p>A class can have multiple constructors with different parameters. This provides flexibility in how objects are created:</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Rectangle</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> width;
    <span class="keyword">private</span> <span class="keyword">double</span> height;

    <span class="comment">// Constructor 1: No parameters (default size)</span>
    <span class="keyword">public</span> <span class="function">Rectangle</span>() {
        <span class="keyword">this</span>.width = <span class="number">1.0</span>;
        <span class="keyword">this</span>.height = <span class="number">1.0</span>;
    }

    <span class="comment">// Constructor 2: Square (one parameter)</span>
    <span class="keyword">public</span> <span class="function">Rectangle</span>(<span class="keyword">double</span> size) {
        <span class="keyword">this</span>.width = size;
        <span class="keyword">this</span>.height = size;
    }

    <span class="comment">// Constructor 3: Rectangle (two parameters)</span>
    <span class="keyword">public</span> <span class="function">Rectangle</span>(<span class="keyword">double</span> width, <span class="keyword">double</span> height) {
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
    }

    <span class="keyword">public</span> <span class="keyword">double</span> <span class="function">area</span>() {
        <span class="keyword">return</span> width * height;
    }
}

<span class="comment">// Usage - different ways to create objects</span>
<span class="class-name">Rectangle</span> r1 = <span class="keyword">new</span> <span class="class-name">Rectangle</span>();  <span class="comment">// 1x1</span>
<span class="class-name">Rectangle</span> r2 = <span class="keyword">new</span> <span class="class-name">Rectangle</span>(<span class="number">5.0</span>);  <span class="comment">// 5x5 square</span>
<span class="class-name">Rectangle</span> r3 = <span class="keyword">new</span> <span class="class-name">Rectangle</span>(<span class="number">4.0</span>, <span class="number">6.0</span>);  <span class="comment">// 4x6 rectangle</span></code></pre>

            <h3>Real-World Example: Connection Configuration</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">DatabaseConnection</span> {
    <span class="keyword">private final</span> <span class="class-name">String</span> host;
    <span class="keyword">private final</span> <span class="keyword">int</span> port;
    <span class="keyword">private final</span> <span class="class-name">String</span> database;
    <span class="keyword">private final</span> <span class="class-name">String</span> username;
    <span class="keyword">private final</span> <span class="class-name">String</span> password;
    <span class="keyword">private final</span> <span class="keyword">int</span> timeout;

    <span class="comment">// Full constructor</span>
    <span class="keyword">public</span> <span class="function">DatabaseConnection</span>(<span class="class-name">String</span> host, <span class="keyword">int</span> port, <span class="class-name">String</span> database,
                               <span class="class-name">String</span> username, <span class="class-name">String</span> password, <span class="keyword">int</span> timeout) {
        <span class="keyword">this</span>.host = host;
        <span class="keyword">this</span>.port = port;
        <span class="keyword">this</span>.database = database;
        <span class="keyword">this</span>.username = username;
        <span class="keyword">this</span>.password = password;
        <span class="keyword">this</span>.timeout = timeout;
    }

    <span class="comment">// Simplified: default port and timeout</span>
    <span class="keyword">public</span> <span class="function">DatabaseConnection</span>(<span class="class-name">String</span> host, <span class="class-name">String</span> database,
                               <span class="class-name">String</span> username, <span class="class-name">String</span> password) {
        <span class="keyword">this</span>(host, <span class="number">5432</span>, database, username, password, <span class="number">30000</span>);
    }

    <span class="comment">// Local development: defaults for everything</span>
    <span class="keyword">public</span> <span class="function">DatabaseConnection</span>(<span class="class-name">String</span> database) {
        <span class="keyword">this</span>(<span class="string">"localhost"</span>, <span class="number">5432</span>, database, <span class="string">"dev"</span>, <span class="string">"dev"</span>, <span class="number">5000</span>);
    }
}

<span class="comment">// Usage scenarios</span>
<span class="class-name">DatabaseConnection</span> prod = <span class="keyword">new</span> <span class="class-name">DatabaseConnection</span>(
    <span class="string">"prod.db.server"</span>, <span class="number">5432</span>, <span class="string">"myapp"</span>, <span class="string">"admin"</span>, <span class="string">"secret"</span>, <span class="number">60000</span>
);
<span class="class-name">DatabaseConnection</span> staging = <span class="keyword">new</span> <span class="class-name">DatabaseConnection</span>(
    <span class="string">"staging.db.server"</span>, <span class="string">"myapp"</span>, <span class="string">"user"</span>, <span class="string">"pass"</span>
);
<span class="class-name">DatabaseConnection</span> local = <span class="keyword">new</span> <span class="class-name">DatabaseConnection</span>(<span class="string">"myapp"</span>);</code></pre>
        </section>

        <section class="content-section">
            <h2>Constructor Chaining</h2>
            <p>Use <span class="inline-code">this()</span> to call another constructor in the same class. This reduces code duplication and centralizes initialization logic.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Employee</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> <span class="keyword">double</span> salary;
    <span class="keyword">private</span> <span class="class-name">String</span> department;

    <span class="comment">// Primary constructor - all validation and logic here</span>
    <span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> salary, <span class="class-name">String</span> department) {
        <span class="comment">// All validation in one place</span>
        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.isBlank()) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Name required"</span>);
        }
        <span class="keyword">if</span> (salary < <span class="number">0</span>) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Salary cannot be negative"</span>);
        }

        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.salary = salary;
        <span class="keyword">this</span>.department = department;
    }

    <span class="comment">// Chain to primary - default department</span>
    <span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> salary) {
        <span class="keyword">this</span>(name, id, salary, <span class="string">"Unassigned"</span>);
    }

    <span class="comment">// Chain to above - default salary</span>
    <span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> id) {
        <span class="keyword">this</span>(name, id, <span class="number">50000.0</span>);
    }

    <span class="comment">// Chain to above - auto-generate ID</span>
    <span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name) {
        <span class="keyword">this</span>(name, <span class="function">generateId</span>());
    }

    <span class="keyword">private static</span> <span class="keyword">int</span> nextId = <span class="number">1000</span>;
    <span class="keyword">private static</span> <span class="keyword">int</span> <span class="function">generateId</span>() {
        <span class="keyword">return</span> nextId++;
    }
}</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">this() Rules</div>
                <ul>
                    <li><span class="inline-code">this()</span> must be the <strong>first statement</strong> in constructor</li>
                    <li>You cannot have both <span class="inline-code">this()</span> and <span class="inline-code">super()</span> in the same constructor</li>
                    <li>Reduces code duplication - validation logic in one place</li>
                    <li>Improves maintainability - changes propagate automatically</li>
                    <li>Constructors should chain "upward" to the most specific one</li>
                </ul>
            </div>

            <h3>Constructor Chain Visualization</h3>
            <pre>
┌────────────────────────────────────────────────────────────────┐
│                    Constructor Chaining                         │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Employee("Alice")                                             │
│        │                                                        │
│        ▼                                                        │
│   Employee("Alice", 1000)     ← generateId() returns 1000      │
│        │                                                        │
│        ▼                                                        │
│   Employee("Alice", 1000, 50000.0)     ← default salary        │
│        │                                                        │
│        ▼                                                        │
│   Employee("Alice", 1000, 50000.0, "Unassigned")  ← default    │
│        │                                                        │
│        ▼                                                        │
│   [Validation + Field Assignment]    ← All logic here          │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
            </pre>
        </section>

        <section class="content-section">
            <h2>Calling Parent Constructors</h2>
            <p>Use <span class="inline-code">super()</span> to call the parent class constructor. This is essential for inheritance.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Animal</span> {
    <span class="keyword">protected</span> <span class="class-name">String</span> name;
    <span class="keyword">protected</span> <span class="keyword">int</span> age;

    <span class="keyword">public</span> <span class="function">Animal</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
        <span class="class-name">System</span>.out.println(<span class="string">"Animal constructor called"</span>);
    }
}

<span class="keyword">public class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> breed;

    <span class="keyword">public</span> <span class="function">Dog</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age, <span class="class-name">String</span> breed) {
        <span class="keyword">super</span>(name, age);  <span class="comment">// MUST be first statement</span>
        <span class="keyword">this</span>.breed = breed;
        <span class="class-name">System</span>.out.println(<span class="string">"Dog constructor called"</span>);
    }
}

<span class="comment">// Usage</span>
<span class="class-name">Dog</span> dog = <span class="keyword">new</span> <span class="class-name">Dog</span>(<span class="string">"Buddy"</span>, <span class="number">3</span>, <span class="string">"Golden Retriever"</span>);
<span class="comment">// Output:</span>
<span class="comment">// Animal constructor called</span>
<span class="comment">// Dog constructor called</span></code></pre>

            <h3>Inheritance Constructor Rules</h3>
            <pre>
┌────────────────────────────────────────────────────────────────┐
│              Inheritance Constructor Execution                  │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   new Dog("Buddy", 3, "Golden")                                │
│        │                                                        │
│        ▼                                                        │
│   Dog constructor starts                                        │
│        │                                                        │
│        ▼                                                        │
│   super(name, age) called → Animal constructor runs FIRST      │
│        │                                                        │
│        ▼                                                        │
│   Animal constructor completes                                  │
│        │                                                        │
│        ▼                                                        │
│   Dog constructor body continues                                │
│        │                                                        │
│        ▼                                                        │
│   Object fully initialized                                      │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
            </pre>

            <div class="info-box important">
                <div class="info-box-title">super() Rules</div>
                <ul>
                    <li><code>super()</code> must be the <strong>first statement</strong> in the constructor</li>
                    <li>If you don't call <code>super()</code>, Java automatically inserts <code>super()</code> (no-arg)</li>
                    <li>If parent has no no-arg constructor, you MUST explicitly call <code>super(args)</code></li>
                    <li>You cannot use both <code>this()</code> and <code>super()</code> in the same constructor</li>
                </ul>
            </div>

            <h3>Multi-Level Inheritance</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Animal</span> {
    <span class="keyword">public</span> <span class="function">Animal</span>() { <span class="class-name">System</span>.out.println(<span class="string">"Animal"</span>); }
}

<span class="keyword">public class</span> <span class="class-name">Mammal</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">public</span> <span class="function">Mammal</span>() { <span class="class-name">System</span>.out.println(<span class="string">"Mammal"</span>); }
}

<span class="keyword">public class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Mammal</span> {
    <span class="keyword">public</span> <span class="function">Dog</span>() { <span class="class-name">System</span>.out.println(<span class="string">"Dog"</span>); }
}

<span class="class-name">Dog</span> dog = <span class="keyword">new</span> <span class="class-name">Dog</span>();
<span class="comment">// Output (parent first, then child):</span>
<span class="comment">// Animal</span>
<span class="comment">// Mammal</span>
<span class="comment">// Dog</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Private Constructors</h2>
            <p>Private constructors prevent external instantiation. They're used in several design patterns:</p>

            <h3>Singleton Pattern</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">DatabaseConnection</span> {
    <span class="keyword">private static</span> <span class="class-name">DatabaseConnection</span> instance;

    <span class="comment">// Private constructor - can't create from outside</span>
    <span class="keyword">private</span> <span class="function">DatabaseConnection</span>() {
        <span class="comment">// Initialize connection</span>
    }

    <span class="comment">// Only way to get an instance</span>
    <span class="keyword">public static</span> <span class="class-name">DatabaseConnection</span> <span class="function">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> <span class="class-name">DatabaseConnection</span>();
        }
        <span class="keyword">return</span> instance;
    }
}

<span class="comment">// Usage</span>
<span class="class-name">DatabaseConnection</span> db = <span class="class-name">DatabaseConnection</span>.getInstance();
<span class="comment">// DatabaseConnection db2 = new DatabaseConnection(); // ERROR!</span></code></pre>

            <h3>Utility Classes</h3>
            <pre><code><span class="keyword">public final class</span> <span class="class-name">StringUtils</span> {
    <span class="comment">// Private constructor - utility class should not be instantiated</span>
    <span class="keyword">private</span> <span class="function">StringUtils</span>() {
        <span class="keyword">throw new</span> <span class="class-name">AssertionError</span>(<span class="string">"Cannot instantiate utility class"</span>);
    }

    <span class="keyword">public static</span> <span class="keyword">boolean</span> <span class="function">isEmpty</span>(<span class="class-name">String</span> str) {
        <span class="keyword">return</span> str == <span class="keyword">null</span> || str.isEmpty();
    }

    <span class="keyword">public static</span> <span class="class-name">String</span> <span class="function">capitalize</span>(<span class="class-name">String</span> str) {
        <span class="keyword">if</span> (<span class="function">isEmpty</span>(str)) <span class="keyword">return</span> str;
        <span class="keyword">return</span> <span class="class-name">Character</span>.toUpperCase(str.charAt(<span class="number">0</span>)) + str.substring(<span class="number">1</span>);
    }
}</code></pre>

            <h3>Factory Pattern with Static Factory Methods</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Color</span> {
    <span class="keyword">private final</span> <span class="keyword">int</span> red, green, blue;

    <span class="comment">// Private constructor</span>
    <span class="keyword">private</span> <span class="function">Color</span>(<span class="keyword">int</span> red, <span class="keyword">int</span> green, <span class="keyword">int</span> blue) {
        <span class="keyword">this</span>.red = red;
        <span class="keyword">this</span>.green = green;
        <span class="keyword">this</span>.blue = blue;
    }

    <span class="comment">// Static factory methods - more readable than constructors</span>
    <span class="keyword">public static</span> <span class="class-name">Color</span> <span class="function">fromRGB</span>(<span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b) {
        <span class="function">validateRange</span>(r, g, b);
        <span class="keyword">return new</span> <span class="class-name">Color</span>(r, g, b);
    }

    <span class="keyword">public static</span> <span class="class-name">Color</span> <span class="function">fromHex</span>(<span class="class-name">String</span> hex) {
        <span class="comment">// Parse hex and create color</span>
        <span class="keyword">int</span> r = <span class="class-name">Integer</span>.parseInt(hex.substring(<span class="number">1</span>, <span class="number">3</span>), <span class="number">16</span>);
        <span class="keyword">int</span> g = <span class="class-name">Integer</span>.parseInt(hex.substring(<span class="number">3</span>, <span class="number">5</span>), <span class="number">16</span>);
        <span class="keyword">int</span> b = <span class="class-name">Integer</span>.parseInt(hex.substring(<span class="number">5</span>, <span class="number">7</span>), <span class="number">16</span>);
        <span class="keyword">return new</span> <span class="class-name">Color</span>(r, g, b);
    }

    <span class="comment">// Pre-defined colors</span>
    <span class="keyword">public static</span> <span class="class-name">Color</span> <span class="function">red</span>()   { <span class="keyword">return new</span> <span class="class-name">Color</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); }
    <span class="keyword">public static</span> <span class="class-name">Color</span> <span class="function">green</span>() { <span class="keyword">return new</span> <span class="class-name">Color</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>); }
    <span class="keyword">public static</span> <span class="class-name">Color</span> <span class="function">blue</span>()  { <span class="keyword">return new</span> <span class="class-name">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>); }

    <span class="keyword">private static void</span> <span class="function">validateRange</span>(<span class="keyword">int</span>... values) {
        <span class="keyword">for</span> (<span class="keyword">int</span> v : values) {
            <span class="keyword">if</span> (v < <span class="number">0</span> || v > <span class="number">255</span>) {
                <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Value must be 0-255"</span>);
            }
        }
    }
}

<span class="comment">// Usage - much more readable!</span>
<span class="class-name">Color</span> c1 = <span class="class-name">Color</span>.fromRGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>);
<span class="class-name">Color</span> c2 = <span class="class-name">Color</span>.fromHex(<span class="string">"#FF8000"</span>);
<span class="class-name">Color</span> c3 = <span class="class-name">Color</span>.red();</code></pre>
        </section>

        <section class="content-section">
            <h2>In Practice: Real-World Patterns</h2>

            <h3>Builder Pattern (Alternative to Many Constructors)</h3>
            <p>When a class has many optional parameters, constructors become unwieldy. The Builder pattern solves this:</p>
            <pre><code><span class="keyword">public class</span> <span class="class-name">HttpRequest</span> {
    <span class="keyword">private final</span> <span class="class-name">String</span> url;
    <span class="keyword">private final</span> <span class="class-name">String</span> method;
    <span class="keyword">private final</span> <span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">String</span>&gt; headers;
    <span class="keyword">private final</span> <span class="class-name">String</span> body;
    <span class="keyword">private final</span> <span class="keyword">int</span> timeout;
    <span class="keyword">private final</span> <span class="keyword">boolean</span> followRedirects;

    <span class="comment">// Private constructor - only Builder can create</span>
    <span class="keyword">private</span> <span class="function">HttpRequest</span>(<span class="class-name">Builder</span> builder) {
        <span class="keyword">this</span>.url = builder.url;
        <span class="keyword">this</span>.method = builder.method;
        <span class="keyword">this</span>.headers = <span class="class-name">Map</span>.copyOf(builder.headers);
        <span class="keyword">this</span>.body = builder.body;
        <span class="keyword">this</span>.timeout = builder.timeout;
        <span class="keyword">this</span>.followRedirects = builder.followRedirects;
    }

    <span class="keyword">public static class</span> <span class="class-name">Builder</span> {
        <span class="comment">// Required</span>
        <span class="keyword">private final</span> <span class="class-name">String</span> url;

        <span class="comment">// Optional with defaults</span>
        <span class="keyword">private</span> <span class="class-name">String</span> method = <span class="string">"GET"</span>;
        <span class="keyword">private</span> <span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">String</span>&gt; headers = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();
        <span class="keyword">private</span> <span class="class-name">String</span> body = <span class="keyword">null</span>;
        <span class="keyword">private</span> <span class="keyword">int</span> timeout = <span class="number">30000</span>;
        <span class="keyword">private</span> <span class="keyword">boolean</span> followRedirects = <span class="keyword">true</span>;

        <span class="keyword">public</span> <span class="function">Builder</span>(<span class="class-name">String</span> url) {
            <span class="keyword">this</span>.url = url;
        }

        <span class="keyword">public</span> <span class="class-name">Builder</span> <span class="function">method</span>(<span class="class-name">String</span> method) {
            <span class="keyword">this</span>.method = method;
            <span class="keyword">return this</span>;
        }

        <span class="keyword">public</span> <span class="class-name">Builder</span> <span class="function">header</span>(<span class="class-name">String</span> key, <span class="class-name">String</span> value) {
            <span class="keyword">this</span>.headers.put(key, value);
            <span class="keyword">return this</span>;
        }

        <span class="keyword">public</span> <span class="class-name">Builder</span> <span class="function">body</span>(<span class="class-name">String</span> body) {
            <span class="keyword">this</span>.body = body;
            <span class="keyword">return this</span>;
        }

        <span class="keyword">public</span> <span class="class-name">Builder</span> <span class="function">timeout</span>(<span class="keyword">int</span> timeout) {
            <span class="keyword">this</span>.timeout = timeout;
            <span class="keyword">return this</span>;
        }

        <span class="keyword">public</span> <span class="class-name">Builder</span> <span class="function">followRedirects</span>(<span class="keyword">boolean</span> follow) {
            <span class="keyword">this</span>.followRedirects = follow;
            <span class="keyword">return this</span>;
        }

        <span class="keyword">public</span> <span class="class-name">HttpRequest</span> <span class="function">build</span>() {
            <span class="keyword">return new</span> <span class="class-name">HttpRequest</span>(<span class="keyword">this</span>);
        }
    }
}

<span class="comment">// Usage - clear and readable!</span>
<span class="class-name">HttpRequest</span> request = <span class="keyword">new</span> <span class="class-name">HttpRequest</span>.<span class="class-name">Builder</span>(<span class="string">"https://api.example.com/data"</span>)
    .method(<span class="string">"POST"</span>)
    .header(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
    .header(<span class="string">"Authorization"</span>, <span class="string">"Bearer token123"</span>)
    .body(<span class="string">"{\"name\": \"test\"}"</span>)
    .timeout(<span class="number">5000</span>)
    .build();</code></pre>

            <h3>Record Classes (Java 16+)</h3>
            <p>For simple data carriers, Java records provide automatic constructors:</p>
            <pre><code><span class="comment">// Record automatically provides:</span>
<span class="comment">// - Constructor with all fields</span>
<span class="comment">// - Getters for all fields</span>
<span class="comment">// - equals(), hashCode(), toString()</span>
<span class="keyword">public record</span> <span class="class-name">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) {
    <span class="comment">// Compact constructor for validation</span>
    <span class="keyword">public</span> <span class="class-name">Point</span> {
        <span class="keyword">if</span> (x < <span class="number">0</span> || y < <span class="number">0</span>) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Coordinates must be positive"</span>);
        }
        <span class="comment">// No need for this.x = x; - done automatically</span>
    }

    <span class="comment">// Additional constructor</span>
    <span class="keyword">public</span> <span class="class-name">Point</span>() {
        <span class="keyword">this</span>(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// Must delegate to canonical constructor</span>
    }
}

<span class="comment">// Usage</span>
<span class="class-name">Point</span> p1 = <span class="keyword">new</span> <span class="class-name">Point</span>(<span class="number">10</span>, <span class="number">20</span>);
<span class="class-name">Point</span> p2 = <span class="keyword">new</span> <span class="class-name">Point</span>();  <span class="comment">// (0, 0)</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Best Practices</h2>

            <div class="info-box tip">
                <div class="info-box-title">Constructor Best Practices</div>
                <ol>
                    <li><strong>Validate all inputs:</strong> Constructors should ensure the object is in a valid state
                        <pre><code><span class="keyword">public</span> <span class="function">Person</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
    <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="keyword">throw new</span> <span class="class-name">NullPointerException</span>(<span class="string">"name"</span>);
    <span class="keyword">if</span> (age < <span class="number">0</span>) <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"age < 0"</span>);
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.age = age;
}</code></pre>
                    </li>
                    <li><strong>Initialize all fields:</strong> Don't leave fields with default values unless intentional</li>
                    <li><strong>Use constructor chaining:</strong> DRY - Don't Repeat Yourself</li>
                    <li><strong>Make defensive copies:</strong> For mutable parameters, copy them
                        <pre><code><span class="keyword">public</span> <span class="function">Event</span>(<span class="class-name">Date</span> date) {
    <span class="keyword">this</span>.date = <span class="keyword">new</span> <span class="class-name">Date</span>(date.getTime()); <span class="comment">// Defensive copy</span>
}</code></pre>
                    </li>
                    <li><strong>Don't call overridable methods:</strong> Can cause issues with subclasses</li>
                    <li><strong>Keep constructors simple:</strong> Avoid complex logic; consider factory methods</li>
                    <li><strong>Document constructor requirements:</strong> Use @throws in Javadoc</li>
                </ol>
            </div>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Forgetting super() When Parent Has No Default Constructor</div>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Animal</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;

    <span class="keyword">public</span> <span class="function">Animal</span>(<span class="class-name">String</span> name) {  <span class="comment">// Only parameterized constructor</span>
        <span class="keyword">this</span>.name = name;
    }
}

<span class="comment">// BAD: Compilation error!</span>
<span class="keyword">public class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">public</span> <span class="function">Dog</span>() {
        <span class="comment">// Java inserts super() implicitly</span>
        <span class="comment">// But Animal has no no-arg constructor!</span>
    }
}

<span class="comment">// GOOD: Explicit super() call</span>
<span class="keyword">public class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">public</span> <span class="function">Dog</span>() {
        <span class="keyword">super</span>(<span class="string">"Unknown"</span>);  <span class="comment">// Explicit call with argument</span>
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Calling Overridable Methods in Constructor</div>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Parent</span> {
    <span class="keyword">public</span> <span class="function">Parent</span>() {
        <span class="function">init</span>();  <span class="comment">// DANGEROUS! Can be overridden</span>
    }

    <span class="keyword">public void</span> <span class="function">init</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Parent init"</span>);
    }
}

<span class="keyword">public class</span> <span class="class-name">Child</span> <span class="keyword">extends</span> <span class="class-name">Parent</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> value = <span class="string">"initialized"</span>;

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">init</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Value: "</span> + value);  <span class="comment">// value is null!</span>
    }
}

<span class="keyword">new</span> <span class="class-name">Child</span>();  <span class="comment">// Prints "Value: null" - field not yet initialized!</span>

<span class="comment">// SOLUTION: Use final methods or private helper methods</span>
<span class="keyword">public class</span> <span class="class-name">Parent</span> {
    <span class="keyword">public</span> <span class="function">Parent</span>() {
        <span class="function">initInternal</span>();  <span class="comment">// Private - can't be overridden</span>
    }

    <span class="keyword">private void</span> <span class="function">initInternal</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Safe init"</span>);
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Storing Mutable Parameters Directly</div>
                <pre><code><span class="comment">// BAD: External code can modify internal state</span>
<span class="keyword">public class</span> <span class="class-name">Schedule</span> {
    <span class="keyword">private</span> <span class="class-name">Date</span>[] dates;

    <span class="keyword">public</span> <span class="function">Schedule</span>(<span class="class-name">Date</span>[] dates) {
        <span class="keyword">this</span>.dates = dates;  <span class="comment">// Stores reference directly!</span>
    }
}

<span class="class-name">Date</span>[] myDates = { <span class="keyword">new</span> <span class="class-name">Date</span>() };
<span class="class-name">Schedule</span> s = <span class="keyword">new</span> <span class="class-name">Schedule</span>(myDates);
myDates[<span class="number">0</span>] = <span class="keyword">null</span>;  <span class="comment">// Now schedule's internal array has null!</span>

<span class="comment">// GOOD: Make defensive copy</span>
<span class="keyword">public class</span> <span class="class-name">Schedule</span> {
    <span class="keyword">private</span> <span class="class-name">Date</span>[] dates;

    <span class="keyword">public</span> <span class="function">Schedule</span>(<span class="class-name">Date</span>[] dates) {
        <span class="keyword">this</span>.dates = <span class="class-name">Arrays</span>.copyOf(dates, dates.length);
        <span class="comment">// Deep copy if Date objects are mutable</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="keyword">this</span>.dates.length; i++) {
            <span class="keyword">this</span>.dates[i] = <span class="keyword">new</span> <span class="class-name">Date</span>(<span class="keyword">this</span>.dates[i].getTime());
        }
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 4: Exception in Constructor Leaves Partial Object</div>
                <pre><code><span class="comment">// BAD: Resource leak if second allocation fails</span>
<span class="keyword">public class</span> <span class="class-name">ResourceHolder</span> {
    <span class="keyword">private</span> <span class="class-name">Connection</span> conn;
    <span class="keyword">private</span> <span class="class-name">FileInputStream</span> fis;

    <span class="keyword">public</span> <span class="function">ResourceHolder</span>(<span class="class-name">String</span> dbUrl, <span class="class-name">String</span> filePath) <span class="keyword">throws</span> <span class="class-name">Exception</span> {
        conn = <span class="class-name">DriverManager</span>.getConnection(dbUrl);  <span class="comment">// OK</span>
        fis = <span class="keyword">new</span> <span class="class-name">FileInputStream</span>(filePath);  <span class="comment">// If this throws, conn leaks!</span>
    }
}

<span class="comment">// GOOD: Clean up on failure</span>
<span class="keyword">public class</span> <span class="class-name">ResourceHolder</span> {
    <span class="keyword">private</span> <span class="class-name">Connection</span> conn;
    <span class="keyword">private</span> <span class="class-name">FileInputStream</span> fis;

    <span class="keyword">public</span> <span class="function">ResourceHolder</span>(<span class="class-name">String</span> dbUrl, <span class="class-name">String</span> filePath) <span class="keyword">throws</span> <span class="class-name">Exception</span> {
        <span class="keyword">try</span> {
            conn = <span class="class-name">DriverManager</span>.getConnection(dbUrl);
            fis = <span class="keyword">new</span> <span class="class-name">FileInputStream</span>(filePath);
        } <span class="keyword">catch</span> (<span class="class-name">Exception</span> e) {
            <span class="comment">// Clean up partially created resources</span>
            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) conn.close();
            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) fis.close();
            <span class="keyword">throw</span> e;
        }
    }
}</code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Performance Considerations</h2>

            <h3>Object Creation Cost</h3>
            <pre><code><span class="comment">// Object creation involves:</span>
<span class="comment">// 1. Memory allocation (very fast in Java)</span>
<span class="comment">// 2. Field initialization (zero-fill, then explicit values)</span>
<span class="comment">// 3. Constructor execution</span>

<span class="comment">// AVOID: Creating objects in tight loops when possible</span>
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000000</span>; i++) {
    <span class="class-name">StringBuilder</span> sb = <span class="keyword">new</span> <span class="class-name">StringBuilder</span>();  <span class="comment">// 1M objects created!</span>
    sb.append(i);
    process(sb.toString());
}

<span class="comment">// BETTER: Reuse when possible</span>
<span class="class-name">StringBuilder</span> sb = <span class="keyword">new</span> <span class="class-name">StringBuilder</span>();
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000000</span>; i++) {
    sb.setLength(<span class="number">0</span>);  <span class="comment">// Reset instead of creating new</span>
    sb.append(i);
    process(sb.toString());
}</code></pre>

            <h3>Constructor Chaining Overhead</h3>
            <pre><code><span class="comment">// Deep constructor chains have minimal overhead</span>
<span class="comment">// JVM inlines small methods, including constructor calls</span>

<span class="comment">// This is FINE - JVM optimizes it:</span>
<span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name) {
    <span class="keyword">this</span>(name, <span class="number">0</span>);
}
<span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> id) {
    <span class="keyword">this</span>(name, id, <span class="number">50000</span>);
}
<span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> salary) {
    <span class="comment">// actual initialization</span>
}</code></pre>

            <h3>Static Factory Methods vs Constructors</h3>
            <pre><code><span class="comment">// Static factory methods can cache instances</span>
<span class="keyword">public class</span> <span class="class-name">Boolean</span> {
    <span class="keyword">public static final</span> <span class="class-name">Boolean</span> TRUE = <span class="keyword">new</span> <span class="class-name">Boolean</span>(<span class="keyword">true</span>);
    <span class="keyword">public static final</span> <span class="class-name">Boolean</span> FALSE = <span class="keyword">new</span> <span class="class-name">Boolean</span>(<span class="keyword">false</span>);

    <span class="comment">// Returns cached instance - no object creation!</span>
    <span class="keyword">public static</span> <span class="class-name">Boolean</span> <span class="function">valueOf</span>(<span class="keyword">boolean</span> b) {
        <span class="keyword">return</span> b ? TRUE : FALSE;
    }
}

<span class="comment">// Prefer valueOf() over new Boolean() - it's cached!</span>
<span class="class-name">Boolean</span> b1 = <span class="class-name">Boolean</span>.valueOf(<span class="keyword">true</span>);  <span class="comment">// Uses cached instance</span>
<span class="class-name">Boolean</span> b2 = <span class="keyword">new</span> <span class="class-name">Boolean</span>(<span class="keyword">true</span>);      <span class="comment">// Creates new object (wasteful)</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Troubleshooting Guide</h2>

            <h3>Common Compilation Errors</h3>

            <div class="info-box note">
                <div class="info-box-title">"constructor X in class Y cannot be applied to given types"</div>
                <p><strong>Cause:</strong> Calling constructor with wrong argument types or count</p>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Person</span> {
    <span class="keyword">public</span> <span class="function">Person</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) { }
}

<span class="class-name">Person</span> p = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Alice"</span>);  <span class="comment">// ERROR: missing age argument</span>
<span class="class-name">Person</span> p = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="number">25</span>, <span class="string">"Alice"</span>);  <span class="comment">// ERROR: wrong order</span></code></pre>
                <p><strong>Fix:</strong> Match the constructor's parameter list exactly</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">"call to this must be first statement in constructor"</div>
                <p><strong>Cause:</strong> Code before this() or super()</p>
                <pre><code><span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name) {
    <span class="class-name">System</span>.out.println(<span class="string">"Creating..."</span>);  <span class="comment">// ERROR!</span>
    <span class="keyword">this</span>(name, <span class="number">0</span>);
}

<span class="comment">// Fix: this() must be first</span>
<span class="keyword">public</span> <span class="function">Employee</span>(<span class="class-name">String</span> name) {
    <span class="keyword">this</span>(name, <span class="number">0</span>);
    <span class="class-name">System</span>.out.println(<span class="string">"Creating..."</span>);  <span class="comment">// OK - after this()</span>
}</code></pre>
            </div>

            <div class="info-box note">
                <div class="info-box-title">"variable x might not have been initialized"</div>
                <p><strong>Cause:</strong> Final field not set in all constructor paths</p>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Config</span> {
    <span class="keyword">private final</span> <span class="class-name">String</span> value;

    <span class="keyword">public</span> <span class="function">Config</span>(<span class="keyword">boolean</span> useDefault) {
        <span class="keyword">if</span> (useDefault) {
            value = <span class="string">"default"</span>;
        }
        <span class="comment">// ERROR: value not set when useDefault is false!</span>
    }
}

<span class="comment">// Fix: Set in all paths</span>
<span class="keyword">public</span> <span class="function">Config</span>(<span class="keyword">boolean</span> useDefault) {
    <span class="keyword">if</span> (useDefault) {
        value = <span class="string">"default"</span>;
    } <span class="keyword">else</span> {
        value = <span class="string">"custom"</span>;
    }
}</code></pre>
            </div>

            <div class="info-box note">
                <div class="info-box-title">"recursive constructor invocation"</div>
                <p><strong>Cause:</strong> Constructor calls itself (directly or indirectly)</p>
                <pre><code><span class="keyword">public</span> <span class="function">MyClass</span>() {
    <span class="keyword">this</span>();  <span class="comment">// ERROR: calls itself!</span>
}

<span class="keyword">public</span> <span class="function">MyClass</span>() {
    <span class="keyword">this</span>(<span class="number">0</span>);
}
<span class="keyword">public</span> <span class="function">MyClass</span>(<span class="keyword">int</span> x) {
    <span class="keyword">this</span>();  <span class="comment">// ERROR: circular chain!</span>
}</code></pre>
                <p><strong>Fix:</strong> Ensure constructor chain terminates</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Q1: What is the difference between a constructor and a method?</div>
                <p><strong>Answer:</strong></p>
                <ul>
                    <li><strong>Name:</strong> Constructor has the same name as the class; methods can have any name</li>
                    <li><strong>Return type:</strong> Constructor has no return type (not even void); methods must have one</li>
                    <li><strong>Invocation:</strong> Constructor is called automatically with <code>new</code>; methods are called explicitly</li>
                    <li><strong>Purpose:</strong> Constructor initializes objects; methods perform operations</li>
                    <li><strong>Inheritance:</strong> Constructors are not inherited; methods can be</li>
                </ul>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q2: Can a constructor be private? When would you use it?</div>
                <p><strong>Answer:</strong> Yes, constructors can be private. Use cases include:</p>
                <ul>
                    <li><strong>Singleton pattern:</strong> Ensure only one instance exists</li>
                    <li><strong>Utility classes:</strong> Prevent instantiation of classes with only static methods</li>
                    <li><strong>Factory pattern:</strong> Force use of static factory methods for controlled object creation</li>
                    <li><strong>Builder pattern:</strong> Allow only the nested Builder class to create instances</li>
                </ul>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q3: What happens if you don't call super() in a subclass constructor?</div>
                <p><strong>Answer:</strong> Java automatically inserts <code>super()</code> (no-argument) as the first statement. If the parent class doesn't have a no-argument constructor, you'll get a compilation error and must explicitly call <code>super(args)</code> with appropriate arguments.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q4: Can you call this() and super() in the same constructor?</div>
                <p><strong>Answer:</strong> No. Both must be the first statement, so you can only have one. If you use <code>this()</code>, the chained constructor will eventually call <code>super()</code>.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q5: What is constructor chaining and why is it useful?</div>
                <p><strong>Answer:</strong> Constructor chaining is when one constructor calls another using <code>this()</code> or <code>super()</code>. Benefits:</p>
                <ul>
                    <li>Reduces code duplication (DRY principle)</li>
                    <li>Centralizes validation and initialization logic</li>
                    <li>Makes maintenance easier - change one place, affects all constructors</li>
                    <li>Ensures consistency across different ways of creating objects</li>
                </ul>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q6: What is the order of initialization when creating an object?</div>
                <p><strong>Answer:</strong> When creating a new object:</p>
                <ol>
                    <li>Static variables and static blocks (only first time class is loaded)</li>
                    <li>Instance variables (set to default values)</li>
                    <li>Instance initializer blocks (in order of appearance)</li>
                    <li>Constructor body</li>
                </ol>
                <p>For inheritance, parent's initialization completes before child's.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q7: What is a copy constructor? How do you implement deep copy?</div>
                <p><strong>Answer:</strong> A copy constructor creates a new object by copying another object of the same class. For deep copy:</p>
                <ul>
                    <li>Primitive fields: Copy directly (already values)</li>
                    <li>Immutable objects (String, Integer, etc.): Can copy reference safely</li>
                    <li>Mutable objects: Must create new copies, not copy references</li>
                    <li>Collections: Create new collection and copy contents</li>
                </ul>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q8: When should you use a Builder pattern instead of telescoping constructors?</div>
                <p><strong>Answer:</strong> Use Builder when:</p>
                <ul>
                    <li>Class has many parameters (more than 4-5)</li>
                    <li>Many parameters are optional</li>
                    <li>Parameters have the same type (easy to mix up order)</li>
                    <li>Object construction requires multiple steps or validation</li>
                    <li>You want immutable objects with many fields</li>
                </ul>
                <p>Builder provides readable code, named parameters, and optional-parameter handling.</p>
            </div>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="oop-principles.html" class="related-link">OOP Principles</a>
                <a href="methods.html" class="related-link">Methods & Functions</a>
                <a href="access-modifiers.html" class="related-link">Access Modifiers</a>
                <a href="static-instance.html" class="related-link">Static vs Instance</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
