<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optional Class - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Optional Class
            </nav>
            <h1>Optional Class</h1>
            <p class="topic-subtitle">Handling Null Values Elegantly</p>
            <a href="../../index.html" class="back-btn">â† Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <!-- Introduction Section -->
        <section class="content-section">
            <h2>Introduction</h2>
            <p><code>java.util.Optional</code>, introduced in <strong>Java 8 (2014)</strong>, is a container object that may or may not contain a non-null value. It represents the explicit possibility of absence and forces developers to consciously handle the case when a value might not exist.</p>

            <p>Optional is Java's answer to the infamous "billion dollar mistake"â€”the invention of null references. Sir Tony Hoare, who introduced null in 1965, later called it his billion dollar mistake because it has caused countless bugs, crashes, and security vulnerabilities across software history.</p>

            <div class="info-box">
                <strong>The Billion Dollar Mistake:</strong> "I call it my billion-dollar mistake. It was the invention of the null reference in 1965... This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years." â€” Sir Tony Hoare
            </div>

            <p>Optional doesn't eliminate null from Java, but it provides a type-level solution that makes null-handling explicit, self-documenting, and safer when used correctly.</p>
        </section>

        <!-- The Problem Optional Solves -->
        <section class="content-section">
            <h2>The Problem Optional Solves</h2>

            <pre><code class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    THE NULL PROBLEM                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  BEFORE Optional (The null minefield):                         â”‚
â”‚                                                                 â”‚
â”‚  public User findUserById(int id) {                            â”‚
â”‚      return database.findById(id);  // Might return null!      â”‚
â”‚  }                                                              â”‚
â”‚                                                                 â”‚
â”‚  // Caller has no idea null is possible from signature         â”‚
â”‚  User user = findUserById(123);                                â”‚
â”‚  String name = user.getName();  // ğŸ’¥ NullPointerException!   â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  WITH Optional (Explicit absence):                             â”‚
â”‚                                                                 â”‚
â”‚  public Optional&lt;User&gt; findUserById(int id) {                  â”‚
â”‚      return Optional.ofNullable(database.findById(id));        â”‚
â”‚  }                                                              â”‚
â”‚                                                                 â”‚
â”‚  // Caller KNOWS absence is possible from the type signature!  â”‚
â”‚  Optional&lt;User&gt; user = findUserById(123);                      â”‚
â”‚  String name = user.map(User::getName).orElse("Unknown");     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </code></pre>

            <h3>Why Null Is Problematic</h3>
            <ul>
                <li><strong>Silent:</strong> A method returning null gives no compile-time indication that absence is possible</li>
                <li><strong>Ambiguous:</strong> Does null mean "not found", "error", "not initialized", or something else?</li>
                <li><strong>Infectious:</strong> Null checks propagate through code, adding defensive clutter everywhere</li>
                <li><strong>Runtime failures:</strong> NullPointerException is Java's most common runtime error</li>
            </ul>

            <h3>What Optional Provides</h3>
            <ul>
                <li><strong>Type-level documentation:</strong> The return type tells you absence is possible</li>
                <li><strong>Forced handling:</strong> You must explicitly deal with the empty case</li>
                <li><strong>Fluent API:</strong> Chain operations safely without null checks</li>
                <li><strong>Functional style:</strong> Works seamlessly with lambdas and streams</li>
            </ul>
        </section>

        <!-- Creating Optional Objects -->
        <section class="content-section">
            <h2>Creating Optional Objects</h2>

            <pre><code class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CREATING OPTIONALS                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Optional.empty()      â†’ Empty Optional (no value)             â”‚
â”‚                                                                 â”‚
â”‚  Optional.of(value)    â†’ Optional with value                   â”‚
â”‚                         (throws NPE if value is null!)         â”‚
â”‚                                                                 â”‚
â”‚  Optional.ofNullable() â†’ Optional that handles null safely     â”‚
â”‚                         (empty if null, present otherwise)     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </code></pre>

            <h3>Optional.empty() - Explicitly Empty</h3>
            <pre><code><span class="comment">// Create an empty Optional - represents absence</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; empty = <span class="class-name">Optional</span>.empty();

<span class="class-name">System</span>.out.println(empty.isPresent());  <span class="comment">// false</span>
<span class="class-name">System</span>.out.println(empty.isEmpty());    <span class="comment">// true (Java 11+)</span>

<span class="comment">// Useful for early returns or default values</span>
<span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findUser</span>(<span class="class-name">String</span> username) {
    <span class="keyword">if</span> (username == <span class="keyword">null</span> || username.isBlank()) {
        <span class="keyword">return</span> <span class="class-name">Optional</span>.empty();
    }
    <span class="comment">// ... lookup logic</span>
}</code></pre>

            <h3>Optional.of() - Non-null Value Required</h3>
            <pre><code><span class="comment">// Create Optional with a guaranteed non-null value</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; name = <span class="class-name">Optional</span>.of(<span class="string">"Alice"</span>);

<span class="class-name">System</span>.out.println(name.isPresent());  <span class="comment">// true</span>
<span class="class-name">System</span>.out.println(name.get());        <span class="comment">// "Alice"</span>

<span class="comment">// âš ï¸ CAUTION: Throws NullPointerException if value is null!</span>
<span class="class-name">String</span> nullValue = <span class="keyword">null</span>;
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; boom = <span class="class-name">Optional</span>.of(nullValue);  <span class="comment">// ğŸ’¥ NPE!</span>

<span class="comment">// Use Optional.of() when you KNOW the value is not null</span>
<span class="comment">// It's a programming error if it is null</span></code></pre>

            <h3>Optional.ofNullable() - Null-Safe Creation</h3>
            <pre><code><span class="comment">// Safely create Optional from a potentially null value</span>
<span class="class-name">String</span> possiblyNull = <span class="keyword">null</span>;
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; optional = <span class="class-name">Optional</span>.ofNullable(possiblyNull);

<span class="class-name">System</span>.out.println(optional.isPresent());  <span class="comment">// false (safely empty)</span>

<span class="comment">// This is the MOST COMMON factory method for wrapping external values</span>
<span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findUserById</span>(<span class="keyword">int</span> id) {
    <span class="class-name">User</span> user = database.findById(id);  <span class="comment">// Might return null</span>
    <span class="keyword">return</span> <span class="class-name">Optional</span>.ofNullable(user);    <span class="comment">// Safely wrapped</span>
}

<span class="comment">// Equivalent behavior:</span>
<span class="comment">// ofNullable(null) â†’ Optional.empty()</span>
<span class="comment">// ofNullable(value) â†’ Optional.of(value)</span></code></pre>
        </section>

        <!-- Checking and Extracting Values -->
        <section class="content-section">
            <h2>Checking and Extracting Values</h2>

            <h3>isPresent() and isEmpty()</h3>
            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; present = <span class="class-name">Optional</span>.of(<span class="string">"Hello"</span>);
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; absent = <span class="class-name">Optional</span>.empty();

<span class="comment">// isPresent() - true if value exists</span>
present.isPresent();  <span class="comment">// true</span>
absent.isPresent();   <span class="comment">// false</span>

<span class="comment">// isEmpty() - true if no value (Java 11+)</span>
present.isEmpty();    <span class="comment">// false</span>
absent.isEmpty();     <span class="comment">// true</span>

<span class="comment">// Imperative style (sometimes needed, but prefer functional methods)</span>
<span class="keyword">if</span> (present.isPresent()) {
    <span class="class-name">System</span>.out.println(<span class="string">"Value: "</span> + present.get());
}</code></pre>

            <h3>get() - Direct Access (Use With Caution!)</h3>
            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; optional = <span class="class-name">Optional</span>.of(<span class="string">"Hello"</span>);
<span class="class-name">String</span> value = optional.get();  <span class="comment">// "Hello"</span>

<span class="comment">// âš ï¸ DANGER: Throws NoSuchElementException if empty!</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; empty = <span class="class-name">Optional</span>.empty();
<span class="class-name">String</span> crash = empty.get();  <span class="comment">// ğŸ’¥ NoSuchElementException!</span></code></pre>

            <div class="warning-box">
                <strong>Avoid get()!</strong> Calling <code>get()</code> without checking <code>isPresent()</code> defeats the purpose of Optional. It's just trading NullPointerException for NoSuchElementException. Always prefer <code>orElse()</code>, <code>orElseGet()</code>, <code>orElseThrow()</code>, or functional methods.
            </div>

            <h3>orElse() - Default Value</h3>
            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; present = <span class="class-name">Optional</span>.of(<span class="string">"Hello"</span>);
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; absent = <span class="class-name">Optional</span>.empty();

<span class="comment">// Returns value if present, otherwise returns the default</span>
<span class="class-name">String</span> result1 = present.orElse(<span class="string">"Default"</span>);  <span class="comment">// "Hello"</span>
<span class="class-name">String</span> result2 = absent.orElse(<span class="string">"Default"</span>);   <span class="comment">// "Default"</span>

<span class="comment">// Common patterns</span>
<span class="class-name">String</span> username = findUsername(id).orElse(<span class="string">"Anonymous"</span>);
<span class="class-name">Integer</span> count = getCount().orElse(<span class="number">0</span>);
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; items = getItems().orElse(<span class="class-name">Collections</span>.emptyList());</code></pre>

            <h3>orElseGet() - Lazy Default (Supplier)</h3>
            <pre><code><span class="comment">// Default is computed ONLY if Optional is empty</span>
<span class="class-name">String</span> value = optional.orElseGet(() -&gt; computeExpensiveDefault());

<span class="comment">// â”€â”€â”€ orElse() vs orElseGet() - IMPORTANT DIFFERENCE! â”€â”€â”€</span>

<span class="comment">// orElse(): Default is ALWAYS evaluated, even if value is present</span>
<span class="class-name">String</span> a = present.orElse(expensiveOperation());  <span class="comment">// expensiveOperation() runs!</span>

<span class="comment">// orElseGet(): Default is evaluated ONLY if absent</span>
<span class="class-name">String</span> b = present.orElseGet(() -&gt; expensiveOperation());  <span class="comment">// NOT called</span>

<span class="comment">// Example showing the difference:</span>
<span class="keyword">public</span> <span class="class-name">String</span> <span class="function">createUser</span>() {
    <span class="class-name">System</span>.out.println(<span class="string">"Creating user..."</span>);  <span class="comment">// Side effect!</span>
    <span class="keyword">return</span> <span class="string">"New User"</span>;
}

<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; name = <span class="class-name">Optional</span>.of(<span class="string">"Alice"</span>);

<span class="comment">// BAD: "Creating user..." prints even though we have a value!</span>
name.orElse(createUser());

<span class="comment">// GOOD: "Creating user..." does NOT print</span>
name.orElseGet(<span class="keyword">this</span>::createUser);</code></pre>

            <div class="info-box">
                <strong>Rule of Thumb:</strong> Use <code>orElse()</code> for simple constants. Use <code>orElseGet()</code> when the default involves computation, I/O, or side effects.
            </div>

            <h3>orElseThrow() - Throw on Empty</h3>
            <pre><code><span class="comment">// Throw custom exception if empty</span>
<span class="class-name">User</span> user = findUserById(id)
    .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="class-name">UserNotFoundException</span>(<span class="string">"User not found: "</span> + id));

<span class="comment">// Java 10+: No-arg version throws NoSuchElementException</span>
<span class="class-name">User</span> user = findUserById(id).orElseThrow();

<span class="comment">// Common pattern for required values</span>
<span class="keyword">public</span> <span class="class-name">User</span> <span class="function">getRequiredUser</span>(<span class="keyword">int</span> id) {
    <span class="keyword">return</span> userRepository.findById(id)
        .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Invalid user ID: "</span> + id));
}</code></pre>

            <h3>or() - Alternative Optional (Java 9+)</h3>
            <pre><code><span class="comment">// Returns this Optional if present, otherwise returns alternative Optional</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; primary = <span class="class-name">Optional</span>.empty();
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; fallback = <span class="class-name">Optional</span>.of(<span class="string">"Backup"</span>);

<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; result = primary.or(() -&gt; fallback);  <span class="comment">// Optional["Backup"]</span>

<span class="comment">// Useful for cascading lookups</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; user = findInCache(id)
    .or(() -&gt; findInDatabase(id))
    .or(() -&gt; findInExternalService(id));</code></pre>
        </section>

        <!-- Conditional Actions -->
        <section class="content-section">
            <h2>Conditional Actions</h2>

            <h3>ifPresent() - Execute If Value Exists</h3>
            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; name = <span class="class-name">Optional</span>.of(<span class="string">"Alice"</span>);

<span class="comment">// Execute action only if value is present</span>
name.ifPresent(n -&gt; <span class="class-name">System</span>.out.println(<span class="string">"Hello, "</span> + n));
<span class="comment">// Output: "Hello, Alice"</span>

<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; empty = <span class="class-name">Optional</span>.empty();
empty.ifPresent(n -&gt; <span class="class-name">System</span>.out.println(<span class="string">"Hello, "</span> + n));
<span class="comment">// No output - action not executed</span>

<span class="comment">// Common use cases</span>
findUser(id).ifPresent(user -&gt; emailService.sendWelcome(user));
findConfig(key).ifPresent(config -&gt; applySettings(config));</code></pre>

            <h3>ifPresentOrElse() - Handle Both Cases (Java 9+)</h3>
            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; user = findUserById(id);

<span class="comment">// Execute one action if present, another if absent</span>
user.ifPresentOrElse(
    u -&gt; <span class="class-name">System</span>.out.println(<span class="string">"Found user: "</span> + u.getName()),
    () -&gt; <span class="class-name">System</span>.out.println(<span class="string">"User not found"</span>)
);

<span class="comment">// Real-world example</span>
findOrder(orderId).ifPresentOrElse(
    order -&gt; processOrder(order),
    () -&gt; logMissingOrder(orderId)
);</code></pre>
        </section>

        <!-- Transforming Values -->
        <section class="content-section">
            <h2>Transforming Values</h2>

            <h3>map() - Transform the Contained Value</h3>
            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; name = <span class="class-name">Optional</span>.of(<span class="string">"alice"</span>);

<span class="comment">// Transform String â†’ String</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; upper = name.map(<span class="class-name">String</span>::toUpperCase);
<span class="class-name">System</span>.out.println(upper.get());  <span class="comment">// "ALICE"</span>

<span class="comment">// Transform String â†’ Integer</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">Integer</span>&gt; length = name.map(<span class="class-name">String</span>::length);
<span class="class-name">System</span>.out.println(length.get());  <span class="comment">// 5</span>

<span class="comment">// If Optional is empty, map returns empty</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; empty = <span class="class-name">Optional</span>.empty();
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; result = empty.map(<span class="class-name">String</span>::toUpperCase);
<span class="class-name">System</span>.out.println(result.isPresent());  <span class="comment">// false</span>

<span class="comment">// Chaining transformations</span>
<span class="class-name">String</span> greeting = <span class="class-name">Optional</span>.of(<span class="string">"  alice  "</span>)
    .map(<span class="class-name">String</span>::trim)
    .map(<span class="class-name">String</span>::toUpperCase)
    .map(n -&gt; <span class="string">"Hello, "</span> + n + <span class="string">"!"</span>)
    .orElse(<span class="string">"Hello, stranger!"</span>);
<span class="comment">// "Hello, ALICE!"</span></code></pre>

            <h3>flatMap() - Avoid Nested Optionals</h3>
            <pre><code><span class="comment">// When a method returns Optional, map() creates nested Optional</span>
<span class="keyword">class</span> <span class="class-name">User</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> email;  <span class="comment">// might be null</span>

    <span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getEmail</span>() {
        <span class="keyword">return</span> <span class="class-name">Optional</span>.ofNullable(email);
    }
}

<span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; user = findUserById(<span class="number">123</span>);

<span class="comment">// âŒ BAD: map() creates Optional&lt;Optional&lt;String&gt;&gt;</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt;&gt; nested = user.map(<span class="class-name">User</span>::getEmail);

<span class="comment">// âœ… GOOD: flatMap() flattens to Optional&lt;String&gt;</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; email = user.flatMap(<span class="class-name">User</span>::getEmail);

<span class="comment">// â”€â”€â”€ Real-world chaining example â”€â”€â”€</span>
<span class="keyword">class</span> <span class="class-name">Person</span> {
    <span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">Address</span>&gt; <span class="function">getAddress</span>() { ... }
}

<span class="keyword">class</span> <span class="class-name">Address</span> {
    <span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">City</span>&gt; <span class="function">getCity</span>() { ... }
}

<span class="keyword">class</span> <span class="class-name">City</span> {
    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getName</span>() { ... }
}

<span class="comment">// Chain through multiple Optional-returning methods</span>
<span class="class-name">String</span> cityName = findPerson(id)
    .flatMap(<span class="class-name">Person</span>::getAddress)   <span class="comment">// Optional&lt;Address&gt;</span>
    .flatMap(<span class="class-name">Address</span>::getCity)      <span class="comment">// Optional&lt;City&gt;</span>
    .map(<span class="class-name">City</span>::getName)              <span class="comment">// Optional&lt;String&gt;</span>
    .orElse(<span class="string">"Unknown"</span>);

<span class="comment">// Without Optional, this would require nested null checks:</span>
<span class="comment">// if (person != null && person.getAddress() != null &&</span>
<span class="comment">//     person.getAddress().getCity() != null) { ... }</span></code></pre>

            <pre><code class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  map() vs flatMap()                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  map():                                                         â”‚
â”‚  Optional&lt;T&gt;.map(T â†’ R) = Optional&lt;R&gt;                          â”‚
â”‚                                                                 â”‚
â”‚  flatMap():                                                     â”‚
â”‚  Optional&lt;T&gt;.flatMap(T â†’ Optional&lt;R&gt;) = Optional&lt;R&gt;            â”‚
â”‚                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Use map() when transformation returns a plain value            â”‚
â”‚  Use flatMap() when transformation returns an Optional          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </code></pre>
        </section>

        <!-- Filtering Values -->
        <section class="content-section">
            <h2>Filtering Values</h2>

            <pre><code><span class="class-name">Optional</span>&lt;<span class="class-name">Integer</span>&gt; number = <span class="class-name">Optional</span>.of(<span class="number">42</span>);

<span class="comment">// filter() - Keep value only if it matches the predicate</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">Integer</span>&gt; even = number.filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);
<span class="class-name">System</span>.out.println(even.isPresent());  <span class="comment">// true (42 is even)</span>

<span class="class-name">Optional</span>&lt;<span class="class-name">Integer</span>&gt; greaterThan100 = number.filter(n -&gt; n > <span class="number">100</span>);
<span class="class-name">System</span>.out.println(greaterThan100.isPresent());  <span class="comment">// false</span>

<span class="comment">// If Optional is already empty, filter returns empty</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">Integer</span>&gt; empty = <span class="class-name">Optional</span>.empty();
<span class="class-name">Optional</span>&lt;<span class="class-name">Integer</span>&gt; filtered = empty.filter(n -&gt; n > <span class="number">0</span>);
<span class="class-name">System</span>.out.println(filtered.isPresent());  <span class="comment">// false</span>

<span class="comment">// â”€â”€â”€ Practical example: Validate and transform â”€â”€â”€</span>
<span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findActiveAdminUser</span>(<span class="keyword">int</span> id) {
    <span class="keyword">return</span> findUserById(id)
        .filter(<span class="class-name">User</span>::isActive)
        .filter(<span class="class-name">User</span>::isAdmin);
}

<span class="comment">// â”€â”€â”€ String validation example â”€â”€â”€</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; validEmail = <span class="class-name">Optional</span>.ofNullable(email)
    .filter(e -&gt; e.contains(<span class="string">"@"</span>))
    .filter(e -&gt; e.length() &gt; <span class="number">5</span>);</code></pre>
        </section>

        <!-- Converting to Stream -->
        <section class="content-section">
            <h2>Converting to Stream (Java 9+)</h2>

            <pre><code><span class="comment">// stream() - Convert Optional to a Stream of 0 or 1 elements</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; present = <span class="class-name">Optional</span>.of(<span class="string">"Hello"</span>);
<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; absent = <span class="class-name">Optional</span>.empty();

present.stream().forEach(<span class="class-name">System</span>.out::println);  <span class="comment">// "Hello"</span>
absent.stream().forEach(<span class="class-name">System</span>.out::println);   <span class="comment">// (nothing)</span>

<span class="comment">// â”€â”€â”€ Most useful with flatMap in streams â”€â”€â”€</span>
<span class="class-name">List</span>&lt;<span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt;&gt; optionals = <span class="class-name">List</span>.of(
    <span class="class-name">Optional</span>.of(<span class="string">"A"</span>),
    <span class="class-name">Optional</span>.empty(),
    <span class="class-name">Optional</span>.of(<span class="string">"B"</span>),
    <span class="class-name">Optional</span>.empty(),
    <span class="class-name">Optional</span>.of(<span class="string">"C"</span>)
);

<span class="comment">// Extract only present values</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; values = optionals.stream()
    .flatMap(<span class="class-name">Optional</span>::stream)  <span class="comment">// Filters out empties!</span>
    .collect(<span class="class-name">Collectors</span>.toList());
<span class="comment">// ["A", "B", "C"]</span>

<span class="comment">// Before Java 9, you had to do this:</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; valuesOld = optionals.stream()
    .filter(<span class="class-name">Optional</span>::isPresent)
    .map(<span class="class-name">Optional</span>::get)
    .collect(<span class="class-name">Collectors</span>.toList());

<span class="comment">// â”€â”€â”€ Transform list of IDs to list of found users â”€â”€â”€</span>
<span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; userIds = <span class="class-name">List</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);

<span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; foundUsers = userIds.stream()
    .map(<span class="keyword">this</span>::findUserById)      <span class="comment">// Stream&lt;Optional&lt;User&gt;&gt;</span>
    .flatMap(<span class="class-name">Optional</span>::stream)    <span class="comment">// Stream&lt;User&gt; (only found)</span>
    .collect(<span class="class-name">Collectors</span>.toList());</code></pre>
        </section>

        <!-- Practical Examples -->
        <section class="content-section">
            <h2>Practical Examples</h2>

            <h3>Example 1: Repository Pattern</h3>
            <pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="class-name">UserRepository</span> {
    <span class="comment">// Return Optional for single-entity lookups</span>
    <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findById</span>(<span class="class-name">Long</span> id);
    <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findByEmail</span>(<span class="class-name">String</span> email);
    <span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findByUsername</span>(<span class="class-name">String</span> username);

    <span class="comment">// Return empty collection (not Optional) for multi-entity queries</span>
    <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findAll</span>();
    <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findByRole</span>(<span class="class-name">String</span> role);
}

<span class="comment">// Service layer usage</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">UserService</span> {
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class-name">UserRepository</span> repository;

    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">getUserOrThrow</span>(<span class="class-name">Long</span> id) {
        <span class="keyword">return</span> repository.findById(id)
            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="class-name">UserNotFoundException</span>(id));
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getUserDisplayName</span>(<span class="class-name">Long</span> id) {
        <span class="keyword">return</span> repository.findById(id)
            .map(<span class="class-name">User</span>::getDisplayName)
            .orElse(<span class="string">"Anonymous"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">sendWelcomeEmail</span>(<span class="class-name">Long</span> id) {
        repository.findById(id)
            .flatMap(<span class="class-name">User</span>::getEmail)
            .ifPresent(email -&gt; emailService.sendWelcome(email));
    }
}</code></pre>

            <h3>Example 2: Configuration with Defaults</h3>
            <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">AppConfig</span> {
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">String</span>&gt; properties;

    <span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; <span class="function">get</span>(<span class="class-name">String</span> key) {
        <span class="keyword">return</span> <span class="class-name">Optional</span>.ofNullable(properties.get(key));
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getOrDefault</span>(<span class="class-name">String</span> key, <span class="class-name">String</span> defaultValue) {
        <span class="keyword">return</span> get(key).orElse(defaultValue);
    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="function">getInt</span>(<span class="class-name">String</span> key, <span class="keyword">int</span> defaultValue) {
        <span class="keyword">return</span> get(key)
            .map(<span class="class-name">Integer</span>::parseInt)
            .orElse(defaultValue);
    }

    <span class="keyword">public</span> <span class="keyword">int</span> <span class="function">getRequiredInt</span>(<span class="class-name">String</span> key) {
        <span class="keyword">return</span> get(key)
            .map(<span class="class-name">Integer</span>::parseInt)
            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="class-name">MissingConfigException</span>(key));
    }
}

<span class="comment">// Usage</span>
<span class="keyword">int</span> port = config.getInt(<span class="string">"server.port"</span>, <span class="number">8080</span>);
<span class="class-name">String</span> env = config.getOrDefault(<span class="string">"environment"</span>, <span class="string">"development"</span>);
<span class="class-name">String</span> dbUrl = config.get(<span class="string">"database.url"</span>)
    .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="class-name">StartupException</span>(<span class="string">"Database URL required"</span>));</code></pre>

            <h3>Example 3: Cascading Lookups</h3>
            <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">ProductService</span> {

    <span class="comment">// Try multiple sources in order</span>
    <span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">Product</span>&gt; <span class="function">findProduct</span>(<span class="class-name">String</span> sku) {
        <span class="keyword">return</span> cache.get(sku)
            .or(() -&gt; database.findBySku(sku))
            .or(() -&gt; externalCatalog.lookup(sku));
    }

    <span class="comment">// Get price with fallback strategy</span>
    <span class="keyword">public</span> <span class="class-name">BigDecimal</span> <span class="function">getPrice</span>(<span class="class-name">String</span> sku) {
        <span class="keyword">return</span> findProduct(sku)
            .map(<span class="class-name">Product</span>::getPrice)
            .or(() -&gt; getPriceFromHistory(sku))
            .orElse(<span class="class-name">BigDecimal</span>.ZERO);
    }
}</code></pre>
        </section>

        <!-- Common Pitfalls -->
        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="pitfall-box">
                <h4>âš ï¸ Pitfall 1: Using isPresent() + get()</h4>
                <p>This pattern defeats the purpose of Optionalâ€”it's just as bad as null checks.</p>
                <pre><code><span class="comment">// âŒ BAD: Defeats the purpose of Optional</span>
<span class="keyword">if</span> (optional.isPresent()) {
    <span class="class-name">String</span> value = optional.get();
    process(value);
}

<span class="comment">// âœ… GOOD: Use functional methods</span>
optional.ifPresent(<span class="keyword">this</span>::process);

<span class="comment">// Or for transformations:</span>
<span class="class-name">String</span> result = optional.map(<span class="keyword">this</span>::transform).orElse(defaultValue);</code></pre>
            </div>

            <div class="pitfall-box">
                <h4>âš ï¸ Pitfall 2: Using Optional as a Field</h4>
                <p>Optional is not Serializable and was not designed for fields.</p>
                <pre><code><span class="comment">// âŒ BAD: Optional as a field</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">User</span> {
    <span class="keyword">private</span> <span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; middleName;  <span class="comment">// Don't do this!</span>
}

<span class="comment">// âœ… GOOD: Use nullable field, return Optional from getter</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="class-name">User</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> middleName;  <span class="comment">// Can be null</span>

    <span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getMiddleName</span>() {
        <span class="keyword">return</span> <span class="class-name">Optional</span>.ofNullable(middleName);
    }
}</code></pre>
            </div>

            <div class="pitfall-box">
                <h4>âš ï¸ Pitfall 3: Using Optional as Method Parameter</h4>
                <p>Parameters should be nullable or use method overloading instead.</p>
                <pre><code><span class="comment">// âŒ BAD: Optional parameter</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="function">createUser</span>(<span class="class-name">String</span> name, <span class="class-name">Optional</span>&lt;<span class="class-name">String</span>&gt; email) {
    <span class="comment">// Caller forced to wrap: createUser("Bob", Optional.empty())</span>
}

<span class="comment">// âœ… GOOD: Method overloading</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="function">createUser</span>(<span class="class-name">String</span> name) {
    createUser(name, <span class="keyword">null</span>);
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="function">createUser</span>(<span class="class-name">String</span> name, <span class="class-name">String</span> email) {
    <span class="comment">// Handle null email internally</span>
}

<span class="comment">// âœ… ALSO GOOD: Builder pattern for multiple optional params</span></code></pre>
            </div>

            <div class="pitfall-box">
                <h4>âš ï¸ Pitfall 4: Returning Optional of Collection</h4>
                <p>Return empty collection insteadâ€”no need to wrap in Optional.</p>
                <pre><code><span class="comment">// âŒ BAD: Optional of collection</span>
<span class="keyword">public</span> <span class="class-name">Optional</span>&lt;<span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt;&gt; <span class="function">findUsers</span>() {
    <span class="keyword">return</span> <span class="class-name">Optional</span>.ofNullable(users);
}

<span class="comment">// âœ… GOOD: Return empty collection</span>
<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findUsers</span>() {
    <span class="keyword">return</span> users != <span class="keyword">null</span> ? users : <span class="class-name">Collections</span>.emptyList();
}</code></pre>
            </div>

            <div class="pitfall-box">
                <h4>âš ï¸ Pitfall 5: orElse() with Expensive Default</h4>
                <p>Use orElseGet() when the default involves computation.</p>
                <pre><code><span class="comment">// âŒ BAD: createDefaultUser() called even when user is present!</span>
<span class="class-name">User</span> user = findUser(id).orElse(createDefaultUser());

<span class="comment">// âœ… GOOD: createDefaultUser() only called when needed</span>
<span class="class-name">User</span> user = findUser(id).orElseGet(<span class="keyword">this</span>::createDefaultUser);</code></pre>
            </div>

            <div class="pitfall-box">
                <h4>âš ï¸ Pitfall 6: Nested Optional</h4>
                <p>Never return Optional&lt;Optional&lt;T&gt;&gt;â€”flatten with flatMap().</p>
                <pre><code><span class="comment">// âŒ BAD: Returns Optional&lt;Optional&lt;Address&gt;&gt;</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">Optional</span>&lt;<span class="class-name">Address</span>&gt;&gt; nested = user.map(<span class="class-name">User</span>::getAddress);

<span class="comment">// âœ… GOOD: Flattened to Optional&lt;Address&gt;</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">Address</span>&gt; address = user.flatMap(<span class="class-name">User</span>::getAddress);</code></pre>
            </div>
        </section>

        <!-- Interview Questions -->
        <section class="content-section">
            <h2>Interview Questions</h2>

            <div class="interview-question">
                <h4>Q1: What is Optional and why was it introduced?</h4>
                <div class="answer">
                    <p>Optional is a container that may or may not contain a non-null value. It was introduced in Java 8 to provide a type-level solution to represent the absence of a value, making null-handling explicit and reducing NullPointerExceptions. It forces developers to consciously handle the empty case.</p>
                </div>
            </div>

            <div class="interview-question">
                <h4>Q2: What's the difference between Optional.of() and Optional.ofNullable()?</h4>
                <div class="answer">
                    <p><code>Optional.of(value)</code> throws NullPointerException if value is nullâ€”use when null is a programming error. <code>Optional.ofNullable(value)</code> returns Optional.empty() if value is nullâ€”use when null is a valid possibility (like wrapping external data).</p>
                </div>
            </div>

            <div class="interview-question">
                <h4>Q3: What's the difference between orElse() and orElseGet()?</h4>
                <div class="answer">
                    <p><code>orElse(defaultValue)</code> always evaluates the default, even when a value is present. <code>orElseGet(supplier)</code> only evaluates the supplier when the Optional is empty. Use orElseGet() when the default involves computation, I/O, or side effects.</p>
                </div>
            </div>

            <div class="interview-question">
                <h4>Q4: When should you NOT use Optional?</h4>
                <div class="answer">
                    <p>Don't use Optional: (1) as class fields (not Serializable), (2) as method parameters (use overloading), (3) to wrap collections (return empty collection instead), (4) for primitive types (use OptionalInt/Long/Double), (5) when performance is critical (boxing overhead).</p>
                </div>
            </div>

            <div class="interview-question">
                <h4>Q5: What's the difference between map() and flatMap() in Optional?</h4>
                <div class="answer">
                    <p><code>map()</code> transforms the value inside Optional using a function that returns a plain value. <code>flatMap()</code> is used when the transformation function itself returns an Optionalâ€”it prevents nested Optional&lt;Optional&lt;T&gt;&gt;.</p>
                </div>
            </div>

            <div class="interview-question">
                <h4>Q6: How do you handle multiple Optionals in a chain?</h4>
                <div class="answer">
                    <p>Use flatMap() to chain through methods that return Optional, and map() for methods that return plain values. The or() method (Java 9+) provides fallback Optionals. For combining independent Optionals, consider using streams or explicit handling.</p>
                </div>
            </div>

            <div class="interview-question">
                <h4>Q7: Why is the isPresent() + get() pattern considered bad practice?</h4>
                <div class="answer">
                    <p>It defeats the purpose of Optionalâ€”it's essentially the same as null checking. It's verbose, doesn't leverage Optional's functional API, and makes it easy to accidentally call get() without the check. Use ifPresent(), orElse(), orElseGet(), or orElseThrow() instead.</p>
                </div>
            </div>
        </section>

        <!-- Best Practices -->
        <section class="content-section">
            <h2>Best Practices</h2>
            <ul class="best-practices">
                <li><strong>Use Optional for return types</strong> - When a method might not find/return a value</li>
                <li><strong>Never use get() directly</strong> - Always use orElse(), orElseGet(), orElseThrow(), or functional methods</li>
                <li><strong>Prefer orElseGet() over orElse()</strong> - When the default involves computation or side effects</li>
                <li><strong>Don't use Optional as fields</strong> - Store nullable values, return Optional from getters</li>
                <li><strong>Don't use Optional as parameters</strong> - Use method overloading or builders instead</li>
                <li><strong>Return empty collections, not Optional of collections</strong> - Collections already handle emptiness</li>
                <li><strong>Use flatMap() to avoid nested Optionals</strong> - When chaining methods that return Optional</li>
                <li><strong>Use OptionalInt/Long/Double for primitives</strong> - Avoid boxing overhead</li>
                <li><strong>Document when null vs Optional is intentional</strong> - Legacy code may still use null</li>
            </ul>
        </section>

        <!-- Why It Matters -->
        <section class="content-section">
            <h2>Why It Matters</h2>
            <ul>
                <li><strong>Eliminates NullPointerException</strong> - When used correctly, null never leaks through APIs</li>
                <li><strong>Self-documenting code</strong> - Return type explicitly signals possible absence</li>
                <li><strong>Cleaner code</strong> - Functional methods replace verbose null checks</li>
                <li><strong>Forces conscious handling</strong> - Can't ignore the possibility of missing values</li>
                <li><strong>Works with streams</strong> - Integrates naturally with Java's functional programming features</li>
                <li><strong>Industry standard</strong> - Expected pattern in modern Java codebases</li>
            </ul>
        </section>

        <!-- See Also -->
        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Optional.html">java.util.Optional (Oracle Docs)</a></li>
                <li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/OptionalInt.html">OptionalInt, OptionalLong, OptionalDouble</a></li>
                <li><strong>Article:</strong> "Tired of Null Pointer Exceptions?" by Brian Goetz (Oracle)</li>
                <li><strong>Book:</strong> "Modern Java in Action" - Chapter 11: Using Optional as a better alternative to null</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="lambda-streams.html" class="related-link">Lambda & Streams</a>
                <a href="exceptions.html" class="related-link">Exception Handling</a>
                <a href="collections.html" class="related-link">Collections Framework</a>
                <a href="generics.html" class="related-link">Generics</a>
                <a href="../advanced/design-patterns.html" class="related-link">Design Patterns</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
