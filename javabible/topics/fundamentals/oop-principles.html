<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OOP Principles - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / OOP Principles
            </nav>
            <h1>OOP Principles</h1>
            <p class="topic-subtitle">The Four Pillars of Object-Oriented Programming</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What is Object-Oriented Programming (OOP)?</h2>
            <p>Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around <strong>objects</strong>&mdash;entities that combine data (attributes) and behavior (methods) into cohesive units. Rather than thinking about programs as a sequence of instructions operating on data, OOP encourages us to model software as a collection of interacting objects, each responsible for its own state and behavior.</p>

            <p>The power of OOP lies in how closely it mirrors the way humans naturally think about the world. We instinctively categorize things (cars, animals, bank accounts), understand their properties (color, age, balance), and know what actions they can perform (drive, eat, withdraw). OOP allows us to translate this natural way of thinking directly into code, making programs more intuitive to design, understand, and maintain.</p>

            <p>Java was designed from the ground up as an object-oriented language, making OOP not just a feature but the fundamental way Java programs are structured. Everything in Java (except primitive types) is an object, and every Java program consists of at least one class. This deep integration means understanding OOP is essential for effective Java development&mdash;it's not optional knowledge but the foundation upon which all Java code is built.</p>

            <h3>Historical Context: The Evolution of OOP</h3>
            <p>The concepts underlying OOP emerged in the 1960s with Simula, a language designed for simulation that introduced the revolutionary ideas of classes and objects. These ideas were refined and expanded by Smalltalk in the 1970s, which coined the term "object-oriented programming" and introduced concepts like inheritance and dynamic dispatch that remain central to OOP today.</p>

            <p>When Java was created in the mid-1990s, its designers drew heavily from these predecessors while learning from the successes and mistakes of C++. Java struck a balance between OOP purity (everything is an object) and pragmatism (primitive types for performance), while adding features like interfaces for flexible abstraction and removing problematic features like multiple inheritance of implementation. The result was a language that made OOP accessible to mainstream developers while providing the structure needed for large-scale software development.</p>

            <h3>The Big Picture: How OOP Fits in the Java Ecosystem</h3>
            <p>OOP principles permeate every aspect of Java development. The Java Collections Framework uses inheritance and polymorphism to provide interchangeable data structures. The Java I/O system uses the Decorator pattern (built on inheritance) for flexible stream composition. Frameworks like Spring rely on interfaces and dependency injection (enabled by polymorphism) for loose coupling. Understanding OOP is prerequisite knowledge for effectively using virtually every Java library and framework.</p>

            <pre><code><span class="comment">/*
 * OOP in the Real World: How Java Applications Are Structured
 * ============================================================
 *
 *  ┌─────────────────────────────────────────────────────────────────────┐
 *  │                        Java Application                              │
 *  │                                                                      │
 *  │   ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐   │
 *  │   │  Domain Objects │   │   Services      │   │  Controllers    │   │
 *  │   │                 │   │                 │   │                 │   │
 *  │   │  - User         │   │  - UserService  │   │  - UserAPI      │   │
 *  │   │  - Order        │   │  - OrderService │   │  - OrderAPI     │   │
 *  │   │  - Product      │   │  - PaymentSvc   │   │  - PaymentAPI   │   │
 *  │   │                 │   │                 │   │                 │   │
 *  │   │ (Encapsulation) │   │ (Abstraction)   │   │ (Polymorphism)  │   │
 *  │   └────────┬────────┘   └────────┬────────┘   └────────┬────────┘   │
 *  │            │                     │                     │            │
 *  │            └─────────────────────┼─────────────────────┘            │
 *  │                                  │                                  │
 *  │                         (Inheritance)                               │
 *  │                    Common behaviors shared                          │
 *  │                    via base classes/interfaces                      │
 *  └─────────────────────────────────────────────────────────────────────┘
 */</span></code></pre>

            <h3>Real-World Analogy: Building with LEGO</h3>
            <p>Imagine you're building with LEGO blocks. Each block is an <strong>object</strong> that has properties (color, size, shape) and can connect to other blocks in specific ways. You can combine blocks into larger structures (composition), create specialized blocks based on generic ones (inheritance), and use blocks interchangeably when they share the same connection points (polymorphism). Object-Oriented Programming works the same way&mdash;we build programs using "objects" that represent real-world things.</p>

            <h3>A Concrete Example: Modeling a Car</h3>
            <p>Think about a car in the real world:</p>
            <ul>
                <li><strong>Properties (Data):</strong> color, brand, speed, fuel level</li>
                <li><strong>Behaviors (Methods):</strong> start(), accelerate(), brake(), refuel()</li>
            </ul>

            <p>In OOP, we create a "Car" class (a blueprint) that defines these properties and behaviors. Then we can create many car objects from that blueprint:</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Car</span> {
    <span class="comment">// Properties (what a car HAS) - encapsulated as private fields</span>
    <span class="keyword">private</span> <span class="class-name">String</span> color;
    <span class="keyword">private</span> <span class="class-name">String</span> brand;
    <span class="keyword">private</span> <span class="keyword">int</span> speed;
    <span class="keyword">private</span> <span class="keyword">double</span> fuelLevel;

    <span class="comment">// Constructor - how cars are created</span>
    <span class="keyword">public</span> <span class="function">Car</span>(<span class="class-name">String</span> color, <span class="class-name">String</span> brand) {
        <span class="keyword">this</span>.color = color;
        <span class="keyword">this</span>.brand = brand;
        <span class="keyword">this</span>.speed = <span class="number">0</span>;
        <span class="keyword">this</span>.fuelLevel = <span class="number">100.0</span>;
    }

    <span class="comment">// Behaviors (what a car DOES) - public methods</span>
    <span class="keyword">public void</span> <span class="function">accelerate</span>() {
        <span class="keyword">if</span> (fuelLevel > <span class="number">0</span>) {
            speed += <span class="number">10</span>;
            fuelLevel -= <span class="number">0.5</span>;
            <span class="class-name">System</span>.out.println(brand + <span class="string">" accelerating. Speed: "</span> + speed + <span class="string">" km/h"</span>);
        } <span class="keyword">else</span> {
            <span class="class-name">System</span>.out.println(<span class="string">"Out of fuel!"</span>);
        }
    }

    <span class="keyword">public void</span> <span class="function">brake</span>() {
        speed = <span class="class-name">Math</span>.max(<span class="number">0</span>, speed - <span class="number">10</span>);
        <span class="class-name">System</span>.out.println(brand + <span class="string">" braking. Speed: "</span> + speed + <span class="string">" km/h"</span>);
    }

    <span class="comment">// Getters provide controlled access to private data</span>
    <span class="keyword">public int</span> <span class="function">getSpeed</span>() { <span class="keyword">return</span> speed; }
    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getBrand</span>() { <span class="keyword">return</span> brand; }
}

<span class="comment">// Creating actual car objects from the blueprint</span>
<span class="class-name">Car</span> myCar = <span class="keyword">new</span> <span class="class-name">Car</span>(<span class="string">"red"</span>, <span class="string">"Toyota"</span>);
<span class="class-name">Car</span> yourCar = <span class="keyword">new</span> <span class="class-name">Car</span>(<span class="string">"blue"</span>, <span class="string">"Honda"</span>);

myCar.accelerate();   <span class="comment">// Toyota accelerating. Speed: 10 km/h</span>
yourCar.accelerate(); <span class="comment">// Honda accelerating. Speed: 10 km/h</span>
<span class="comment">// Each car has its own speed - they're independent objects</span></code></pre>

            <h3>Why Use OOP?</h3>
            <ul>
                <li><strong>Organized:</strong> Code is grouped logically (all car-related code in one place)</li>
                <li><strong>Reusable:</strong> Create many objects from one class (many cars from one Car blueprint)</li>
                <li><strong>Maintainable:</strong> Changes to a class are isolated; easy to find and fix problems</li>
                <li><strong>Extensible:</strong> New features can be added without breaking existing code</li>
                <li><strong>Mirrors Reality:</strong> Code structure matches how we think about the real world</li>
            </ul>

            <h2>The Four Pillars of OOP</h2>
            <p>OOP is built on four fundamental principles, often called the "four pillars." These aren't arbitrary rules but time-tested techniques that help us write better, more organized code:</p>

            <div class="info-box note">
                <div class="info-box-title">The Four Pillars - Simple Explanations</div>
                <ul>
                    <li><strong>1. Encapsulation</strong> - <em>"Hide the messy details"</em>
                        <br>Like a TV remote: you press buttons (simple interface), but you don't see the complex circuit board inside</li>
                    <li><strong>2. Inheritance</strong> - <em>"Build on what already exists"</em>
                        <br>Like how a sports car is still a car, but with extra features</li>
                    <li><strong>3. Polymorphism</strong> - <em>"Many forms, same action"</em>
                        <br>Like how both dogs and cats can "speak()", but dogs bark and cats meow</li>
                    <li><strong>4. Abstraction</strong> - <em>"Focus on what, not how"</em>
                        <br>Like knowing you can "send email" without knowing how the internet works</li>
                </ul>
            </div>

            <p>Let's explore each pillar in detail with practical examples...</p>
        </section>

        <section class="content-section">
            <h2>1. Encapsulation</h2>
            <p>Encapsulation is the practice of bundling data (fields) and methods that operate on that data within a single unit (class), and restricting direct access to some of the object's components. It's the most fundamental OOP principle&mdash;without encapsulation, objects would just be data containers, and OOP would offer little benefit over procedural programming.</p>

            <p>The key insight of encapsulation is that an object should <strong>control its own state</strong>. Rather than exposing internal data for external code to manipulate directly, an object provides methods that perform operations on its data, ensuring that the object always remains in a valid state.</p>

            <h3>The Problem Encapsulation Solves</h3>
            <pre><code><span class="comment">// ❌ BAD: Without encapsulation - data is exposed</span>
<span class="keyword">public class</span> <span class="class-name">BankAccountBad</span> {
    <span class="keyword">public</span> <span class="keyword">double</span> balance;  <span class="comment">// Anyone can access and modify!</span>
    <span class="keyword">public</span> <span class="class-name">String</span> accountNumber;
}

<span class="comment">// Problems this causes:</span>
<span class="class-name">BankAccountBad</span> account = <span class="keyword">new</span> <span class="class-name">BankAccountBad</span>();
account.balance = -<span class="number">1000000</span>;  <span class="comment">// Invalid state! Negative balance allowed</span>
account.balance = account.balance * <span class="number">100</span>;  <span class="comment">// Oops, multiplied instead of added</span>
account.accountNumber = <span class="keyword">null</span>;  <span class="comment">// Now the account has no number!</span>
<span class="comment">// No validation, no logging, no security - chaos!</span></code></pre>

            <h3>Code Example: Proper Encapsulation</h3>
            <pre><code><span class="comment">// ✅ GOOD: With encapsulation - data is protected</span>
<span class="keyword">public class</span> <span class="class-name">BankAccount</span> {
    <span class="comment">// Private fields - encapsulated data</span>
    <span class="keyword">private final</span> <span class="class-name">String</span> accountNumber;  <span class="comment">// Cannot change once set</span>
    <span class="keyword">private</span> <span class="keyword">double</span> balance;
    <span class="keyword">private final</span> <span class="class-name">String</span> owner;
    <span class="keyword">private final</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; transactionHistory;

    <span class="comment">// Constructor - controlled initialization</span>
    <span class="keyword">public</span> <span class="function">BankAccount</span>(<span class="class-name">String</span> accountNumber, <span class="class-name">String</span> owner) {
        <span class="keyword">if</span> (accountNumber == <span class="keyword">null</span> || accountNumber.length() != <span class="number">10</span>) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Invalid account number"</span>);
        }
        <span class="keyword">this</span>.accountNumber = accountNumber;
        <span class="keyword">this</span>.owner = owner;
        <span class="keyword">this</span>.balance = <span class="number">0.0</span>;
        <span class="keyword">this</span>.transactionHistory = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
    }

    <span class="comment">// Getter methods - controlled read access</span>
    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getAccountNumber</span>() {
        <span class="keyword">return</span> accountNumber;
    }

    <span class="keyword">public</span> <span class="keyword">double</span> <span class="function">getBalance</span>() {
        <span class="keyword">return</span> balance;
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getOwner</span>() {
        <span class="keyword">return</span> owner;
    }

    <span class="comment">// Defensive copy - protect internal collection</span>
    <span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getTransactionHistory</span>() {
        <span class="keyword">return new</span> <span class="class-name">ArrayList</span>&lt;&gt;(transactionHistory);  <span class="comment">// Return copy!</span>
    }

    <span class="comment">// Controlled methods with validation</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">deposit</span>(<span class="keyword">double</span> amount) {
        <span class="keyword">if</span> (amount <= <span class="number">0</span>) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Deposit amount must be positive"</span>);
        }
        balance += amount;
        logTransaction(<span class="string">"DEPOSIT"</span>, amount);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">withdraw</span>(<span class="keyword">double</span> amount) {
        <span class="keyword">if</span> (amount <= <span class="number">0</span>) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Withdrawal amount must be positive"</span>);
        }
        <span class="keyword">if</span> (amount > balance) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalStateException</span>(<span class="string">"Insufficient funds"</span>);
        }
        balance -= amount;
        logTransaction(<span class="string">"WITHDRAWAL"</span>, amount);
    }

    <span class="comment">// Private helper - internal implementation detail</span>
    <span class="keyword">private void</span> <span class="function">logTransaction</span>(<span class="class-name">String</span> type, <span class="keyword">double</span> amount) {
        <span class="class-name">String</span> entry = <span class="class-name">String</span>.format(<span class="string">"%s: $%.2f | Balance: $%.2f"</span>, type, amount, balance);
        transactionHistory.add(entry);
    }
}

<span class="comment">// Usage - the object controls its own state</span>
<span class="class-name">BankAccount</span> account = <span class="keyword">new</span> <span class="class-name">BankAccount</span>(<span class="string">"1234567890"</span>, <span class="string">"Alice"</span>);
account.deposit(<span class="number">1000</span>);     <span class="comment">// ✅ Validated and logged</span>
account.withdraw(<span class="number">500</span>);    <span class="comment">// ✅ Validated and logged</span>
<span class="comment">// account.balance = -1000;  // ❌ Won't compile - balance is private</span>
<span class="comment">// account.withdraw(10000);  // ❌ Throws exception - insufficient funds</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Encapsulation Benefits</div>
                <ul>
                    <li><strong>Data Integrity:</strong> Object always remains in a valid state</li>
                    <li><strong>Flexibility:</strong> Internal implementation can change without affecting external code</li>
                    <li><strong>Security:</strong> Sensitive data protected from unauthorized access</li>
                    <li><strong>Debugging:</strong> All modifications go through controlled methods (easier to track)</li>
                    <li><strong>Maintainability:</strong> Changes isolated to one place</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>2. Inheritance</h2>
            <p>Inheritance allows a class to inherit properties and methods from another class, creating a parent-child (or superclass-subclass) relationship. This promotes code reuse and establishes an "is-a" relationship between classes&mdash;a Dog <em>is an</em> Animal, a SportsCar <em>is a</em> Car.</p>

            <p>Inheritance models the hierarchical relationships we see in the real world. Just as biological taxonomy organizes living things into hierarchies (Animal &rarr; Mammal &rarr; Dog &rarr; Labrador), class inheritance organizes code into hierarchies where more specific classes inherit from more general ones.</p>

            <h3>Understanding the "is-a" Relationship</h3>
            <pre><code><span class="comment">/*
 * Inheritance Hierarchy
 * =====================
 *
 *                    ┌─────────────┐
 *                    │   Animal    │  ← Base class (most general)
 *                    │  - name     │
 *                    │  - eat()    │
 *                    │  - sleep()  │
 *                    └──────┬──────┘
 *                           │
 *           ┌───────────────┼───────────────┐
 *           │               │               │
 *    ┌──────┴──────┐ ┌──────┴──────┐ ┌──────┴──────┐
 *    │    Dog      │ │    Cat      │ │    Bird     │
 *    │  - breed    │ │  - indoor   │ │  - wingspan │
 *    │  - bark()   │ │  - meow()   │ │  - fly()    │
 *    └──────┬──────┘ └─────────────┘ └─────────────┘
 *           │
 *    ┌──────┴──────┐
 *    │  Labrador   │  ← Most specific
 *    │  - fetch()  │
 *    └─────────────┘
 *
 *  Each subclass IS-A type of its parent:
 *  - Labrador is-a Dog is-a Animal
 *  - Cat is-a Animal
 */</span></code></pre>

            <h3>Code Example</h3>
            <pre><code><span class="comment">// Parent class (superclass)</span>
<span class="keyword">public class</span> <span class="class-name">Animal</span> {
    <span class="keyword">protected</span> <span class="class-name">String</span> name;
    <span class="keyword">protected</span> <span class="keyword">int</span> age;

    <span class="keyword">public</span> <span class="function">Animal</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">eat</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is eating"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">sleep</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is sleeping"</span>);
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getName</span>() {
        <span class="keyword">return</span> name;
    }
}

<span class="comment">// Child class (subclass) - inherits from Animal</span>
<span class="keyword">public class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> breed;

    <span class="keyword">public</span> <span class="function">Dog</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age, <span class="class-name">String</span> breed) {
        <span class="keyword">super</span>(name, age);  <span class="comment">// Call parent constructor FIRST</span>
        <span class="keyword">this</span>.breed = breed;
    }

    <span class="comment">// Additional method specific to Dog</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">bark</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" says: Woof! Woof!"</span>);
    }

    <span class="comment">// Override parent method to provide specialized behavior</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">eat</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" the "</span> + breed + <span class="string">" is eating dog food"</span>);
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getBreed</span>() {
        <span class="keyword">return</span> breed;
    }
}

<span class="comment">// More specific subclass</span>
<span class="keyword">public class</span> <span class="class-name">Labrador</span> <span class="keyword">extends</span> <span class="class-name">Dog</span> {
    <span class="keyword">public</span> <span class="function">Labrador</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
        <span class="keyword">super</span>(name, age, <span class="string">"Labrador"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">fetch</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" fetches the ball!"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">bark</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" says: WOOF! (Labs are loud)"</span>);
    }
}

<span class="comment">// Usage</span>
<span class="class-name">Dog</span> dog = <span class="keyword">new</span> <span class="class-name">Dog</span>(<span class="string">"Buddy"</span>, <span class="number">3</span>, <span class="string">"Golden Retriever"</span>);
dog.eat();    <span class="comment">// Uses overridden method: "Buddy the Golden Retriever is eating dog food"</span>
dog.bark();   <span class="comment">// Dog-specific method: "Buddy says: Woof! Woof!"</span>
dog.sleep();  <span class="comment">// Inherited method: "Buddy is sleeping"</span>

<span class="class-name">Labrador</span> lab = <span class="keyword">new</span> <span class="class-name">Labrador</span>(<span class="string">"Max"</span>, <span class="number">2</span>);
lab.fetch();  <span class="comment">// Labrador-specific: "Max fetches the ball!"</span>
lab.bark();   <span class="comment">// Overridden: "Max says: WOOF! (Labs are loud)"</span>
lab.eat();    <span class="comment">// Inherited from Dog: "Max the Labrador is eating dog food"</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Inheritance Caution: Favor Composition Over Inheritance</div>
                <p>While inheritance is powerful, it creates tight coupling between classes. The "is-a" relationship should be genuine and permanent. If you're unsure, consider <strong>composition</strong> ("has-a" relationship) instead:</p>
                <pre><code><span class="comment">// ❌ Problematic inheritance - a Stack is not really a List</span>
<span class="keyword">public class</span> <span class="class-name">Stack</span> <span class="keyword">extends</span> <span class="class-name">ArrayList</span> { ... }  <span class="comment">// Exposes unwanted List methods!</span>

<span class="comment">// ✅ Better: Composition - Stack uses a List internally</span>
<span class="keyword">public class</span> <span class="class-name">Stack</span>&lt;<span class="class-name">T</span>&gt; {
    <span class="keyword">private</span> <span class="class-name">List</span>&lt;<span class="class-name">T</span>&gt; elements = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();  <span class="comment">// has-a List</span>

    <span class="keyword">public void</span> <span class="function">push</span>(<span class="class-name">T</span> item) { elements.add(item); }
    <span class="keyword">public</span> <span class="class-name">T</span> <span class="function">pop</span>() { <span class="keyword">return</span> elements.remove(elements.size() - <span class="number">1</span>); }
}</code></pre>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Key Inheritance Rules in Java</div>
                <ul>
                    <li>Java supports only <strong>single inheritance</strong> (one parent class)</li>
                    <li>Use <code>extends</code> keyword to inherit</li>
                    <li>Use <code>super</code> to access parent members</li>
                    <li>Constructor chaining: subclass constructor must call superclass constructor</li>
                    <li>All classes implicitly extend <code>Object</code> if no parent specified</li>
                    <li>Use interfaces for multiple inheritance of type</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>3. Polymorphism</h2>
            <p>Polymorphism means "many forms." It allows objects of different classes to be treated as objects of a common parent class, with each responding to the same method call in its own way. This is perhaps OOP's most powerful feature&mdash;it enables writing flexible, extensible code that works with objects based on <em>what they can do</em> rather than <em>what they are</em>.</p>

            <p>Polymorphism comes in two forms in Java:</p>
            <ul>
                <li><strong>Compile-time (Static) Polymorphism:</strong> Method overloading - same method name, different parameters</li>
                <li><strong>Runtime (Dynamic) Polymorphism:</strong> Method overriding - subclass provides specific implementation</li>
            </ul>

            <h3>Runtime Polymorphism in Action</h3>
            <pre><code><span class="keyword">public abstract class</span> <span class="class-name">Shape</span> {
    <span class="keyword">protected</span> <span class="class-name">String</span> color;

    <span class="keyword">public</span> <span class="function">Shape</span>(<span class="class-name">String</span> color) {
        <span class="keyword">this</span>.color = color;
    }

    <span class="comment">// Abstract method - each shape calculates area differently</span>
    <span class="keyword">public abstract double</span> <span class="function">calculateArea</span>();

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="function">displayInfo</span>() {
        <span class="class-name">System</span>.out.println(color + <span class="string">" shape with area: "</span> + calculateArea());
    }
}

<span class="keyword">public class</span> <span class="class-name">Circle</span> <span class="keyword">extends</span> <span class="class-name">Shape</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> radius;

    <span class="keyword">public</span> <span class="function">Circle</span>(<span class="class-name">String</span> color, <span class="keyword">double</span> radius) {
        <span class="keyword">super</span>(color);
        <span class="keyword">this</span>.radius = radius;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public double</span> <span class="function">calculateArea</span>() {
        <span class="keyword">return</span> <span class="class-name">Math</span>.PI * radius * radius;
    }
}

<span class="keyword">public class</span> <span class="class-name">Rectangle</span> <span class="keyword">extends</span> <span class="class-name">Shape</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> width, height;

    <span class="keyword">public</span> <span class="function">Rectangle</span>(<span class="class-name">String</span> color, <span class="keyword">double</span> width, <span class="keyword">double</span> height) {
        <span class="keyword">super</span>(color);
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public double</span> <span class="function">calculateArea</span>() {
        <span class="keyword">return</span> width * height;
    }
}

<span class="keyword">public class</span> <span class="class-name">Triangle</span> <span class="keyword">extends</span> <span class="class-name">Shape</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> base, height;

    <span class="keyword">public</span> <span class="function">Triangle</span>(<span class="class-name">String</span> color, <span class="keyword">double</span> base, <span class="keyword">double</span> height) {
        <span class="keyword">super</span>(color);
        <span class="keyword">this</span>.base = base;
        <span class="keyword">this</span>.height = height;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public double</span> <span class="function">calculateArea</span>() {
        <span class="keyword">return</span> <span class="number">0.5</span> * base * height;
    }
}

<span class="comment">// THE POWER OF POLYMORPHISM:</span>
<span class="comment">// One method works with ANY shape - present or FUTURE!</span>
<span class="keyword">public class</span> <span class="class-name">ShapeCalculator</span> {

    <span class="comment">// This method works with Circle, Rectangle, Triangle, and any</span>
    <span class="comment">// future Shape subclass without modification!</span>
    <span class="keyword">public static double</span> <span class="function">calculateTotalArea</span>(<span class="class-name">List</span>&lt;<span class="class-name">Shape</span>&gt; shapes) {
        <span class="keyword">double</span> total = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="class-name">Shape</span> shape : shapes) {
            total += shape.calculateArea();  <span class="comment">// Calls the RIGHT method at runtime</span>
        }
        <span class="keyword">return</span> total;
    }

    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="class-name">List</span>&lt;<span class="class-name">Shape</span>&gt; shapes = <span class="class-name">Arrays</span>.asList(
            <span class="keyword">new</span> <span class="class-name">Circle</span>(<span class="string">"Red"</span>, <span class="number">5.0</span>),
            <span class="keyword">new</span> <span class="class-name">Rectangle</span>(<span class="string">"Blue"</span>, <span class="number">4.0</span>, <span class="number">6.0</span>),
            <span class="keyword">new</span> <span class="class-name">Triangle</span>(<span class="string">"Green"</span>, <span class="number">3.0</span>, <span class="number">4.0</span>)
        );

        <span class="comment">// Each shape calculates its area using ITS OWN formula</span>
        <span class="keyword">for</span> (<span class="class-name">Shape</span> shape : shapes) {
            shape.displayInfo();
        }
        <span class="comment">// Output:</span>
        <span class="comment">// Red shape with area: 78.54...</span>
        <span class="comment">// Blue shape with area: 24.0</span>
        <span class="comment">// Green shape with area: 6.0</span>

        <span class="class-name">System</span>.out.println(<span class="string">"Total area: "</span> + calculateTotalArea(shapes));
    }
}</code></pre>

            <h3>Compile-Time Polymorphism (Method Overloading)</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Calculator</span> {
    <span class="comment">// Same method name, different parameters</span>
    <span class="keyword">public int</span> <span class="function">add</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
        <span class="keyword">return</span> a + b;
    }

    <span class="keyword">public double</span> <span class="function">add</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b) {
        <span class="keyword">return</span> a + b;
    }

    <span class="keyword">public int</span> <span class="function">add</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) {
        <span class="keyword">return</span> a + b + c;
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">add</span>(<span class="class-name">String</span> a, <span class="class-name">String</span> b) {
        <span class="keyword">return</span> a + b;  <span class="comment">// String concatenation</span>
    }
}

<span class="class-name">Calculator</span> calc = <span class="keyword">new</span> <span class="class-name">Calculator</span>();
calc.add(<span class="number">5</span>, <span class="number">10</span>);           <span class="comment">// Calls int version: 15</span>
calc.add(<span class="number">3.14</span>, <span class="number">2.86</span>);      <span class="comment">// Calls double version: 6.0</span>
calc.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);         <span class="comment">// Calls three-param version: 6</span>
calc.add(<span class="string">"Hello"</span>, <span class="string">"World"</span>); <span class="comment">// Calls String version: "HelloWorld"</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Real-World Use Case: Plugin Architecture</div>
                <p>Polymorphism enables plugin architectures where new functionality can be added without modifying existing code:</p>
                <pre><code><span class="keyword">public interface</span> <span class="class-name">PaymentProcessor</span> {
    <span class="keyword">void</span> <span class="function">processPayment</span>(<span class="keyword">double</span> amount);
}

<span class="comment">// Existing processors</span>
<span class="keyword">public class</span> <span class="class-name">CreditCardProcessor</span> <span class="keyword">implements</span> <span class="class-name">PaymentProcessor</span> { ... }
<span class="keyword">public class</span> <span class="class-name">PayPalProcessor</span> <span class="keyword">implements</span> <span class="class-name">PaymentProcessor</span> { ... }

<span class="comment">// Add new payment method WITHOUT changing PaymentService!</span>
<span class="keyword">public class</span> <span class="class-name">CryptoProcessor</span> <span class="keyword">implements</span> <span class="class-name">PaymentProcessor</span> { ... }

<span class="keyword">public class</span> <span class="class-name">PaymentService</span> {
    <span class="keyword">public void</span> <span class="function">pay</span>(<span class="class-name">PaymentProcessor</span> processor, <span class="keyword">double</span> amount) {
        processor.processPayment(amount);  <span class="comment">// Works with ANY processor</span>
    }
}</code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>4. Abstraction</h2>
            <p>Abstraction means hiding complex implementation details and showing only the essential features. It focuses on <strong>WHAT</strong> an object does rather than <strong>HOW</strong> it does it. While encapsulation hides data, abstraction hides complexity.</p>

            <p>Think about driving a car: you interact with a simple interface (steering wheel, pedals, gear shift) without needing to understand the complex mechanics underneath. The car <em>abstracts</em> away the complexity of internal combustion, transmission systems, and electronic controls.</p>

            <h3>Abstraction in Java</h3>
            <p>Java provides two mechanisms for abstraction:</p>
            <ul>
                <li><strong>Abstract Classes:</strong> Partially implemented classes that define a template</li>
                <li><strong>Interfaces:</strong> Fully abstract contracts that define capabilities</li>
            </ul>

            <h3>Code Example: Payment Processing System</h3>
            <pre><code><span class="comment">// Abstract class provides template with some implementation</span>
<span class="keyword">public abstract class</span> <span class="class-name">Payment</span> {
    <span class="keyword">protected</span> <span class="keyword">double</span> amount;
    <span class="keyword">protected</span> <span class="class-name">String</span> transactionId;
    <span class="keyword">protected</span> <span class="class-name">LocalDateTime</span> timestamp;

    <span class="keyword">public</span> <span class="function">Payment</span>(<span class="keyword">double</span> amount) {
        <span class="keyword">this</span>.amount = amount;
        <span class="keyword">this</span>.transactionId = generateTransactionId();
        <span class="keyword">this</span>.timestamp = <span class="class-name">LocalDateTime</span>.now();
    }

    <span class="comment">// Abstract methods - MUST be implemented by subclasses</span>
    <span class="comment">// These define WHAT must happen, not HOW</span>
    <span class="keyword">public abstract boolean</span> <span class="function">validate</span>();
    <span class="keyword">public abstract void</span> <span class="function">executePayment</span>();
    <span class="keyword">public abstract void</span> <span class="function">sendConfirmation</span>();

    <span class="comment">// Concrete method - shared implementation</span>
    <span class="keyword">public final void</span> <span class="function">process</span>() {
        <span class="comment">// Template Method Pattern: defines the algorithm structure</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Starting payment processing..."</span>);
        <span class="keyword">if</span> (validate()) {
            executePayment();
            sendConfirmation();
            printReceipt();
        } <span class="keyword">else</span> {
            <span class="class-name">System</span>.out.println(<span class="string">"Payment validation failed"</span>);
        }
    }

    <span class="keyword">protected void</span> <span class="function">printReceipt</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Receipt:"</span>);
        <span class="class-name">System</span>.out.println(<span class="string">"  Transaction ID: "</span> + transactionId);
        <span class="class-name">System</span>.out.println(<span class="string">"  Amount: $"</span> + amount);
        <span class="class-name">System</span>.out.println(<span class="string">"  Time: "</span> + timestamp);
    }

    <span class="keyword">private</span> <span class="class-name">String</span> <span class="function">generateTransactionId</span>() {
        <span class="keyword">return</span> <span class="string">"TXN-"</span> + <span class="class-name">System</span>.currentTimeMillis();
    }
}

<span class="comment">// Concrete implementation - provides the HOW</span>
<span class="keyword">public class</span> <span class="class-name">CreditCardPayment</span> <span class="keyword">extends</span> <span class="class-name">Payment</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> cardNumber;
    <span class="keyword">private</span> <span class="class-name">String</span> cvv;
    <span class="keyword">private</span> <span class="class-name">String</span> expiryDate;

    <span class="keyword">public</span> <span class="function">CreditCardPayment</span>(<span class="keyword">double</span> amount, <span class="class-name">String</span> cardNumber,
                            <span class="class-name">String</span> cvv, <span class="class-name">String</span> expiryDate) {
        <span class="keyword">super</span>(amount);
        <span class="keyword">this</span>.cardNumber = cardNumber;
        <span class="keyword">this</span>.cvv = cvv;
        <span class="keyword">this</span>.expiryDate = expiryDate;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public boolean</span> <span class="function">validate</span>() {
        <span class="comment">// Credit card specific validation</span>
        <span class="keyword">return</span> cardNumber != <span class="keyword">null</span>
            && cardNumber.length() == <span class="number">16</span>
            && cvv.length() == <span class="number">3</span>
            && !isExpired();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">executePayment</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Charging credit card ending in "</span>
            + cardNumber.substring(<span class="number">12</span>) + <span class="string">" for $"</span> + amount);
        <span class="comment">// Connect to payment gateway, process charge, etc.</span>
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">sendConfirmation</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Sending email confirmation for credit card payment"</span>);
    }

    <span class="keyword">private boolean</span> <span class="function">isExpired</span>() {
        <span class="comment">// Check if card is expired</span>
        <span class="keyword">return false</span>;
    }
}

<span class="comment">// Another concrete implementation</span>
<span class="keyword">public class</span> <span class="class-name">PayPalPayment</span> <span class="keyword">extends</span> <span class="class-name">Payment</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> email;
    <span class="keyword">private</span> <span class="class-name">String</span> authToken;

    <span class="keyword">public</span> <span class="function">PayPalPayment</span>(<span class="keyword">double</span> amount, <span class="class-name">String</span> email) {
        <span class="keyword">super</span>(amount);
        <span class="keyword">this</span>.email = email;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public boolean</span> <span class="function">validate</span>() {
        <span class="comment">// PayPal specific validation</span>
        <span class="keyword">return</span> email != <span class="keyword">null</span> && email.contains(<span class="string">"@"</span>) && authenticateUser();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">executePayment</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Processing PayPal payment for "</span> + email);
        <span class="comment">// Connect to PayPal API, authorize, transfer funds</span>
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">sendConfirmation</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Sending PayPal notification to "</span> + email);
    }

    <span class="keyword">private boolean</span> <span class="function">authenticateUser</span>() {
        <span class="comment">// OAuth authentication with PayPal</span>
        <span class="keyword">return true</span>;
    }
}

<span class="comment">// Usage - client code doesn't need to know implementation details</span>
<span class="keyword">public class</span> <span class="class-name">PaymentDemo</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="comment">// Process ANY payment type with the same code</span>
        <span class="class-name">Payment</span> payment1 = <span class="keyword">new</span> <span class="class-name">CreditCardPayment</span>(<span class="number">99.99</span>, <span class="string">"1234567890123456"</span>, <span class="string">"123"</span>, <span class="string">"12/25"</span>);
        <span class="class-name">Payment</span> payment2 = <span class="keyword">new</span> <span class="class-name">PayPalPayment</span>(<span class="number">49.99</span>, <span class="string">"user@example.com"</span>);

        payment1.process();  <span class="comment">// Uses credit card implementation</span>
        payment2.process();  <span class="comment">// Uses PayPal implementation</span>
    }
}</code></pre>

            <div class="info-box note">
                <div class="info-box-title">Abstract Class vs Interface</div>
                <table>
                    <tr>
                        <th>Use Abstract Class When</th>
                        <th>Use Interface When</th>
                    </tr>
                    <tr>
                        <td>You need to share code among related classes</td>
                        <td>Unrelated classes need same capability</td>
                    </tr>
                    <tr>
                        <td>You need constructors or instance fields</td>
                        <td>You want multiple inheritance of type</td>
                    </tr>
                    <tr>
                        <td>You want to provide default implementations</td>
                        <td>You want to define a contract only</td>
                    </tr>
                    <tr>
                        <td>Example: Animal, Vehicle, Payment</td>
                        <td>Example: Comparable, Serializable, Runnable</td>
                    </tr>
                </table>
                <p><em>See <a href="interfaces-abstract.html">Interfaces vs Abstract Classes</a> for detailed comparison.</em></p>
            </div>
        </section>

        <section class="content-section">
            <h2>Under the Hood: How OOP Works in the JVM</h2>
            <p>Understanding how the JVM implements OOP concepts helps you write better code and debug issues more effectively.</p>

            <h3>Method Dispatch: How Polymorphism Works</h3>
            <pre><code><span class="comment">/*
 * Virtual Method Table (vtable)
 * =============================
 *
 * Each class has a vtable - a table of pointers to method implementations.
 * When you call a method on an object, the JVM:
 * 1. Looks at the object's actual class (not the reference type)
 * 2. Finds the method in that class's vtable
 * 3. Calls the correct implementation
 *
 *  Shape shape = new Circle();
 *  shape.calculateArea();  // Which method is called?
 *
 *  Step 1: shape refers to a Circle object
 *  Step 2: JVM looks in Circle's vtable for calculateArea
 *  Step 3: Finds Circle's override, calls it
 *
 *  ┌─────────────────────────────┐
 *  │ Circle instance (on heap)  │
 *  │  - class pointer ──────────┼───► Circle.class vtable:
 *  │  - radius: 5.0             │      calculateArea() ─► Circle's impl
 *  │  - color: "Red"            │      displayInfo()   ─► Shape's impl
 *  └─────────────────────────────┘
 */</span>

<span class="comment">// This is why the "real" type matters, not the reference type:</span>
<span class="class-name">Shape</span> shape = <span class="keyword">new</span> <span class="class-name">Circle</span>(<span class="string">"Red"</span>, <span class="number">5.0</span>);  <span class="comment">// Reference type: Shape, Object type: Circle</span>
shape.calculateArea();  <span class="comment">// Calls Circle's version (runtime polymorphism)</span></code></pre>

            <h3>Object Memory Layout</h3>
            <pre><code><span class="comment">/*
 * Object Layout in Memory
 * =======================
 *
 *  Dog dog = new Dog("Buddy", 3, "Labrador");
 *
 *  ┌──────────────────────────────────────────┐
 *  │             Dog Object (Heap)            │
 *  ├──────────────────────────────────────────┤
 *  │ Object Header (12-16 bytes)              │
 *  │  - Mark word (hashCode, locks, GC info)  │
 *  │  - Class pointer → Dog.class             │
 *  ├──────────────────────────────────────────┤
 *  │ Animal fields (inherited)                │
 *  │  - name: "Buddy" (reference to String)   │
 *  │  - age: 3 (int, 4 bytes)                 │
 *  ├──────────────────────────────────────────┤
 *  │ Dog fields (this class)                  │
 *  │  - breed: "Labrador" (reference)         │
 *  └──────────────────────────────────────────┘
 *
 *  Inheritance = fields are laid out in order from parent to child
 */</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Best Practices</h2>

            <h3>Encapsulation Best Practices</h3>
            <ul>
                <li><strong>Make fields private</strong> - Always. No exceptions.</li>
                <li><strong>Provide getters only when needed</strong> - Don't auto-generate for everything</li>
                <li><strong>Be cautious with setters</strong> - Consider immutability; use builders or factory methods</li>
                <li><strong>Return defensive copies</strong> - For mutable objects like collections, dates</li>
                <li><strong>Validate in setters/constructors</strong> - Never allow invalid state</li>
            </ul>

            <h3>Inheritance Best Practices</h3>
            <ul>
                <li><strong>Favor composition over inheritance</strong> - Use "has-a" when "is-a" isn't genuine</li>
                <li><strong>Keep hierarchies shallow</strong> - 2-3 levels maximum</li>
                <li><strong>Use <code>final</code> to prevent inheritance</strong> - When a class shouldn't be extended</li>
                <li><strong>Document for inheritance or prohibit it</strong> - Design explicitly for extension</li>
                <li><strong>Don't inherit for code reuse alone</strong> - The relationship must make semantic sense</li>
            </ul>

            <h3>Polymorphism Best Practices</h3>
            <ul>
                <li><strong>Program to interfaces, not implementations</strong> - Use abstract types in declarations</li>
                <li><strong>Follow Liskov Substitution Principle</strong> - Subtypes must be substitutable for base types</li>
                <li><strong>Use <code>@Override</code> annotation</strong> - Compiler catches mistakes</li>
                <li><strong>Avoid type checking with instanceof</strong> - Usually indicates design problem</li>
            </ul>

            <h3>Abstraction Best Practices</h3>
            <ul>
                <li><strong>Keep interfaces small and focused</strong> - Single responsibility</li>
                <li><strong>Use abstract classes for template patterns</strong> - When sharing implementation</li>
                <li><strong>Don't leak implementation details</strong> - Interface should describe capability</li>
                <li><strong>Design contracts carefully</strong> - Once published, hard to change</li>
            </ul>

            <pre><code><span class="comment">// ✅ GOOD: Programming to interfaces</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; names = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();  <span class="comment">// Can switch to LinkedList easily</span>
<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; scores = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();

<span class="comment">// ❌ BAD: Programming to implementations</span>
<span class="class-name">ArrayList</span>&lt;<span class="class-name">String</span>&gt; names = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();  <span class="comment">// Locked into ArrayList</span>

<span class="comment">// ✅ GOOD: Method accepts interface type</span>
<span class="keyword">public void</span> <span class="function">processItems</span>(<span class="class-name">Collection</span>&lt;<span class="class-name">Item</span>&gt; items) { ... }

<span class="comment">// ❌ BAD: Method accepts concrete type</span>
<span class="keyword">public void</span> <span class="function">processItems</span>(<span class="class-name">ArrayList</span>&lt;<span class="class-name">Item</span>&gt; items) { ... }</code></pre>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Over-Engineering with Inheritance</div>
                <pre><code><span class="comment">// ❌ BAD: Unnecessary deep hierarchy</span>
<span class="keyword">class</span> <span class="class-name">LivingThing</span> { }
<span class="keyword">class</span> <span class="class-name">Animal</span> <span class="keyword">extends</span> <span class="class-name">LivingThing</span> { }
<span class="keyword">class</span> <span class="class-name">Mammal</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> { }
<span class="keyword">class</span> <span class="class-name">Canine</span> <span class="keyword">extends</span> <span class="class-name">Mammal</span> { }
<span class="keyword">class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Canine</span> { }
<span class="keyword">class</span> <span class="class-name">Labrador</span> <span class="keyword">extends</span> <span class="class-name">Dog</span> { }  <span class="comment">// 6 levels deep!</span>

<span class="comment">// ✅ BETTER: Flatter hierarchy with composition</span>
<span class="keyword">class</span> <span class="class-name">Dog</span> {
    <span class="keyword">private</span> <span class="class-name">Breed</span> breed;  <span class="comment">// Composition</span>
    <span class="keyword">private</span> <span class="class-name">BehaviorSet</span> behaviors;  <span class="comment">// Composition</span>
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Breaking Encapsulation</div>
                <pre><code><span class="comment">// ❌ BAD: Exposing mutable internal state</span>
<span class="keyword">public class</span> <span class="class-name">Team</span> {
    <span class="keyword">private</span> <span class="class-name">List</span>&lt;<span class="class-name">Player</span>&gt; players = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();

    <span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">Player</span>&gt; <span class="function">getPlayers</span>() {
        <span class="keyword">return</span> players;  <span class="comment">// Caller can modify!</span>
    }
}
team.getPlayers().clear();  <span class="comment">// Oops! Destroyed the team</span>

<span class="comment">// ✅ GOOD: Return defensive copy or unmodifiable view</span>
<span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">Player</span>&gt; <span class="function">getPlayers</span>() {
    <span class="keyword">return</span> <span class="class-name">Collections</span>.unmodifiableList(players);
    <span class="comment">// OR: return new ArrayList&lt;&gt;(players);</span>
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Violating Liskov Substitution Principle</div>
                <pre><code><span class="comment">// ❌ BAD: Square "is-a" Rectangle? Not really...</span>
<span class="keyword">class</span> <span class="class-name">Rectangle</span> {
    <span class="keyword">protected int</span> width, height;

    <span class="keyword">public void</span> <span class="function">setWidth</span>(<span class="keyword">int</span> w) { width = w; }
    <span class="keyword">public void</span> <span class="function">setHeight</span>(<span class="keyword">int</span> h) { height = h; }
    <span class="keyword">public int</span> <span class="function">getArea</span>() { <span class="keyword">return</span> width * height; }
}

<span class="keyword">class</span> <span class="class-name">Square</span> <span class="keyword">extends</span> <span class="class-name">Rectangle</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">setWidth</span>(<span class="keyword">int</span> w) {
        width = w;
        height = w;  <span class="comment">// Must keep square!</span>
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">setHeight</span>(<span class="keyword">int</span> h) {
        width = h;
        height = h;
    }
}

<span class="comment">// This breaks expectations:</span>
<span class="class-name">Rectangle</span> r = <span class="keyword">new</span> <span class="class-name">Square</span>();
r.setWidth(<span class="number">5</span>);
r.setHeight(<span class="number">10</span>);
<span class="class-name">System</span>.out.println(r.getArea());  <span class="comment">// Expects 50, gets 100!</span>

<span class="comment">// ✅ BETTER: Don't use inheritance here</span>
<span class="keyword">interface</span> <span class="class-name">Shape</span> { <span class="keyword">int</span> <span class="function">getArea</span>(); }
<span class="keyword">class</span> <span class="class-name">Rectangle</span> <span class="keyword">implements</span> <span class="class-name">Shape</span> { ... }
<span class="keyword">class</span> <span class="class-name">Square</span> <span class="keyword">implements</span> <span class="class-name">Shape</span> { ... }  <span class="comment">// Independent implementations</span></code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 4: Forgetting @Override</div>
                <pre><code><span class="comment">// ❌ BAD: Typo creates new method instead of overriding</span>
<span class="keyword">class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">public void</span> <span class="function">eats</span>() {  <span class="comment">// Typo! Should be eat()</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Dog eating"</span>);
    }
}
<span class="class-name">Animal</span> dog = <span class="keyword">new</span> <span class="class-name">Dog</span>();
dog.eat();  <span class="comment">// Calls Animal.eat(), not our "override"!</span>

<span class="comment">// ✅ GOOD: @Override catches the mistake at compile time</span>
<span class="keyword">class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="annotation">@Override</span>  <span class="comment">// Compiler error: method does not override</span>
    <span class="keyword">public void</span> <span class="function">eats</span>() { ... }
}</code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Performance Considerations</h2>

            <div class="info-box note">
                <div class="info-box-title">OOP and Performance</div>
                <p>OOP adds minimal overhead in modern JVMs:</p>
                <ul>
                    <li><strong>Virtual method calls:</strong> ~1 nanosecond overhead (negligible in most cases)</li>
                    <li><strong>Object creation:</strong> Optimized by JVM; ~10 nanoseconds for small objects</li>
                    <li><strong>Inheritance depth:</strong> No runtime cost; field offsets calculated at class loading</li>
                </ul>
                <p>Focus on good design first. Optimize only when profiling shows a bottleneck.</p>
            </div>

            <pre><code><span class="comment">// Performance myths debunked:</span>

<span class="comment">// MYTH: "Deep inheritance is slow"</span>
<span class="comment">// REALITY: Field access is O(1) - offsets are precomputed</span>
<span class="class-name">Labrador</span> lab = <span class="keyword">new</span> <span class="class-name">Labrador</span>(<span class="string">"Max"</span>, <span class="number">3</span>);
lab.getName();  <span class="comment">// Same speed whether name is in Animal or Labrador</span>

<span class="comment">// MYTH: "Interface calls are slower than class calls"</span>
<span class="comment">// REALITY: JIT optimizes common cases (monomorphic/bimorphic sites)</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
list.add(<span class="string">"item"</span>);  <span class="comment">// JIT often inlines this</span>

<span class="comment">// WHEN TO WORRY:</span>
<span class="comment">// - Extremely hot loops (millions of iterations)</span>
<span class="comment">// - Real-time systems with strict latency requirements</span>
<span class="comment">// - Even then, measure first!</span></code></pre>
        </section>

        <section class="content-section">
            <h2>In Practice: Real-World Applications</h2>

            <h3>Java Collections Framework</h3>
            <pre><code><span class="comment">// The Collections Framework is a masterclass in OOP design:</span>

<span class="comment">// ABSTRACTION: Interface defines contract</span>
<span class="keyword">public interface</span> <span class="class-name">List</span>&lt;<span class="class-name">E</span>&gt; <span class="keyword">extends</span> <span class="class-name">Collection</span>&lt;<span class="class-name">E</span>&gt; {
    <span class="keyword">void</span> <span class="function">add</span>(<span class="keyword">int</span> index, <span class="class-name">E</span> element);
    <span class="class-name">E</span> <span class="function">get</span>(<span class="keyword">int</span> index);
    <span class="comment">// ...</span>
}

<span class="comment">// INHERITANCE: AbstractList provides common implementation</span>
<span class="keyword">public abstract class</span> <span class="class-name">AbstractList</span>&lt;<span class="class-name">E</span>&gt; <span class="keyword">implements</span> <span class="class-name">List</span>&lt;<span class="class-name">E</span>&gt; {
    <span class="comment">// Provides iterator(), indexOf(), etc.</span>
}

<span class="comment">// POLYMORPHISM: Different implementations, same interface</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; arrayList = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();   <span class="comment">// O(1) random access</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; linkedList = <span class="keyword">new</span> <span class="class-name">LinkedList</span>&lt;&gt;(); <span class="comment">// O(1) insertion</span>

<span class="comment">// ENCAPSULATION: Internal array/nodes hidden</span>
arrayList.add(<span class="string">"item"</span>);  <span class="comment">// Don't know/care about internal array resizing</span></code></pre>

            <h3>Spring Framework</h3>
            <pre><code><span class="comment">// Spring uses OOP principles extensively:</span>

<span class="comment">// ABSTRACTION + POLYMORPHISM: Dependency Injection</span>
<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">OrderService</span> {
    <span class="keyword">private final</span> <span class="class-name">PaymentProcessor</span> paymentProcessor;  <span class="comment">// Interface!</span>

    <span class="comment">// Spring injects the appropriate implementation</span>
    <span class="keyword">public</span> <span class="function">OrderService</span>(<span class="class-name">PaymentProcessor</span> paymentProcessor) {
        <span class="keyword">this</span>.paymentProcessor = paymentProcessor;
    }

    <span class="keyword">public void</span> <span class="function">processOrder</span>(<span class="class-name">Order</span> order) {
        paymentProcessor.process(order.getTotal());  <span class="comment">// Works with ANY processor</span>
    }
}

<span class="comment">// Easy to swap implementations:</span>
<span class="annotation">@Profile</span>(<span class="string">"production"</span>)
<span class="annotation">@Component</span>
<span class="keyword">public class</span> <span class="class-name">StripePaymentProcessor</span> <span class="keyword">implements</span> <span class="class-name">PaymentProcessor</span> { }

<span class="annotation">@Profile</span>(<span class="string">"test"</span>)
<span class="annotation">@Component</span>
<span class="keyword">public class</span> <span class="class-name">MockPaymentProcessor</span> <span class="keyword">implements</span> <span class="class-name">PaymentProcessor</span> { }</code></pre>
        </section>

        <section class="content-section">
            <h2>Troubleshooting Guide</h2>

            <h3>Error: "Cannot instantiate abstract class"</h3>
            <pre><code><span class="comment">// Problem:</span>
<span class="class-name">Animal</span> animal = <span class="keyword">new</span> <span class="class-name">Animal</span>(<span class="string">"Rex"</span>, <span class="number">5</span>);  <span class="comment">// ERROR!</span>

<span class="comment">// Solution: Create a concrete subclass instance</span>
<span class="class-name">Animal</span> animal = <span class="keyword">new</span> <span class="class-name">Dog</span>(<span class="string">"Rex"</span>, <span class="number">5</span>, <span class="string">"Labrador"</span>);  <span class="comment">// ✅</span></code></pre>

            <h3>Error: "Method does not override method from superclass"</h3>
            <pre><code><span class="comment">// Problem: Signature doesn't match</span>
<span class="keyword">class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">eat</span>(<span class="class-name">String</span> food) { }  <span class="comment">// Different signature!</span>
}

<span class="comment">// Solution: Match the parent method signature exactly</span>
<span class="annotation">@Override</span>
<span class="keyword">public void</span> <span class="function">eat</span>() { }  <span class="comment">// ✅ Matches Animal.eat()</span></code></pre>

            <h3>Error: "Constructor call must be first statement"</h3>
            <pre><code><span class="comment">// Problem: super() not first</span>
<span class="keyword">public</span> <span class="function">Dog</span>(<span class="class-name">String</span> name) {
    <span class="class-name">System</span>.out.println(<span class="string">"Creating dog"</span>);  <span class="comment">// ERROR!</span>
    <span class="keyword">super</span>(name, <span class="number">0</span>);
}

<span class="comment">// Solution: super() must be first</span>
<span class="keyword">public</span> <span class="function">Dog</span>(<span class="class-name">String</span> name) {
    <span class="keyword">super</span>(name, <span class="number">0</span>);  <span class="comment">// ✅ First!</span>
    <span class="class-name">System</span>.out.println(<span class="string">"Creating dog"</span>);
}</code></pre>

            <h3>Problem: Unexpected method called (wrong polymorphism)</h3>
            <pre><code><span class="comment">// Problem: Calling overloaded instead of overridden method</span>
<span class="keyword">class</span> <span class="class-name">Parent</span> {
    <span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">Object</span> obj) {
        <span class="class-name">System</span>.out.println(<span class="string">"Parent"</span>);
    }
}

<span class="keyword">class</span> <span class="class-name">Child</span> <span class="keyword">extends</span> <span class="class-name">Parent</span> {
    <span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">String</span> str) {  <span class="comment">// Overloading, not overriding!</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Child"</span>);
    }
}

<span class="class-name">Parent</span> p = <span class="keyword">new</span> <span class="class-name">Child</span>();
p.process(<span class="string">"test"</span>);  <span class="comment">// Prints "Parent"! Reference type determines overload</span>

<span class="comment">// Solution: Make sure you're overriding, not overloading</span>
<span class="keyword">class</span> <span class="class-name">Child</span> <span class="keyword">extends</span> <span class="class-name">Parent</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">process</span>(<span class="class-name">Object</span> obj) {  <span class="comment">// Same signature = override</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Child"</span>);
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Q1: What are the four pillars of OOP?</div>
                <p><strong>Answer:</strong> Encapsulation (hiding data, exposing behavior), Inheritance (creating class hierarchies, code reuse), Polymorphism (many forms, runtime method dispatch), and Abstraction (hiding complexity, showing essential features). Together they enable modular, maintainable, extensible code.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q2: What's the difference between method overloading and overriding?</div>
                <p><strong>Answer:</strong> <strong>Overloading</strong> is compile-time polymorphism where multiple methods have the same name but different parameters (resolved by compiler based on argument types). <strong>Overriding</strong> is runtime polymorphism where a subclass provides a specific implementation of a parent method (same signature, resolved at runtime based on object type).</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q3: Why should we "favor composition over inheritance"?</div>
                <p><strong>Answer:</strong> Inheritance creates tight coupling and exposes internal details. Composition is more flexible (can change at runtime), avoids fragile base class problem, and better models "has-a" relationships. Use inheritance only for genuine "is-a" relationships where substitutability is needed.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q4: Explain the Liskov Substitution Principle.</div>
                <p><strong>Answer:</strong> Objects of a superclass should be replaceable with objects of a subclass without altering program correctness. Subclasses must honor the contract of the parent: accept the same inputs (or more general), return the same outputs (or more specific), and not throw unexpected exceptions. The classic Square/Rectangle example violates this.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q5: Can we override static methods?</div>
                <p><strong>Answer:</strong> No. Static methods belong to the class, not instances, so there's no polymorphism. If a subclass defines a static method with the same signature, it's <strong>method hiding</strong>, not overriding. The method called depends on the reference type, not the object type.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q6: What's the diamond problem and how does Java solve it?</div>
                <p><strong>Answer:</strong> The diamond problem occurs when a class inherits from two classes that have a common ancestor, causing ambiguity about which inherited member to use. Java avoids this by allowing only single inheritance for classes. For interfaces (Java 8+), if two interfaces have default methods with the same signature, the implementing class must override and explicitly choose which to use.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q7: What's the difference between abstraction and encapsulation?</div>
                <p><strong>Answer:</strong> <strong>Encapsulation</strong> hides <em>data</em> (making fields private, providing controlled access). <strong>Abstraction</strong> hides <em>implementation complexity</em> (showing what an object does, not how). Encapsulation is about bundling and protecting; abstraction is about simplifying the interface. They're complementary: encapsulation implements data hiding, abstraction defines what to hide.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q8: When would you use an abstract class vs. an interface?</div>
                <p><strong>Answer:</strong> Use <strong>abstract class</strong> when: sharing code among related classes, need constructors/instance fields, defining template methods. Use <strong>interface</strong> when: defining a capability for unrelated classes, need multiple inheritance of type, defining pure contracts. Java 8+ blurred this with default methods in interfaces, but abstract classes still win when you need state or constructors.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="interfaces-abstract.html">Interfaces vs Abstract Classes</a> &ndash; Detailed comparison and when to use each</li>
                <li><a href="access-modifiers.html">Access Modifiers</a> &ndash; Implementing encapsulation</li>
                <li><a href="constructors.html">Constructors</a> &ndash; Object initialization and inheritance</li>
                <li><a href="../advanced/design-patterns.html">Design Patterns</a> &ndash; OOP patterns in practice</li>
                <li><a href="../best-practices/solid-principles.html">SOLID Principles</a> &ndash; OOP design principles</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="interfaces-abstract.html" class="related-link">Interfaces vs Abstract Classes</a>
                <a href="access-modifiers.html" class="related-link">Access Modifiers</a>
                <a href="constructors.html" class="related-link">Constructors</a>
                <a href="static-instance.html" class="related-link">Static vs Instance</a>
                <a href="generics.html" class="related-link">Generics</a>
                <a href="../advanced/design-patterns.html" class="related-link">Design Patterns</a>
                <a href="../best-practices/solid-principles.html" class="related-link">SOLID Principles</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
