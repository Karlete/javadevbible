<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variables & Data Types - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Variables & Data Types
            </nav>
            <h1>Variables & Data Types</h1>
            <p class="topic-subtitle">Understanding Java's Type System and Variables</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What Are Variables?</h2>
            <p>Variables are the fundamental building blocks of any Java program, serving as named containers that store data in your computer's memory. At its core, a variable is simply a labeled memory location where you can store, retrieve, and manipulate data during program execution. Every piece of data your program works with&mdash;from a user's name to a complex calculation result&mdash;is stored in variables. Understanding how variables work is essential because they form the foundation upon which all other programming concepts are built.</p>

            <p>Java is a <strong>statically-typed</strong> language, which means every variable must have a declared type before it can be used. This is fundamentally different from dynamically-typed languages like Python or JavaScript, where variables can hold any type of data at any time. In Java, when you declare a variable as an <code>int</code>, it can only ever hold integer values&mdash;you cannot later assign a String to it. This strictness might seem limiting at first, but it provides significant benefits: the compiler catches type-related errors before your code ever runs, making your programs more robust and easier to debug.</p>

            <p>The concept of variables dates back to the earliest days of programming, but Java's approach to types was influenced by its goal of being a safe, portable language. When Java was designed in the early 1990s, the creators decided that explicit typing and strong type checking would help prevent the kinds of bugs that plagued C and C++ programs. They also made the sizes of primitive types consistent across all platforms&mdash;an <code>int</code> is always 32 bits, whether you're running on Windows, Linux, or any other operating system. This was revolutionary at the time and remains one of Java's key portability features.</p>

            <p>Java's type system divides all data into two fundamental categories: <strong>primitive types</strong> and <strong>reference types</strong>. Primitive types (like <code>int</code>, <code>boolean</code>, and <code>double</code>) store actual values directly in memory and represent the most basic data elements. Reference types (like <code>String</code>, arrays, and objects) store references (memory addresses) that point to where the actual data lives in the heap. Understanding this distinction is crucial because primitives and references behave differently in assignments, method calls, and memory management.</p>

            <p>Modern Java continues to evolve its type system. Java 10 introduced <code>var</code> for local variable type inference, allowing the compiler to deduce types automatically. Java 14 added records for immutable data carriers. Java 17 introduced sealed classes for restricted type hierarchies. These features build upon the strong typing foundation while reducing verbosity and improving expressiveness. Whether you're a beginner learning your first programming language or an experienced developer coming from another language, mastering Java's type system is the gateway to writing effective Java code.</p>

            <h3>Real-World Analogy</h3>
            <p>Think of variables as labeled containers in an organized storage room. Just as you might have containers of different sizes and types for storing different things, Java has different variable types for different kinds of data:</p>
            <ul>
                <li><strong>Small drawer (byte)</strong> = Holds small numbers like ages (0-127)</li>
                <li><strong>Medium box (int)</strong> = Holds regular numbers like populations (up to ~2 billion)</li>
                <li><strong>Large container (long)</strong> = Holds very large numbers like national debts</li>
                <li><strong>Price tag (double)</strong> = Holds decimal numbers like $19.99</li>
                <li><strong>Name label (String)</strong> = Holds text like "Alice Johnson"</li>
                <li><strong>Light switch (boolean)</strong> = Either ON (true) or OFF (false)</li>
            </ul>
            <p>Each container has a specific purpose and capacity. You wouldn't try to fit a car in a shoebox, and you wouldn't use a shipping container for a single marble. Similarly, choosing the right variable type for your data is essential for writing efficient, correct programs.</p>

            <div class="info-box note">
                <div class="info-box-title">Key Concepts</div>
                <ul>
                    <li><strong>Static typing</strong> &ndash; Types are checked at compile time, not runtime</li>
                    <li><strong>Declaration</strong> &ndash; Variables must be declared with a type before use</li>
                    <li><strong>Initialization</strong> &ndash; Variables should be given initial values before reading</li>
                    <li><strong>Scope</strong> &ndash; Variables are only accessible within their declared block</li>
                    <li><strong>Naming conventions</strong> &ndash; Use camelCase for variables, UPPER_CASE for constants</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Under the Hood: How Variables Work in Memory</h2>
            <p>Understanding how Java stores variables in memory helps you write better code and debug issues more effectively. Java's memory model divides the runtime memory into distinct areas, each serving a specific purpose.</p>

            <pre><code><span class="comment">/*
 * Java Memory Model - Variable Storage
 * =====================================
 *
 *  ┌─────────────────────────────────────────────────────────────────────┐
 *  │                         JVM MEMORY                                   │
 *  │                                                                      │
 *  │  ┌─────────────────────────────────────────────────────────────┐    │
 *  │  │                     STACK MEMORY                             │    │
 *  │  │  (Each thread has its own stack)                             │    │
 *  │  │                                                              │    │
 *  │  │  ┌─────────────────────────────────────────────────────┐    │    │
 *  │  │  │ Method Frame: main()                                 │    │    │
 *  │  │  │   ┌──────────┬───────┐                               │    │    │
 *  │  │  │   │ int age  │  25   │ ← Primitive: value stored     │    │    │
 *  │  │  │   ├──────────┼───────┤   directly on stack           │    │    │
 *  │  │  │   │ double d │ 3.14  │                               │    │    │
 *  │  │  │   ├──────────┼───────┤                               │    │    │
 *  │  │  │   │ name     │ 0x742 │ ← Reference: stores address   │    │    │
 *  │  │  │   └──────────┴───┬───┘   pointing to heap            │    │    │
 *  │  │  └──────────────────┼───────────────────────────────────┘    │    │
 *  │  └─────────────────────┼────────────────────────────────────────┘    │
 *  │                        │                                             │
 *  │                        ▼                                             │
 *  │  ┌─────────────────────────────────────────────────────────────┐    │
 *  │  │                     HEAP MEMORY                              │    │
 *  │  │  (Shared by all threads - Objects live here)                 │    │
 *  │  │                                                              │    │
 *  │  │     0x742: ┌───────────────────────────────┐                 │    │
 *  │  │            │ String Object                  │                 │    │
 *  │  │            │   value: ['A','l','i','c','e'] │                 │    │
 *  │  │            │   hash:  63494142              │                 │    │
 *  │  │            └───────────────────────────────┘                 │    │
 *  │  │                                                              │    │
 *  │  │     0x850: ┌───────────────────────────────┐                 │    │
 *  │  │            │ Person Object                  │                 │    │
 *  │  │            │   name: 0x742  ────────────────┼─── (reference) │    │
 *  │  │            │   age: 25                      │                 │    │
 *  │  │            └───────────────────────────────┘                 │    │
 *  │  │                                                              │    │
 *  │  └──────────────────────────────────────────────────────────────┘    │
 *  └─────────────────────────────────────────────────────────────────────┘
 *
 *  KEY INSIGHT:
 *  - Primitives store VALUES directly on the stack
 *  - References store ADDRESSES on the stack, with objects on the heap
 *  - This is why primitives are faster - no pointer dereferencing needed
 */</span></code></pre>

            <h3>Primitive vs Reference: Memory Behavior</h3>
            <pre><code><span class="comment">// PRIMITIVES: Copies the actual value</span>
<span class="keyword">int</span> a = <span class="number">10</span>;
<span class="keyword">int</span> b = a;       <span class="comment">// b gets a COPY of the value 10</span>
b = <span class="number">20</span>;          <span class="comment">// Only b changes</span>
<span class="class-name">System</span>.out.println(a);  <span class="comment">// Still 10!</span>
<span class="class-name">System</span>.out.println(b);  <span class="comment">// 20</span>

<span class="comment">// REFERENCES: Copies the address (both point to same object)</span>
<span class="keyword">int</span>[] arr1 = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};
<span class="keyword">int</span>[] arr2 = arr1;     <span class="comment">// arr2 points to SAME array</span>
arr2[<span class="number">0</span>] = <span class="number">999</span>;         <span class="comment">// Modifies the shared array</span>
<span class="class-name">System</span>.out.println(arr1[<span class="number">0</span>]);  <span class="comment">// 999 - arr1 sees the change!</span></code></pre>

            <pre><code><span class="comment">/*
 * Visualizing Primitive vs Reference Assignment
 * ==============================================
 *
 * PRIMITIVE ASSIGNMENT (int a = 10; int b = a;):
 *
 *   Stack:
 *   ┌──────┬──────┐     ┌──────┬──────┐
 *   │  a   │  10  │     │  b   │  10  │  ← Separate copies!
 *   └──────┴──────┘     └──────┴──────┘
 *
 *
 * REFERENCE ASSIGNMENT (int[] arr1 = {1,2,3}; int[] arr2 = arr1;):
 *
 *   Stack:                              Heap:
 *   ┌──────┬────────┐                   ┌─────────────────┐
 *   │ arr1 │ 0x100 ─┼──────────────────►│ [1, 2, 3]       │
 *   └──────┴────────┘                   └─────────────────┘
 *   ┌──────┬────────┐                          ▲
 *   │ arr2 │ 0x100 ─┼──────────────────────────┘
 *   └──────┴────────┘       Both point to same object!
 *
 */</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Performance Insight</div>
                <p>Primitives are stored directly on the stack, making them faster to access. Reference types require an extra memory lookup (dereferencing) to get to the actual data on the heap. For performance-critical code, prefer primitives when possible.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Primitive Data Types</h2>
            <p>Java has exactly 8 primitive data types, each designed for specific use cases. These types are built into the language and represent the most fundamental data elements. Unlike objects, primitives cannot be null and have no methods&mdash;they're pure values.</p>

            <h3>Integer Types: byte, short, int, long</h3>
            <p>Integer types store whole numbers without decimal points. Choose based on the range of values you need:</p>

            <pre><code><span class="comment">// byte: 8-bit signed integer (-128 to 127)</span>
<span class="comment">// Best for: Memory-efficient storage of small numbers, binary data</span>
<span class="keyword">byte</span> age = <span class="number">25</span>;
<span class="keyword">byte</span> maxByte = <span class="number">127</span>;
<span class="keyword">byte</span> minByte = -<span class="number">128</span>;
<span class="comment">// byte overflow = 128;  // ERROR: too large for byte!</span>

<span class="comment">// short: 16-bit signed integer (-32,768 to 32,767)</span>
<span class="comment">// Best for: Legacy systems, rare - usually just use int</span>
<span class="keyword">short</span> year = <span class="number">2024</span>;
<span class="keyword">short</span> temperature = -<span class="number">273</span>;

<span class="comment">// int: 32-bit signed integer (-2,147,483,648 to 2,147,483,647)</span>
<span class="comment">// THE DEFAULT CHOICE for whole numbers</span>
<span class="keyword">int</span> population = <span class="number">1_000_000</span>;      <span class="comment">// Underscores for readability (Java 7+)</span>
<span class="keyword">int</span> maxInt = <span class="class-name">Integer</span>.MAX_VALUE;  <span class="comment">// 2,147,483,647</span>
<span class="keyword">int</span> hexValue = <span class="number">0xFF</span>;             <span class="comment">// Hexadecimal notation</span>
<span class="keyword">int</span> binaryValue = <span class="number">0b1010</span>;        <span class="comment">// Binary notation (Java 7+)</span>

<span class="comment">// long: 64-bit signed integer (-9.2 quintillion to 9.2 quintillion)</span>
<span class="comment">// Best for: Very large numbers, timestamps, IDs</span>
<span class="keyword">long</span> worldPopulation = <span class="number">8_000_000_000L</span>;  <span class="comment">// Note the L suffix!</span>
<span class="keyword">long</span> timestamp = <span class="class-name">System</span>.currentTimeMillis();
<span class="keyword">long</span> fileSize = <span class="number">3_221_225_472L</span>;         <span class="comment">// 3 GB in bytes</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Don't Forget the L Suffix!</div>
                <p>When assigning large values to <code>long</code>, always use the <code>L</code> suffix. Without it, Java treats the literal as an <code>int</code>, which will fail for values over 2 billion:</p>
                <pre><code><span class="comment">// long big = 3000000000;   // ERROR: integer number too large</span>
<span class="keyword">long</span> big = <span class="number">3000000000L</span>;      <span class="comment">// Correct - use L suffix</span></code></pre>
            </div>

            <h3>Floating-Point Types: float, double</h3>
            <p>Floating-point types store numbers with decimal points using IEEE 754 standard:</p>

            <pre><code><span class="comment">// float: 32-bit IEEE 754 floating point (~6-7 significant digits)</span>
<span class="comment">// Rarely used - only when memory is critical</span>
<span class="keyword">float</span> price = <span class="number">19.99f</span>;          <span class="comment">// Note the f suffix!</span>
<span class="keyword">float</span> temperature = <span class="number">98.6f</span>;
<span class="keyword">float</span> scientific = <span class="number">3.14e2f</span>;   <span class="comment">// 314.0 (scientific notation)</span>

<span class="comment">// double: 64-bit IEEE 754 floating point (~15-16 significant digits)</span>
<span class="comment">// THE DEFAULT CHOICE for decimal numbers</span>
<span class="keyword">double</span> pi = <span class="number">3.141592653589793</span>;
<span class="keyword">double</span> avogadro = <span class="number">6.022e23</span>;    <span class="comment">// Scientific notation</span>
<span class="keyword">double</span> tiny = <span class="number">1.23e-10</span>;       <span class="comment">// Very small numbers</span>

<span class="comment">// Special values</span>
<span class="keyword">double</span> infinity = <span class="class-name">Double</span>.POSITIVE_INFINITY;
<span class="keyword">double</span> negInfinity = <span class="class-name">Double</span>.NEGATIVE_INFINITY;
<span class="keyword">double</span> notANumber = <span class="class-name">Double</span>.NaN;  <span class="comment">// Result of 0.0/0.0</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Never Use float/double for Money!</div>
                <p>Floating-point arithmetic can produce surprising results due to binary representation:</p>
                <pre><code><span class="keyword">double</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;
<span class="class-name">System</span>.out.println(a);  <span class="comment">// 0.30000000000000004 (!)</span>

<span class="comment">// Use BigDecimal for financial calculations:</span>
<span class="class-name">BigDecimal</span> price = <span class="keyword">new</span> <span class="class-name">BigDecimal</span>(<span class="string">"19.99"</span>);
<span class="class-name">BigDecimal</span> tax = <span class="keyword">new</span> <span class="class-name">BigDecimal</span>(<span class="string">"0.08"</span>);
<span class="class-name">BigDecimal</span> total = price.add(price.multiply(tax));</code></pre>
            </div>

            <h3>Character Type: char</h3>
            <pre><code><span class="comment">// char: 16-bit Unicode character (0 to 65,535)</span>
<span class="keyword">char</span> letter = <span class="string">'A'</span>;           <span class="comment">// Single quotes for char!</span>
<span class="keyword">char</span> digit = <span class="string">'7'</span>;
<span class="keyword">char</span> symbol = <span class="string">'$'</span>;
<span class="keyword">char</span> newline = <span class="string">'\n'</span>;         <span class="comment">// Escape sequence</span>
<span class="keyword">char</span> tab = <span class="string">'\t'</span>;
<span class="keyword">char</span> unicode = <span class="string">'\u0041'</span>;     <span class="comment">// 'A' in Unicode</span>
<span class="keyword">char</span> emoji = <span class="string">'\u2764'</span>;       <span class="comment">// Heart symbol ❤</span>
<span class="keyword">char</span> japanese = <span class="string">'\u3042'</span>;    <span class="comment">// Hiragana 'a' あ</span>

<span class="comment">// char is numeric - arithmetic works!</span>
<span class="keyword">char</span> c = <span class="string">'A'</span>;
<span class="class-name">System</span>.out.println((<span class="keyword">int</span>) c);      <span class="comment">// 65</span>
<span class="class-name">System</span>.out.println((<span class="keyword">char</span>)(c + <span class="number">1</span>)); <span class="comment">// B</span></code></pre>

            <h3>Boolean Type: boolean</h3>
            <pre><code><span class="comment">// boolean: true or false (1 bit logically, but JVM uses more)</span>
<span class="keyword">boolean</span> isActive = <span class="keyword">true</span>;
<span class="keyword">boolean</span> hasPermission = <span class="keyword">false</span>;

<span class="comment">// Common usage patterns</span>
<span class="keyword">boolean</span> isAdult = age >= <span class="number">18</span>;
<span class="keyword">boolean</span> canVote = isAdult &amp;&amp; isCitizen;
<span class="keyword">boolean</span> isEmpty = list.size() == <span class="number">0</span>;

<span class="comment">// Unlike C/C++, integers CANNOT be used as booleans</span>
<span class="comment">// if (1) { }         // ERROR in Java!</span>
<span class="comment">// if (pointer) { }   // ERROR in Java!</span>
<span class="keyword">if</span> (<span class="keyword">true</span>) { }        <span class="comment">// Only true/false allowed</span></code></pre>

            <h3>Complete Primitive Types Reference Table</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Size</th>
                    <th>Min Value</th>
                    <th>Max Value</th>
                    <th>Default</th>
                    <th>Use Case</th>
                </tr>
                <tr>
                    <td><code>byte</code></td>
                    <td>8 bits</td>
                    <td>-128</td>
                    <td>127</td>
                    <td>0</td>
                    <td>Binary data, small arrays</td>
                </tr>
                <tr>
                    <td><code>short</code></td>
                    <td>16 bits</td>
                    <td>-32,768</td>
                    <td>32,767</td>
                    <td>0</td>
                    <td>Legacy systems (rare)</td>
                </tr>
                <tr>
                    <td><code>int</code></td>
                    <td>32 bits</td>
                    <td>-2,147,483,648</td>
                    <td>2,147,483,647</td>
                    <td>0</td>
                    <td>Default for integers</td>
                </tr>
                <tr>
                    <td><code>long</code></td>
                    <td>64 bits</td>
                    <td>-9.2 &times; 10<sup>18</sup></td>
                    <td>9.2 &times; 10<sup>18</sup></td>
                    <td>0L</td>
                    <td>Timestamps, large IDs</td>
                </tr>
                <tr>
                    <td><code>float</code></td>
                    <td>32 bits</td>
                    <td>&plusmn;1.4 &times; 10<sup>-45</sup></td>
                    <td>&plusmn;3.4 &times; 10<sup>38</sup></td>
                    <td>0.0f</td>
                    <td>Graphics, memory-critical</td>
                </tr>
                <tr>
                    <td><code>double</code></td>
                    <td>64 bits</td>
                    <td>&plusmn;4.9 &times; 10<sup>-324</sup></td>
                    <td>&plusmn;1.7 &times; 10<sup>308</sup></td>
                    <td>0.0d</td>
                    <td>Default for decimals</td>
                </tr>
                <tr>
                    <td><code>char</code></td>
                    <td>16 bits</td>
                    <td>0 ('\u0000')</td>
                    <td>65,535 ('\uFFFF')</td>
                    <td>'\u0000'</td>
                    <td>Single characters</td>
                </tr>
                <tr>
                    <td><code>boolean</code></td>
                    <td>~1 bit*</td>
                    <td>false</td>
                    <td>true</td>
                    <td>false</td>
                    <td>Flags, conditions</td>
                </tr>
            </table>
            <p><em>*boolean size is JVM implementation-dependent; often uses 1 byte or even 4 bytes for alignment.</em></p>
        </section>

        <section class="content-section">
            <h2>Reference Types</h2>
            <p>Reference types are any types that are not primitives. They include classes, interfaces, arrays, and enums. Unlike primitives that store values directly, reference variables store memory addresses pointing to objects on the heap.</p>

            <h3>Strings: The Most Common Reference Type</h3>
            <pre><code><span class="comment">// String is a class, not a primitive</span>
<span class="class-name">String</span> name = <span class="string">"John Doe"</span>;           <span class="comment">// String literal (interned)</span>
<span class="class-name">String</span> greeting = <span class="keyword">new</span> <span class="class-name">String</span>(<span class="string">"Hello"</span>); <span class="comment">// Explicit object (avoid)</span>

<span class="comment">// Strings are IMMUTABLE - operations create new strings</span>
<span class="class-name">String</span> original = <span class="string">"Hello"</span>;
<span class="class-name">String</span> modified = original.toUpperCase();  <span class="comment">// "HELLO" - new String!</span>
<span class="class-name">System</span>.out.println(original);              <span class="comment">// Still "Hello"</span>

<span class="comment">// String concatenation</span>
<span class="class-name">String</span> fullName = <span class="string">"John"</span> + <span class="string">" "</span> + <span class="string">"Doe"</span>;

<span class="comment">// Useful String methods</span>
<span class="keyword">int</span> len = name.length();                  <span class="comment">// 8</span>
<span class="class-name">String</span> upper = name.toUpperCase();        <span class="comment">// "JOHN DOE"</span>
<span class="class-name">String</span> lower = name.toLowerCase();        <span class="comment">// "john doe"</span>
<span class="keyword">boolean</span> starts = name.startsWith(<span class="string">"John"</span>); <span class="comment">// true</span>
<span class="keyword">boolean</span> contains = name.contains(<span class="string">"Doe"</span>);  <span class="comment">// true</span>
<span class="class-name">String</span> replaced = name.replace(<span class="string">"John"</span>, <span class="string">"Jane"</span>);  <span class="comment">// "Jane Doe"</span>
<span class="class-name">String</span>[] parts = name.split(<span class="string">" "</span>);         <span class="comment">// ["John", "Doe"]</span>
<span class="class-name">String</span> trimmed = <span class="string">"  Hello  "</span>.trim();     <span class="comment">// "Hello"</span>

<span class="comment">// Text blocks (Java 15+) for multi-line strings</span>
<span class="class-name">String</span> json = <span class="string">"""
    {
        "name": "John",
        "age": 30
    }
    """</span>;

<span class="comment">// String formatting</span>
<span class="class-name">String</span> formatted = <span class="class-name">String</span>.format(<span class="string">"Name: %s, Age: %d"</span>, name, <span class="number">30</span>);
<span class="class-name">String</span> formatted2 = <span class="string">"Name: %s, Age: %d"</span>.formatted(name, <span class="number">30</span>);  <span class="comment">// Java 15+</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">String Comparison: Use equals(), Not ==</div>
                <pre><code><span class="class-name">String</span> s1 = <span class="string">"hello"</span>;
<span class="class-name">String</span> s2 = <span class="keyword">new</span> <span class="class-name">String</span>(<span class="string">"hello"</span>);

<span class="class-name">System</span>.out.println(s1 == s2);       <span class="comment">// false (different objects!)</span>
<span class="class-name">System</span>.out.println(s1.equals(s2));  <span class="comment">// true (same content)</span>

<span class="comment">// == compares memory addresses</span>
<span class="comment">// equals() compares actual content</span></code></pre>
            </div>

            <h3>Arrays: Fixed-Size Collections</h3>
            <pre><code><span class="comment">// Array declaration and initialization</span>
<span class="keyword">int</span>[] numbers = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};           <span class="comment">// Inline initialization</span>
<span class="keyword">int</span>[] scores = <span class="keyword">new int</span>[<span class="number">10</span>];                   <span class="comment">// Empty array of size 10</span>
<span class="class-name">String</span>[] names = {<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>};

<span class="comment">// Alternative syntax (type[] name is preferred)</span>
<span class="keyword">int</span> numbers2[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};  <span class="comment">// C-style, less common in Java</span>

<span class="comment">// Accessing elements (0-indexed)</span>
<span class="keyword">int</span> first = numbers[<span class="number">0</span>];      <span class="comment">// 1</span>
<span class="keyword">int</span> last = numbers[numbers.length - <span class="number">1</span>];  <span class="comment">// 5</span>
numbers[<span class="number">2</span>] = <span class="number">99</span>;             <span class="comment">// Modify element</span>

<span class="comment">// Array length (not a method!)</span>
<span class="keyword">int</span> size = numbers.length;   <span class="comment">// 5</span>

<span class="comment">// Multi-dimensional arrays</span>
<span class="keyword">int</span>[][] matrix = {
    {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>},
    {<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>},
    {<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>}
};
<span class="keyword">int</span> value = matrix[<span class="number">1</span>][<span class="number">2</span>];    <span class="comment">// 6 (row 1, column 2)</span>

<span class="comment">// Iterating arrays</span>
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) {
    <span class="class-name">System</span>.out.println(numbers[i]);
}

<span class="comment">// Enhanced for-loop (preferred for reading)</span>
<span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) {
    <span class="class-name">System</span>.out.println(num);
}</code></pre>

            <h3>Wrapper Classes: Primitives as Objects</h3>
            <p>Each primitive type has a corresponding wrapper class that allows primitives to be used as objects:</p>

            <pre><code><span class="comment">// Wrapper classes for primitives</span>
<span class="class-name">Integer</span> intObj = <span class="number">42</span>;           <span class="comment">// Autoboxing: int → Integer</span>
<span class="keyword">int</span> intPrim = intObj;          <span class="comment">// Unboxing: Integer → int</span>

<span class="class-name">Double</span> doubleObj = <span class="number">3.14</span>;
<span class="class-name">Boolean</span> boolObj = <span class="keyword">true</span>;
<span class="class-name">Character</span> charObj = <span class="string">'A'</span>;

<span class="comment">// Why use wrappers?</span>
<span class="comment">// 1. Collections require objects</span>
<span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; numbers = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
numbers.add(<span class="number">42</span>);  <span class="comment">// Autoboxing</span>

<span class="comment">// 2. Can be null (primitives cannot)</span>
<span class="class-name">Integer</span> maybeNull = <span class="keyword">null</span>;  <span class="comment">// Valid</span>
<span class="comment">// int cannotBeNull = null;  // ERROR!</span>

<span class="comment">// 3. Useful utility methods</span>
<span class="keyword">int</span> parsed = <span class="class-name">Integer</span>.parseInt(<span class="string">"123"</span>);
<span class="class-name">String</span> binary = <span class="class-name">Integer</span>.toBinaryString(<span class="number">42</span>);  <span class="comment">// "101010"</span>
<span class="keyword">int</span> max = <span class="class-name">Integer</span>.MAX_VALUE;
<span class="keyword">boolean</span> isDigit = <span class="class-name">Character</span>.isDigit(<span class="string">'5'</span>);   <span class="comment">// true</span></code></pre>

            <table>
                <tr>
                    <th>Primitive</th>
                    <th>Wrapper Class</th>
                    <th>Example Usage</th>
                </tr>
                <tr>
                    <td><code>byte</code></td>
                    <td><code>Byte</code></td>
                    <td><code>Byte.parseByte("42")</code></td>
                </tr>
                <tr>
                    <td><code>short</code></td>
                    <td><code>Short</code></td>
                    <td><code>Short.parseShort("1000")</code></td>
                </tr>
                <tr>
                    <td><code>int</code></td>
                    <td><code>Integer</code></td>
                    <td><code>Integer.parseInt("123")</code></td>
                </tr>
                <tr>
                    <td><code>long</code></td>
                    <td><code>Long</code></td>
                    <td><code>Long.parseLong("999999")</code></td>
                </tr>
                <tr>
                    <td><code>float</code></td>
                    <td><code>Float</code></td>
                    <td><code>Float.parseFloat("3.14")</code></td>
                </tr>
                <tr>
                    <td><code>double</code></td>
                    <td><code>Double</code></td>
                    <td><code>Double.parseDouble("3.14159")</code></td>
                </tr>
                <tr>
                    <td><code>char</code></td>
                    <td><code>Character</code></td>
                    <td><code>Character.isLetter('A')</code></td>
                </tr>
                <tr>
                    <td><code>boolean</code></td>
                    <td><code>Boolean</code></td>
                    <td><code>Boolean.parseBoolean("true")</code></td>
                </tr>
            </table>
        </section>

        <section class="content-section">
            <h2>Variable Declaration and Initialization</h2>

            <h3>Basic Declaration Patterns</h3>
            <pre><code><span class="comment">// Declaration with initialization (recommended)</span>
<span class="keyword">int</span> count = <span class="number">10</span>;

<span class="comment">// Declaration only (must initialize before use)</span>
<span class="keyword">int</span> total;
<span class="comment">// System.out.println(total);  // ERROR: variable might not be initialized</span>
total = <span class="number">100</span>;
<span class="class-name">System</span>.out.println(total);    <span class="comment">// Now OK</span>

<span class="comment">// Multiple variables of same type</span>
<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;

<span class="comment">// Multiple declarations (mixed initialized/uninitialized)</span>
<span class="keyword">int</span> a, b = <span class="number">5</span>, c;  <span class="comment">// Only b is initialized</span></code></pre>

            <h3>Local Variable Type Inference (var) - Java 10+</h3>
            <pre><code><span class="comment">// var lets the compiler infer the type</span>
<span class="keyword">var</span> name = <span class="string">"Alice"</span>;        <span class="comment">// Inferred as String</span>
<span class="keyword">var</span> age = <span class="number">25</span>;              <span class="comment">// Inferred as int</span>
<span class="keyword">var</span> prices = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;<span class="class-name">Double</span>&gt;();  <span class="comment">// Inferred as ArrayList&lt;Double&gt;</span>
<span class="keyword">var</span> map = <span class="class-name">Map</span>.of(<span class="string">"a"</span>, <span class="number">1</span>, <span class="string">"b"</span>, <span class="number">2</span>);       <span class="comment">// Inferred as Map&lt;String, Integer&gt;</span>

<span class="comment">// var restrictions:</span>
<span class="comment">// var x;                    // ERROR: cannot infer without initializer</span>
<span class="comment">// var nothing = null;       // ERROR: cannot infer type from null</span>
<span class="comment">// var nums = {1, 2, 3};     // ERROR: cannot infer array type</span>
<span class="keyword">var</span> nums = <span class="keyword">new int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};  <span class="comment">// OK: explicit array creation</span>

<span class="comment">// var is only for local variables</span>
<span class="comment">// Cannot use var for fields, parameters, or return types</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">When to Use var</div>
                <p>Use <code>var</code> when:</p>
                <ul>
                    <li>The type is obvious from the right side: <code>var list = new ArrayList&lt;String&gt;();</code></li>
                    <li>The type name is long: <code>var entries = map.entrySet();</code></li>
                </ul>
                <p>Avoid <code>var</code> when:</p>
                <ul>
                    <li>The type isn't clear: <code>var result = calculate();</code> - What type is this?</li>
                    <li>Working with primitives where precision matters: <code>var x = 1.0;</code> - Is it float or double?</li>
                </ul>
            </div>

            <h3>Variable Scope</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">ScopeExample</span> {
    <span class="comment">// Instance variable - belongs to each object instance</span>
    <span class="keyword">private</span> <span class="class-name">String</span> instanceField = <span class="string">"instance"</span>;

    <span class="comment">// Static variable - shared by all instances (class-level)</span>
    <span class="keyword">private static</span> <span class="keyword">int</span> staticCounter = <span class="number">0</span>;

    <span class="keyword">public void</span> <span class="function">demonstrateScope</span>(<span class="class-name">String</span> parameter) {  <span class="comment">// Method parameter</span>
        <span class="comment">// Local variable - only exists within this method</span>
        <span class="keyword">int</span> localVar = <span class="number">10</span>;

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
            <span class="comment">// Loop variable - only exists within the for loop</span>
            <span class="keyword">int</span> loopLocal = i * <span class="number">2</span>;
            <span class="class-name">System</span>.out.println(loopLocal);
        }
        <span class="comment">// i and loopLocal are not accessible here</span>

        <span class="keyword">if</span> (localVar &gt; <span class="number">5</span>) {
            <span class="comment">// Block variable - only exists within this if block</span>
            <span class="class-name">String</span> blockVar = <span class="string">"block"</span>;
            <span class="class-name">System</span>.out.println(blockVar);
        }
        <span class="comment">// blockVar is not accessible here</span>
    }
}</code></pre>

            <pre><code><span class="comment">/*
 * Variable Scope Visualization
 * ============================
 *
 *  ┌──────────────────────────────────────────────────────────────────┐
 *  │ CLASS SCOPE                                                       │
 *  │   static int staticCounter   ← Shared by ALL instances            │
 *  │                                                                   │
 *  │  ┌────────────────────────────────────────────────────────────┐  │
 *  │  │ INSTANCE SCOPE                                              │  │
 *  │  │   String instanceField    ← Each object has its own copy    │  │
 *  │  │                                                             │  │
 *  │  │  ┌───────────────────────────────────────────────────────┐  │  │
 *  │  │  │ METHOD SCOPE (demonstrateScope)                        │  │  │
 *  │  │  │   String parameter     ← Passed in                     │  │  │
 *  │  │  │   int localVar         ← Exists during method call     │  │  │
 *  │  │  │                                                        │  │  │
 *  │  │  │  ┌─────────────────────────────────────────────────┐   │  │  │
 *  │  │  │  │ BLOCK SCOPE (for loop)                          │   │  │  │
 *  │  │  │  │   int i             ← Only in for loop          │   │  │  │
 *  │  │  │  │   int loopLocal     ← Only in for loop          │   │  │  │
 *  │  │  │  └─────────────────────────────────────────────────┘   │  │  │
 *  │  │  │                                                        │  │  │
 *  │  │  │  ┌─────────────────────────────────────────────────┐   │  │  │
 *  │  │  │  │ BLOCK SCOPE (if block)                          │   │  │  │
 *  │  │  │  │   String blockVar   ← Only in if block          │   │  │  │
 *  │  │  │  └─────────────────────────────────────────────────┘   │  │  │
 *  │  │  │                                                        │  │  │
 *  │  │  └────────────────────────────────────────────────────────┘  │  │
 *  │  └──────────────────────────────────────────────────────────────┘  │
 *  └────────────────────────────────────────────────────────────────────┘
 */</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Type Conversion (Casting)</h2>
            <p>Java is strict about types but provides mechanisms for converting between compatible types.</p>

            <h3>Implicit Conversion (Widening)</h3>
            <p>Automatic conversion from smaller to larger types. No data loss possible.</p>

            <pre><code><span class="comment">// Widening: byte → short → int → long → float → double</span>
<span class="keyword">byte</span> b = <span class="number">10</span>;
<span class="keyword">short</span> s = b;      <span class="comment">// byte to short (automatic)</span>
<span class="keyword">int</span> i = s;        <span class="comment">// short to int (automatic)</span>
<span class="keyword">long</span> l = i;       <span class="comment">// int to long (automatic)</span>
<span class="keyword">float</span> f = l;      <span class="comment">// long to float (automatic)</span>
<span class="keyword">double</span> d = f;     <span class="comment">// float to double (automatic)</span>

<span class="comment">// char can widen to int and larger</span>
<span class="keyword">char</span> c = <span class="string">'A'</span>;
<span class="keyword">int</span> charValue = c;  <span class="comment">// 65</span>

<span class="comment">// In expressions, smaller types promote to int</span>
<span class="keyword">byte</span> b1 = <span class="number">10</span>, b2 = <span class="number">20</span>;
<span class="comment">// byte result = b1 + b2;  // ERROR! b1 + b2 is int</span>
<span class="keyword">int</span> result = b1 + b2;     <span class="comment">// OK</span></code></pre>

            <h3>Explicit Conversion (Narrowing)</h3>
            <p>Manual casting from larger to smaller types. May lose data!</p>

            <pre><code><span class="comment">// Narrowing requires explicit cast</span>
<span class="keyword">double</span> d = <span class="number">100.99</span>;
<span class="keyword">int</span> i = (<span class="keyword">int</span>) d;      <span class="comment">// 100 (decimal part LOST!)</span>

<span class="keyword">long</span> l = <span class="number">1000L</span>;
<span class="keyword">int</span> n = (<span class="keyword">int</span>) l;      <span class="comment">// OK if value fits in int</span>

<span class="comment">// Dangerous: overflow when value doesn't fit</span>
<span class="keyword">int</span> big = <span class="number">130</span>;
<span class="keyword">byte</span> small = (<span class="keyword">byte</span>) big;  <span class="comment">// -126 (OVERFLOW! 130 doesn't fit in byte)</span>

<span class="comment">// Safe pattern: check before casting</span>
<span class="keyword">long</span> value = getSomeValue();
<span class="keyword">if</span> (value &gt;= <span class="class-name">Integer</span>.MIN_VALUE &amp;&amp; value &lt;= <span class="class-name">Integer</span>.MAX_VALUE) {
    <span class="keyword">int</span> safeInt = (<span class="keyword">int</span>) value;
} <span class="keyword">else</span> {
    <span class="keyword">throw new</span> <span class="class-name">ArithmeticException</span>(<span class="string">"Value out of int range"</span>);
}</code></pre>

            <h3>String Conversions</h3>
            <pre><code><span class="comment">// String to primitive (parsing)</span>
<span class="keyword">int</span> num = <span class="class-name">Integer</span>.parseInt(<span class="string">"123"</span>);
<span class="keyword">double</span> decimal = <span class="class-name">Double</span>.parseDouble(<span class="string">"3.14"</span>);
<span class="keyword">boolean</span> flag = <span class="class-name">Boolean</span>.parseBoolean(<span class="string">"true"</span>);
<span class="keyword">long</span> bigNum = <span class="class-name">Long</span>.parseLong(<span class="string">"999999999999"</span>);

<span class="comment">// Primitive to String</span>
<span class="class-name">String</span> s1 = <span class="class-name">String</span>.valueOf(<span class="number">42</span>);          <span class="comment">// "42"</span>
<span class="class-name">String</span> s2 = <span class="class-name">Integer</span>.toString(<span class="number">42</span>);        <span class="comment">// "42"</span>
<span class="class-name">String</span> s3 = <span class="string">""</span> + <span class="number">42</span>;                    <span class="comment">// "42" (concatenation)</span>
<span class="class-name">String</span> s4 = <span class="class-name">String</span>.format(<span class="string">"%d"</span>, <span class="number">42</span>);     <span class="comment">// "42"</span>

<span class="comment">// Handling invalid input</span>
<span class="keyword">try</span> {
    <span class="keyword">int</span> value = <span class="class-name">Integer</span>.parseInt(<span class="string">"not a number"</span>);
} <span class="keyword">catch</span> (<span class="class-name">NumberFormatException</span> e) {
    <span class="class-name">System</span>.out.println(<span class="string">"Invalid number format"</span>);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Constants and Final Variables</h2>
            <pre><code><span class="comment">// Constants: use final keyword</span>
<span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;
<span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265359</span>;
<span class="keyword">final</span> <span class="class-name">String</span> APP_NAME = <span class="string">"MyApp"</span>;

<span class="comment">// MAX_SIZE = 200;  // ERROR: cannot assign to final variable</span>

<span class="comment">// Convention: UPPER_SNAKE_CASE for constants</span>
<span class="keyword">public static final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">30_000</span>;
<span class="keyword">public static final</span> <span class="class-name">String</span> DATABASE_URL = <span class="string">"jdbc:mysql://localhost:3306/db"</span>;

<span class="comment">// Blank finals: declared without value, initialized later (once!)</span>
<span class="keyword">final</span> <span class="keyword">int</span> assignedLater;
<span class="keyword">if</span> (condition) {
    assignedLater = <span class="number">10</span>;
} <span class="keyword">else</span> {
    assignedLater = <span class="number">20</span>;
}
<span class="comment">// Must be definitely assigned before use</span>

<span class="comment">// final with reference types: reference is constant, not the object!</span>
<span class="keyword">final</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; names = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
names.add(<span class="string">"Alice"</span>);  <span class="comment">// OK! Modifying the list, not the reference</span>
<span class="comment">// names = new ArrayList<>();  // ERROR! Cannot reassign final reference</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Naming Conventions and Best Practices</h2>

            <h3>Official Java Naming Conventions</h3>
            <table>
                <tr>
                    <th>Element</th>
                    <th>Convention</th>
                    <th>Examples</th>
                </tr>
                <tr>
                    <td>Variables</td>
                    <td>camelCase</td>
                    <td><code>userName</code>, <code>totalAmount</code>, <code>isActive</code></td>
                </tr>
                <tr>
                    <td>Constants</td>
                    <td>UPPER_SNAKE_CASE</td>
                    <td><code>MAX_SIZE</code>, <code>DEFAULT_TIMEOUT</code></td>
                </tr>
                <tr>
                    <td>Classes</td>
                    <td>PascalCase</td>
                    <td><code>UserAccount</code>, <code>HttpConnection</code></td>
                </tr>
                <tr>
                    <td>Methods</td>
                    <td>camelCase (verb)</td>
                    <td><code>calculateTotal()</code>, <code>getUserName()</code></td>
                </tr>
                <tr>
                    <td>Packages</td>
                    <td>lowercase</td>
                    <td><code>com.example.myapp</code></td>
                </tr>
            </table>

            <h3>Good vs Bad Variable Names</h3>
            <pre><code><span class="comment">// ❌ BAD: Vague, abbreviated, or misleading names</span>
<span class="keyword">int</span> x = <span class="number">42</span>;
<span class="keyword">int</span> n = <span class="number">10</span>;
<span class="keyword">int</span> data = <span class="number">100</span>;
<span class="class-name">String</span> s = <span class="string">"John"</span>;
<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;
<span class="keyword">int</span> temp = calculateSomething();
<span class="keyword">double</span> val = getPrice();

<span class="comment">// ✅ GOOD: Descriptive, intention-revealing names</span>
<span class="keyword">int</span> userAge = <span class="number">42</span>;
<span class="keyword">int</span> retryAttempts = <span class="number">10</span>;
<span class="keyword">int</span> maxConnectionsAllowed = <span class="number">100</span>;
<span class="class-name">String</span> customerName = <span class="string">"John"</span>;
<span class="keyword">boolean</span> isEmailVerified = <span class="keyword">true</span>;
<span class="keyword">int</span> averageOrderValue = calculateAverageOrderValue();
<span class="keyword">double</span> discountedPrice = getDiscountedPrice();

<span class="comment">// ❌ BAD: Hungarian notation (type in name)</span>
<span class="class-name">String</span> strName = <span class="string">"John"</span>;
<span class="keyword">int</span> iCount = <span class="number">5</span>;

<span class="comment">// ✅ GOOD: Let the type system handle types</span>
<span class="class-name">String</span> name = <span class="string">"John"</span>;
<span class="keyword">int</span> count = <span class="number">5</span>;

<span class="comment">// Boolean naming: use is, has, can, should prefixes</span>
<span class="keyword">boolean</span> isValid = <span class="keyword">true</span>;
<span class="keyword">boolean</span> hasPermission = <span class="keyword">false</span>;
<span class="keyword">boolean</span> canEdit = <span class="keyword">true</span>;
<span class="keyword">boolean</span> shouldRetry = <span class="keyword">false</span>;</code></pre>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls and How to Avoid Them</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Uninitialized Local Variables</div>
                <p>Local variables MUST be initialized before use. Instance variables get default values, but local variables do not.</p>
                <pre><code><span class="comment">// ❌ WRONG</span>
<span class="keyword">int</span> x;
<span class="class-name">System</span>.out.println(x);  <span class="comment">// ERROR: variable x might not have been initialized</span>

<span class="comment">// ✅ CORRECT</span>
<span class="keyword">int</span> x = <span class="number">0</span>;
<span class="class-name">System</span>.out.println(x);  <span class="comment">// OK: 0</span></code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Integer Division Truncation</div>
                <p>Division between two integers always produces an integer, truncating any decimal part.</p>
                <pre><code><span class="comment">// ❌ UNEXPECTED RESULT</span>
<span class="keyword">int</span> a = <span class="number">5</span>;
<span class="keyword">int</span> b = <span class="number">2</span>;
<span class="keyword">double</span> result = a / b;  <span class="comment">// 2.0, NOT 2.5!</span>

<span class="comment">// ✅ CORRECT: Cast at least one operand to double</span>
<span class="keyword">double</span> result = (<span class="keyword">double</span>) a / b;  <span class="comment">// 2.5</span>
<span class="keyword">double</span> result = a / (<span class="keyword">double</span>) b;  <span class="comment">// 2.5</span>
<span class="keyword">double</span> result = a / <span class="number">2.0</span>;         <span class="comment">// 2.5 (literal is double)</span></code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Integer Overflow</div>
                <p>When calculations exceed the type's range, they silently wrap around!</p>
                <pre><code><span class="comment">// ❌ SILENT OVERFLOW</span>
<span class="keyword">int</span> max = <span class="class-name">Integer</span>.MAX_VALUE;  <span class="comment">// 2,147,483,647</span>
<span class="keyword">int</span> overflow = max + <span class="number">1</span>;        <span class="comment">// -2,147,483,648 (wrapped!)</span>

<span class="comment">// ✅ SAFER: Use Math methods that throw on overflow (Java 8+)</span>
<span class="keyword">int</span> safe = <span class="class-name">Math</span>.addExact(max, <span class="number">1</span>);  <span class="comment">// Throws ArithmeticException</span>

<span class="comment">// ✅ SAFER: Use long for potentially large calculations</span>
<span class="keyword">long</span> factorial = <span class="number">1L</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) {
    factorial *= i;  <span class="comment">// Would overflow int at i=13</span>
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 4: String Comparison with ==</div>
                <pre><code><span class="comment">// ❌ WRONG: == compares references, not content</span>
<span class="class-name">String</span> s1 = <span class="string">"hello"</span>;
<span class="class-name">String</span> s2 = <span class="keyword">new</span> <span class="class-name">String</span>(<span class="string">"hello"</span>);
<span class="keyword">if</span> (s1 == s2) { }  <span class="comment">// FALSE! Different objects</span>

<span class="comment">// ✅ CORRECT: Use equals() for content comparison</span>
<span class="keyword">if</span> (s1.equals(s2)) { }  <span class="comment">// TRUE! Same content</span>

<span class="comment">// ✅ SAFER: Handle null with Objects.equals()</span>
<span class="keyword">if</span> (<span class="class-name">Objects</span>.equals(s1, s2)) { }  <span class="comment">// Null-safe comparison</span></code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 5: NullPointerException with Wrapper Unboxing</div>
                <pre><code><span class="comment">// ❌ DANGER: Null wrapper unboxing throws NPE</span>
<span class="class-name">Integer</span> maybeNull = <span class="keyword">null</span>;
<span class="keyword">int</span> value = maybeNull;  <span class="comment">// NullPointerException!</span>

<span class="comment">// ✅ SAFER: Check for null first</span>
<span class="keyword">int</span> value = (maybeNull != <span class="keyword">null</span>) ? maybeNull : <span class="number">0</span>;

<span class="comment">// ✅ SAFER: Use Optional (Java 8+)</span>
<span class="keyword">int</span> value = <span class="class-name">Optional</span>.ofNullable(maybeNull).orElse(<span class="number">0</span>);</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 6: Floating-Point Precision</div>
                <pre><code><span class="comment">// ❌ UNEXPECTED: Binary floating-point can't represent all decimals exactly</span>
<span class="keyword">double</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span>;
<span class="class-name">System</span>.out.println(sum);  <span class="comment">// 0.30000000000000004</span>
<span class="class-name">System</span>.out.println(sum == <span class="number">0.3</span>);  <span class="comment">// false!</span>

<span class="comment">// ✅ CORRECT: Compare with epsilon for "close enough"</span>
<span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-10</span>;
<span class="keyword">if</span> (<span class="class-name">Math</span>.abs(sum - <span class="number">0.3</span>) &lt; EPSILON) { }  <span class="comment">// true</span>

<span class="comment">// ✅ CORRECT: Use BigDecimal for financial calculations</span>
<span class="class-name">BigDecimal</span> a = <span class="keyword">new</span> <span class="class-name">BigDecimal</span>(<span class="string">"0.1"</span>);
<span class="class-name">BigDecimal</span> b = <span class="keyword">new</span> <span class="class-name">BigDecimal</span>(<span class="string">"0.2"</span>);
<span class="class-name">BigDecimal</span> result = a.add(b);  <span class="comment">// Exactly 0.3</span></code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Performance Considerations</h2>

            <h3>Primitive vs Wrapper Performance</h3>
            <pre><code><span class="comment">// Primitives are significantly faster than wrappers</span>
<span class="comment">// Benchmark: Sum 1 million numbers</span>

<span class="comment">// ✅ FAST: Using primitive int</span>
<span class="keyword">int</span> sumPrimitive = <span class="number">0</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) {
    sumPrimitive += i;
}
<span class="comment">// Approximately 2-3 ms</span>

<span class="comment">// ❌ SLOW: Using Integer wrapper (autoboxing overhead)</span>
<span class="class-name">Integer</span> sumWrapper = <span class="number">0</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) {
    sumWrapper += i;  <span class="comment">// Creates new Integer objects!</span>
}
<span class="comment">// Approximately 10-15x slower</span></code></pre>

            <h3>String Concatenation in Loops</h3>
            <pre><code><span class="comment">// ❌ SLOW: String concatenation in loops (creates many objects)</span>
<span class="class-name">String</span> result = <span class="string">""</span>;
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    result += <span class="string">"a"</span>;  <span class="comment">// Creates 10,000 String objects!</span>
}

<span class="comment">// ✅ FAST: Use StringBuilder for loop concatenation</span>
<span class="class-name">StringBuilder</span> sb = <span class="keyword">new</span> <span class="class-name">StringBuilder</span>();
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    sb.append(<span class="string">"a"</span>);  <span class="comment">// Modifies same buffer</span>
}
<span class="class-name">String</span> result = sb.toString();</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Memory Impact of Type Choices</div>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Memory</th>
                        <th>Notes</th>
                    </tr>
                    <tr>
                        <td><code>int</code></td>
                        <td>4 bytes</td>
                        <td>Use for most integers</td>
                    </tr>
                    <tr>
                        <td><code>Integer</code></td>
                        <td>16+ bytes</td>
                        <td>Object overhead + value</td>
                    </tr>
                    <tr>
                        <td><code>int[]</code> (1000)</td>
                        <td>~4 KB</td>
                        <td>Compact storage</td>
                    </tr>
                    <tr>
                        <td><code>Integer[]</code> (1000)</td>
                        <td>~20 KB</td>
                        <td>Reference + object overhead each</td>
                    </tr>
                </table>
            </div>
        </section>

        <section class="content-section">
            <h2>Common Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Q1: What's the difference between primitive and reference types?</div>
                <p><strong>Answer:</strong> Primitive types (int, boolean, etc.) store actual values directly in memory and are stored on the stack. Reference types store memory addresses pointing to objects on the heap. Primitives cannot be null and have no methods, while reference types can be null and have methods. When you assign a primitive to another variable, the value is copied. When you assign a reference, both variables point to the same object.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q2: Why does 0.1 + 0.2 != 0.3 in Java?</div>
                <p><strong>Answer:</strong> Java uses IEEE 754 binary floating-point representation, which cannot exactly represent many decimal fractions. 0.1 and 0.2 are stored as approximations, and their sum is slightly off from 0.3. For exact decimal arithmetic (like financial calculations), use BigDecimal with String constructors.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q3: What is autoboxing and unboxing?</div>
                <p><strong>Answer:</strong> Autoboxing is the automatic conversion from primitive to wrapper type (e.g., int to Integer). Unboxing is the reverse (Integer to int). Java does this automatically when needed, like adding an int to a List&lt;Integer&gt;. Be careful: unboxing a null wrapper throws NullPointerException.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q4: What's the difference between == and equals()?</div>
                <p><strong>Answer:</strong> For primitives, == compares values directly. For objects, == compares memory addresses (whether they're the same object). equals() compares object content (but must be properly overridden). Always use equals() for String comparison, and Objects.equals() for null-safe comparison.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q5: What happens when an int overflows?</div>
                <p><strong>Answer:</strong> Java integer arithmetic silently wraps around. Integer.MAX_VALUE + 1 equals Integer.MIN_VALUE. This can cause subtle bugs. Use Math.addExact() to throw ArithmeticException on overflow, or use long for calculations that might exceed int range.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q6: Can you explain the 'var' keyword introduced in Java 10?</div>
                <p><strong>Answer:</strong> 'var' enables local variable type inference, letting the compiler deduce the type from the initializer. It only works for local variables with initializers&mdash;not fields, parameters, or return types. It's still statically typed; the type is fixed at compile time. Use it when the type is obvious from context to reduce verbosity.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Troubleshooting Guide</h2>

            <h3>Error: "variable might not have been initialized"</h3>
            <pre><code><span class="comment">// Problem: Local variable used before initialization</span>
<span class="keyword">int</span> x;
<span class="class-name">System</span>.out.println(x);  <span class="comment">// Error!</span>

<span class="comment">// Solution: Initialize the variable</span>
<span class="keyword">int</span> x = <span class="number">0</span>;
<span class="class-name">System</span>.out.println(x);  <span class="comment">// Works</span></code></pre>

            <h3>Error: "incompatible types: possible lossy conversion"</h3>
            <pre><code><span class="comment">// Problem: Assigning larger type to smaller without cast</span>
<span class="keyword">double</span> d = <span class="number">3.14</span>;
<span class="keyword">int</span> i = d;  <span class="comment">// Error: possible lossy conversion from double to int</span>

<span class="comment">// Solution: Explicit cast (acknowledging potential data loss)</span>
<span class="keyword">int</span> i = (<span class="keyword">int</span>) d;  <span class="comment">// Works: i = 3</span></code></pre>

            <h3>Error: "integer number too large"</h3>
            <pre><code><span class="comment">// Problem: Large literal treated as int</span>
<span class="keyword">long</span> big = <span class="number">3000000000</span>;  <span class="comment">// Error: integer number too large</span>

<span class="comment">// Solution: Add L suffix for long literals</span>
<span class="keyword">long</span> big = <span class="number">3000000000L</span>;  <span class="comment">// Works</span></code></pre>

            <h3>Error: "bad operand types for binary operator"</h3>
            <pre><code><span class="comment">// Problem: Type mismatch in operation</span>
<span class="class-name">String</span> s = <span class="string">"5"</span>;
<span class="keyword">int</span> result = s + <span class="number">3</span>;  <span class="comment">// Error: String + int = String, not int</span>

<span class="comment">// Solution: Parse the string first</span>
<span class="keyword">int</span> result = <span class="class-name">Integer</span>.parseInt(s) + <span class="number">3</span>;  <span class="comment">// Works: 8</span></code></pre>

            <h3>Runtime: NumberFormatException</h3>
            <pre><code><span class="comment">// Problem: Parsing invalid number string</span>
<span class="keyword">int</span> x = <span class="class-name">Integer</span>.parseInt(<span class="string">"abc"</span>);  <span class="comment">// Throws NumberFormatException</span>

<span class="comment">// Solution: Validate input or catch exception</span>
<span class="keyword">try</span> {
    <span class="keyword">int</span> x = <span class="class-name">Integer</span>.parseInt(userInput);
} <span class="keyword">catch</span> (<span class="class-name">NumberFormatException</span> e) {
    <span class="class-name">System</span>.out.println(<span class="string">"Please enter a valid number"</span>);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="../java-versions/jdk-jre-jvm.html">JDK vs JRE vs JVM</a> &ndash; Understanding the Java runtime environment</li>
                <li><a href="optional.html">Optional Class</a> &ndash; Modern null handling in Java</li>
                <li><a href="generics.html">Generics</a> &ndash; Type-safe parameterized types</li>
                <li><a href="collections.html">Collections Framework</a> &ndash; Working with groups of objects</li>
                <li><a href="../advanced/jvm-internals.html">JVM Internals</a> &ndash; Deep dive into memory management</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="what-is-java.html" class="related-link">What is Java?</a>
                <a href="methods.html" class="related-link">Methods & Functions</a>
                <a href="oop-principles.html" class="related-link">OOP Principles</a>
                <a href="collections.html" class="related-link">Collections Framework</a>
                <a href="generics.html" class="related-link">Generics</a>
                <a href="optional.html" class="related-link">Optional Class</a>
                <a href="lambda-streams.html" class="related-link">Lambda & Streams</a>
                <a href="../advanced/jvm-internals.html" class="related-link">JVM Internals</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
