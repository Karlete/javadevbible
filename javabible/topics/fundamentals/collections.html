<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collections Framework - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Collections Framework
            </nav>
            <h1>Collections Framework</h1>
            <p class="topic-subtitle">Managing Groups of Objects Efficiently</p>
            <a href="../../index.html" class="back-btn">‚Üê Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <!-- What It Is -->
        <section class="content-section">
            <h2>What are Collections?</h2>
            <p>Imagine you need to store the names of all students in a classroom. You <em>could</em> create individual variables like this:</p>

            <pre><code><span class="class-name">String</span> student1 = <span class="string">"Alice"</span>;
<span class="class-name">String</span> student2 = <span class="string">"Bob"</span>;
<span class="class-name">String</span> student3 = <span class="string">"Charlie"</span>;
<span class="comment">// ... What if you have 100 students? This is terrible!</span></code></pre>

            <p>This approach is impractical! Instead, Java provides <strong>Collections</strong> - special objects that can hold multiple items together, like a container.</p>

            <pre><code><span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; students = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
students.add(<span class="string">"Alice"</span>);
students.add(<span class="string">"Bob"</span>);
students.add(<span class="string">"Charlie"</span>);
<span class="comment">// Add as many as you need!</span></code></pre>

            <h3>Real-World Analogies</h3>
            <ul>
                <li><strong>List (ArrayList)</strong> - Like a shopping list on paper. Items are in order, and you can have "milk" written twice.</li>
                <li><strong>Set (HashSet)</strong> - Like a bag of unique marbles. No duplicates allowed, and order doesn't matter.</li>
                <li><strong>Map (HashMap)</strong> - Like a phone book. Each name (key) has one phone number (value). You look up by name.</li>
                <li><strong>Queue</strong> - Like a line at a store. First person in line is served first (FIFO - First In, First Out).</li>
            </ul>

            <h3>Why Use Collections?</h3>
            <ul>
                <li><strong>Flexible size:</strong> Can grow or shrink as needed (unlike arrays with fixed size)</li>
                <li><strong>Built-in methods:</strong> Easy to add, remove, search, and sort</li>
                <li><strong>Different behaviors:</strong> Choose the right tool for the job (List, Set, Map)</li>
                <li><strong>Type-safe:</strong> With generics, you can ensure only certain types go in</li>
            </ul>

            <h2>The Collections Framework</h2>
            <p>The <strong>Java Collections Framework</strong> is a set of classes and interfaces that implement commonly used collection data structures. Think of it as a toolbox with different containers for different needs.</p>

            <div class="info-box note">
                <div class="info-box-title">Core Interfaces - Quick Reference</div>
                <ul>
                    <li><strong>List</strong> - Ordered collection that allows duplicates
                        <br><em>Example:</em> ArrayList, LinkedList
                        <br><em>Use when:</em> Order matters, need duplicates</li>
                    <li><strong>Set</strong> - Unordered collection with no duplicates
                        <br><em>Example:</em> HashSet, TreeSet
                        <br><em>Use when:</em> Need unique items only</li>
                    <li><strong>Map</strong> - Key-value pairs (no duplicate keys)
                        <br><em>Example:</em> HashMap, TreeMap
                        <br><em>Use when:</em> Need to look up values by key</li>
                    <li><strong>Queue</strong> - Collection for holding elements before processing
                        <br><em>Example:</em> LinkedList, PriorityQueue
                        <br><em>Use when:</em> Need FIFO processing</li>
                </ul>
            </div>

            <h3>Arrays vs Collections - What's the Difference?</h3>
            <table>
                <tr>
                    <th>Feature</th>
                    <th>Array</th>
                    <th>Collection (e.g., ArrayList)</th>
                </tr>
                <tr>
                    <td>Size</td>
                    <td>Fixed (cannot change)</td>
                    <td>Dynamic (grows/shrinks)</td>
                </tr>
                <tr>
                    <td>Types</td>
                    <td>Can hold primitives</td>
                    <td>Holds objects only (use Integer not int)</td>
                </tr>
                <tr>
                    <td>Methods</td>
                    <td>Just length property</td>
                    <td>Many useful methods (add, remove, contains)</td>
                </tr>
                <tr>
                    <td>Syntax</td>
                    <td>String[] arr = new String[5];</td>
                    <td>List&lt;String&gt; list = new ArrayList&lt;&gt;();</td>
                </tr>
            </table>

            <p>Now let's explore each collection type in detail with practical examples...</p>
        </section>

        <!-- List Interface -->
        <section class="content-section">
            <h2>List Interface</h2>
            <p>Lists maintain insertion order and allow duplicate elements. They provide positional access and search operations.</p>

            <h3>ArrayList - Dynamic Array Implementation</h3>
            <pre><code><span class="keyword">import</span> java.util.*;

<span class="keyword">public class</span> <span class="class-name">ListExample</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="comment">// Create an ArrayList</span>
        <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; fruits = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();

        <span class="comment">// Add elements</span>
        fruits.add(<span class="string">"Apple"</span>);
        fruits.add(<span class="string">"Banana"</span>);
        fruits.add(<span class="string">"Orange"</span>);
        fruits.add(<span class="string">"Apple"</span>);  <span class="comment">// Duplicates allowed</span>

        <span class="comment">// Access by index</span>
        <span class="class-name">String</span> first = fruits.get(<span class="number">0</span>);  <span class="comment">// "Apple"</span>

        <span class="comment">// Update element</span>
        fruits.set(<span class="number">1</span>, <span class="string">"Mango"</span>);

        <span class="comment">// Remove element</span>
        fruits.remove(<span class="string">"Orange"</span>);
        fruits.remove(<span class="number">0</span>);  <span class="comment">// Remove by index</span>

        <span class="comment">// Check if contains</span>
        <span class="keyword">boolean</span> hasApple = fruits.contains(<span class="string">"Apple"</span>);

        <span class="comment">// Iterate</span>
        <span class="keyword">for</span> (<span class="class-name">String</span> fruit : fruits) {
            <span class="class-name">System</span>.out.println(fruit);
        }

        <span class="comment">// Size</span>
        <span class="keyword">int</span> size = fruits.size();
    }
}</code></pre>

            <h3>LinkedList - Doubly-Linked List Implementation</h3>
            <pre><code><span class="comment">// Better for frequent insertions/deletions</span>
<span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; numbers = <span class="keyword">new</span> <span class="class-name">LinkedList</span>&lt;&gt;();
numbers.add(<span class="number">1</span>);
numbers.add(<span class="number">2</span>);
numbers.add(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// Insert at beginning - O(1)</span>

<span class="comment">// LinkedList also implements Queue</span>
<span class="class-name">LinkedList</span>&lt;<span class="class-name">String</span>&gt; queue = <span class="keyword">new</span> <span class="class-name">LinkedList</span>&lt;&gt;();
queue.addFirst(<span class="string">"First"</span>);
queue.addLast(<span class="string">"Last"</span>);
<span class="class-name">String</span> head = queue.removeFirst();</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">When to Use</div>
                <ul>
                    <li><strong>ArrayList</strong> - Fast random access, use when you access elements by index frequently</li>
                    <li><strong>LinkedList</strong> - Fast insertions/deletions, use for queue/deque operations</li>
                </ul>
            </div>
        </section>

        <!-- Set Interface -->
        <section class="content-section">
            <h2>Set Interface</h2>
            <p>Sets contain unique elements with no duplicates. They model the mathematical set abstraction.</p>

            <h3>HashSet - Fastest, No Order Guarantee</h3>
            <pre><code><span class="keyword">import</span> java.util.*;

<span class="class-name">Set</span>&lt;<span class="class-name">String</span>&gt; uniqueNames = <span class="keyword">new</span> <span class="class-name">HashSet</span>&lt;&gt;();

<span class="comment">// Add elements</span>
uniqueNames.add(<span class="string">"Alice"</span>);
uniqueNames.add(<span class="string">"Bob"</span>);
uniqueNames.add(<span class="string">"Alice"</span>);  <span class="comment">// Duplicate - will be ignored</span>

<span class="class-name">System</span>.out.println(uniqueNames.size());  <span class="comment">// 2, not 3</span>

<span class="comment">// Check membership - O(1) average</span>
<span class="keyword">if</span> (uniqueNames.contains(<span class="string">"Alice"</span>)) {
    <span class="class-name">System</span>.out.println(<span class="string">"Alice is in the set"</span>);
}

<span class="comment">// Remove</span>
uniqueNames.remove(<span class="string">"Bob"</span>);</code></pre>

            <h3>TreeSet - Sorted Order</h3>
            <pre><code><span class="comment">// Elements are sorted (natural order or custom comparator)</span>
<span class="class-name">Set</span>&lt;<span class="class-name">Integer</span>&gt; sortedNumbers = <span class="keyword">new</span> <span class="class-name">TreeSet</span>&lt;&gt;();
sortedNumbers.add(<span class="number">5</span>);
sortedNumbers.add(<span class="number">2</span>);
sortedNumbers.add(<span class="number">8</span>);
sortedNumbers.add(<span class="number">1</span>);

<span class="comment">// Iterates in sorted order: 1, 2, 5, 8</span>
<span class="keyword">for</span> (<span class="keyword">int</span> num : sortedNumbers) {
    <span class="class-name">System</span>.out.println(num);
}

<span class="comment">// Custom comparator</span>
<span class="class-name">Set</span>&lt;<span class="class-name">String</span>&gt; reverseSet = <span class="keyword">new</span> <span class="class-name">TreeSet</span>&lt;&gt;(<span class="class-name">Comparator</span>.reverseOrder());
reverseSet.add(<span class="string">"C"</span>);
reverseSet.add(<span class="string">"A"</span>);
reverseSet.add(<span class="string">"B"</span>);
<span class="comment">// Order: C, B, A</span></code></pre>

            <h3>LinkedHashSet - Insertion Order Preserved</h3>
            <pre><code><span class="comment">// Maintains insertion order</span>
<span class="class-name">Set</span>&lt;<span class="class-name">String</span>&gt; orderedSet = <span class="keyword">new</span> <span class="class-name">LinkedHashSet</span>&lt;&gt;();
orderedSet.add(<span class="string">"First"</span>);
orderedSet.add(<span class="string">"Second"</span>);
orderedSet.add(<span class="string">"Third"</span>);
<span class="comment">// Iterates in insertion order</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Set Comparison</div>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Order</th>
                        <th>Performance</th>
                        <th>Use When</th>
                    </tr>
                    <tr>
                        <td>HashSet</td>
                        <td>No order</td>
                        <td>Fastest (O(1))</td>
                        <td>You don't care about order</td>
                    </tr>
                    <tr>
                        <td>TreeSet</td>
                        <td>Sorted</td>
                        <td>O(log n)</td>
                        <td>You need sorted elements</td>
                    </tr>
                    <tr>
                        <td>LinkedHashSet</td>
                        <td>Insertion order</td>
                        <td>Slightly slower than HashSet</td>
                        <td>You need insertion order</td>
                    </tr>
                </table>
            </div>
        </section>

        <!-- Map Interface -->
        <section class="content-section">
            <h2>Map Interface</h2>
            <p>Maps store key-value pairs. Each key maps to exactly one value.</p>

            <h3>HashMap - Fast Key-Value Storage</h3>
            <pre><code><span class="keyword">import</span> java.util.*;

<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; ages = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();

<span class="comment">// Put key-value pairs</span>
ages.put(<span class="string">"Alice"</span>, <span class="number">25</span>);
ages.put(<span class="string">"Bob"</span>, <span class="number">30</span>);
ages.put(<span class="string">"Charlie"</span>, <span class="number">35</span>);

<span class="comment">// Get value by key</span>
<span class="keyword">int</span> aliceAge = ages.get(<span class="string">"Alice"</span>);  <span class="comment">// 25</span>

<span class="comment">// Check if key exists</span>
<span class="keyword">if</span> (ages.containsKey(<span class="string">"Bob"</span>)) {
    <span class="class-name">System</span>.out.println(<span class="string">"Bob's age: "</span> + ages.get(<span class="string">"Bob"</span>));
}

<span class="comment">// Get with default value</span>
<span class="keyword">int</span> age = ages.getOrDefault(<span class="string">"David"</span>, <span class="number">0</span>);  <span class="comment">// 0 if not found</span>

<span class="comment">// Update value</span>
ages.put(<span class="string">"Alice"</span>, <span class="number">26</span>);  <span class="comment">// Overwrites existing value</span>

<span class="comment">// Put if absent</span>
ages.putIfAbsent(<span class="string">"Eve"</span>, <span class="number">28</span>);

<span class="comment">// Remove</span>
ages.remove(<span class="string">"Charlie"</span>);

<span class="comment">// Iterate over entries</span>
<span class="keyword">for</span> (<span class="class-name">Map.Entry</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; entry : ages.entrySet()) {
    <span class="class-name">System</span>.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());
}

<span class="comment">// Iterate over keys only</span>
<span class="keyword">for</span> (<span class="class-name">String</span> name : ages.keySet()) {
    <span class="class-name">System</span>.out.println(name);
}

<span class="comment">// Iterate over values only</span>
<span class="keyword">for</span> (<span class="keyword">int</span> ageValue : ages.values()) {
    <span class="class-name">System</span>.out.println(ageValue);
}</code></pre>

            <h3>TreeMap - Sorted by Keys</h3>
            <pre><code><span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">String</span>&gt; sortedMap = <span class="keyword">new</span> <span class="class-name">TreeMap</span>&lt;&gt;();
sortedMap.put(<span class="string">"C"</span>, <span class="string">"Cat"</span>);
sortedMap.put(<span class="string">"A"</span>, <span class="string">"Apple"</span>);
sortedMap.put(<span class="string">"B"</span>, <span class="string">"Ball"</span>);
<span class="comment">// Keys are sorted: A, B, C</span></code></pre>

            <h3>LinkedHashMap - Insertion Order Preserved</h3>
            <pre><code><span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; orderedMap = <span class="keyword">new</span> <span class="class-name">LinkedHashMap</span>&lt;&gt;();
orderedMap.put(<span class="string">"First"</span>, <span class="number">1</span>);
orderedMap.put(<span class="string">"Second"</span>, <span class="number">2</span>);
<span class="comment">// Maintains insertion order</span></code></pre>

            <h3>Practical Example - Word Frequency Counter</h3>
            <pre><code><span class="keyword">public static</span> <span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; <span class="function">countWords</span>(<span class="class-name">String</span> text) {
    <span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; wordCount = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();
    <span class="class-name">String</span>[] words = text.toLowerCase().split(<span class="string">"\\s+"</span>);

    <span class="keyword">for</span> (<span class="class-name">String</span> word : words) {
        wordCount.put(word, wordCount.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);
    }

    <span class="keyword">return</span> wordCount;
}

<span class="comment">// Usage</span>
<span class="class-name">String</span> text = <span class="string">"hello world hello java world"</span>;
<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; counts = countWords(text);
<span class="comment">// {hello=2, world=2, java=1}</span></code></pre>
        </section>

        <!-- Common Operations -->
        <section class="content-section">
            <h2>Common Collection Operations</h2>

            <h3>Sorting Collections</h3>
            <pre><code><span class="keyword">import</span> java.util.*;

<span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; numbers = <span class="class-name">Arrays</span>.asList(<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>);

<span class="comment">// Sort in natural order</span>
<span class="class-name">Collections</span>.sort(numbers);
<span class="comment">// [1, 2, 5, 8, 9]</span>

<span class="comment">// Sort in reverse order</span>
<span class="class-name">Collections</span>.sort(numbers, <span class="class-name">Collections</span>.reverseOrder());

<span class="comment">// Sort with custom comparator</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; names = <span class="class-name">Arrays</span>.asList(<span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Charlie"</span>);
<span class="class-name">Collections</span>.sort(names, (a, b) -&gt; a.length() - b.length());
<span class="comment">// Sort by length</span></code></pre>

            <h3>Searching Collections</h3>
            <pre><code><span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; sortedList = <span class="class-name">Arrays</span>.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>);

<span class="comment">// Binary search (list must be sorted)</span>
<span class="keyword">int</span> index = <span class="class-name">Collections</span>.binarySearch(sortedList, <span class="number">5</span>);  <span class="comment">// 2</span>

<span class="comment">// Find max/min</span>
<span class="keyword">int</span> max = <span class="class-name">Collections</span>.max(sortedList);  <span class="comment">// 9</span>
<span class="keyword">int</span> min = <span class="class-name">Collections</span>.min(sortedList);  <span class="comment">// 1</span></code></pre>

            <h3>Converting Between Collections</h3>
            <pre><code><span class="comment">// List to Set</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; list = <span class="class-name">Arrays</span>.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>);
<span class="class-name">Set</span>&lt;<span class="class-name">String</span>&gt; set = <span class="keyword">new</span> <span class="class-name">HashSet</span>&lt;&gt;(list);  <span class="comment">// Removes duplicates</span>

<span class="comment">// Set to List</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; listFromSet = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;(set);

<span class="comment">// Array to List</span>
<span class="class-name">String</span>[] array = {<span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>};
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; listFromArray = <span class="class-name">Arrays</span>.asList(array);

<span class="comment">// List to Array</span>
<span class="class-name">String</span>[] arrayFromList = list.toArray(<span class="keyword">new</span> <span class="class-name">String</span>[<span class="number">0</span>]);</code></pre>
        </section>

        <!-- Why It Matters -->
        <section class="content-section">
            <h2>Why Collections Framework Matters</h2>
            <ul>
                <li><strong>Performance</strong> - Optimized implementations for different use cases</li>
                <li><strong>Consistency</strong> - Uniform API across different collection types</li>
                <li><strong>Reduced Programming Effort</strong> - Don't reinvent the wheel</li>
                <li><strong>Interoperability</strong> - Collections can be passed between different APIs</li>
            </ul>
        </section>

        <!-- Common Pitfalls -->
        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">ConcurrentModificationException</div>
                <pre><code><span class="comment">// DON'T: Modify collection while iterating</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;(<span class="class-name">Arrays</span>.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));
<span class="keyword">for</span> (<span class="class-name">String</span> s : list) {
    list.remove(s);  <span class="comment">// THROWS EXCEPTION!</span>
}

<span class="comment">// DO: Use Iterator.remove() or create new collection</span>
<span class="class-name">Iterator</span>&lt;<span class="class-name">String</span>&gt; it = list.iterator();
<span class="keyword">while</span> (it.hasNext()) {
    it.next();
    it.remove();  <span class="comment">// Safe</span>
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Null Keys and Values</div>
                <p>HashMap allows one null key and multiple null values. TreeMap doesn't allow null keys. Always check your requirements.</p>
            </div>
        </section>

        <!-- Related Topics -->
        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="generics.html" class="related-link">Generics</a>
                <a href="lambda-streams.html" class="related-link">Lambda & Streams</a>
                <a href="../advanced/multithreading.html" class="related-link">Thread-Safe Collections</a>
                <a href="exceptions.html" class="related-link">Exception Handling</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
