<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaces vs Abstract Classes - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Interfaces vs Abstract Classes
            </nav>
            <h1>Interfaces vs Abstract Classes</h1>
            <p class="topic-subtitle">Understanding the Differences and When to Use Each</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What Are Interfaces and Abstract Classes?</h2>
            <p>Interfaces and abstract classes are two mechanisms Java provides for achieving <strong>abstraction</strong>&mdash;the ability to define what something does without specifying how it does it. Both allow you to create contracts that other classes must fulfill, but they serve different purposes and have different capabilities. Understanding when to use each is crucial for good object-oriented design.</p>

            <p>At their core, both interfaces and abstract classes let you define method signatures without implementations (abstract methods), and both prevent direct instantiation&mdash;you can't create an object of an interface or abstract class directly. However, they differ fundamentally in their intent: <strong>interfaces define capabilities</strong> (what an object can do), while <strong>abstract classes define identities</strong> (what an object is).</p>

            <p>This distinction matters because it affects how classes relate to each other and how flexible your design becomes. A class can implement many interfaces (gaining multiple capabilities), but can only extend one abstract class (having one identity). This single inheritance limitation for classes but multiple inheritance for interfaces is Java's solution to the "diamond problem" that plagued languages like C++.</p>

            <h3>Historical Context: The Evolution of Interfaces</h3>
            <p>Java's interface concept was revolutionary when the language was introduced in 1995. While abstract classes existed in earlier languages like C++, Java's interfaces provided a cleaner way to achieve multiple inheritance of type without the complexity and ambiguity of multiple inheritance of implementation.</p>

            <p>Interfaces remained purely abstract (no implementation allowed) until Java 8 (2014), which introduced <strong>default methods</strong> and <strong>static methods</strong> in interfaces. This was a major evolution driven by the need to add methods to existing interfaces (like adding <code>forEach()</code> to <code>Iterable</code>) without breaking millions of existing implementations. Java 9 added <strong>private methods</strong> in interfaces, allowing code reuse within default methods. These changes blurred the line between interfaces and abstract classes, making the choice between them more nuanced.</p>

            <h3>The Big Picture: Where They Fit in Java Design</h3>
            <p>Interfaces and abstract classes are foundational to nearly every Java framework and library:</p>
            <ul>
                <li><strong>Java Collections Framework:</strong> Uses interfaces (<code>List</code>, <code>Set</code>, <code>Map</code>) for contracts and abstract classes (<code>AbstractList</code>, <code>AbstractSet</code>) for partial implementations</li>
                <li><strong>JDBC:</strong> Database connectivity through interfaces like <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code></li>
                <li><strong>Spring Framework:</strong> Heavy use of interfaces for dependency injection and loose coupling</li>
                <li><strong>Java I/O:</strong> Abstract classes like <code>InputStream</code> and <code>OutputStream</code> define the stream hierarchy</li>
            </ul>

            <pre><code><span class="comment">/*
 * Interfaces vs Abstract Classes: The Decision Tree
 * ==================================================
 *
 *  Need to define behavior for UNRELATED classes?
 *  │
 *  ├── YES → Use INTERFACE
 *  │         Example: Comparable, Serializable, Runnable
 *  │         (A String, Integer, and your custom class can all be Comparable)
 *  │
 *  └── NO → Classes are RELATED (share "is-a" relationship)?
 *           │
 *           ├── YES → Need to share CODE (fields, constructors, methods)?
 *           │         │
 *           │         ├── YES → Use ABSTRACT CLASS
 *           │         │         Example: Animal → Dog, Cat (share name, age, eat())
 *           │         │
 *           │         └── NO → Use INTERFACE
 *           │                  Example: Shape interface with area(), perimeter()
 *           │
 *           └── NO → Rethink your design!
 */</span></code></pre>

            <h3>Real-World Analogies</h3>
            <p><strong>Interface = Job Description / Contract / Certification</strong></p>
            <ul>
                <li>A job posting says: "Must be able to type, answer phones, file documents"</li>
                <li>It doesn't tell you HOW to do these things, just that you MUST be able to do them</li>
                <li>A person can have multiple certifications (implements multiple interfaces)</li>
                <li>Very different people (classes) can share the same certification</li>
            </ul>

            <p><strong>Abstract Class = Partial Template / Family Heritage</strong></p>
            <ul>
                <li>Think of a house blueprint that has some rooms finished (kitchen with cabinets) but others are blank (you decide bedroom layout)</li>
                <li>Or family traits: all members of the Smith family share certain characteristics (last name, family history) but have individual traits too</li>
                <li>You can only belong to ONE family (single inheritance)</li>
            </ul>

            <div class="info-box note">
                <div class="info-box-title">Key Differences at a Glance</div>
                <table>
                    <tr>
                        <th>Feature</th>
                        <th>Interface</th>
                        <th>Abstract Class</th>
                    </tr>
                    <tr>
                        <td><strong>Purpose</strong></td>
                        <td>Defines a CONTRACT (what to do)</td>
                        <td>Provides a TEMPLATE (what you are)</td>
                    </tr>
                    <tr>
                        <td><strong>Inheritance</strong></td>
                        <td>Can implement MANY interfaces</td>
                        <td>Can extend only ONE abstract class</td>
                    </tr>
                    <tr>
                        <td><strong>Methods (pre-Java 8)</strong></td>
                        <td>Only abstract (no body)</td>
                        <td>Both abstract and concrete</td>
                    </tr>
                    <tr>
                        <td><strong>Methods (Java 8+)</strong></td>
                        <td>Abstract, default, static, private (9+)</td>
                        <td>Any type of method</td>
                    </tr>
                    <tr>
                        <td><strong>Fields</strong></td>
                        <td>Only <code>public static final</code> constants</td>
                        <td>Any type of field</td>
                    </tr>
                    <tr>
                        <td><strong>Constructors</strong></td>
                        <td>Not allowed</td>
                        <td>Allowed (called via super)</td>
                    </tr>
                    <tr>
                        <td><strong>Keyword</strong></td>
                        <td><code>implements</code></td>
                        <td><code>extends</code></td>
                    </tr>
                    <tr>
                        <td><strong>Access Modifiers</strong></td>
                        <td>Methods implicitly public</td>
                        <td>Any access modifier</td>
                    </tr>
                </table>
            </div>
        </section>

        <section class="content-section">
            <h2>Interfaces In Depth</h2>
            <p>An interface is a completely abstract type that defines a set of methods (and constants) that implementing classes must provide. Interfaces establish a contract: "any class that implements me guarantees to have these capabilities."</p>

            <h3>Interface Syntax Evolution</h3>
            <pre><code><span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="comment">// CLASSIC INTERFACE (Pre-Java 8) - Pure abstraction</span>
<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="keyword">public interface</span> <span class="class-name">Drawable</span> {
    <span class="comment">// Constants (implicitly public static final)</span>
    <span class="keyword">int</span> DEFAULT_COLOR = <span class="number">0x000000</span>;  <span class="comment">// Black</span>

    <span class="comment">// Abstract methods (implicitly public abstract)</span>
    <span class="keyword">void</span> <span class="function">draw</span>();
    <span class="keyword">void</span> <span class="function">resize</span>(<span class="keyword">int</span> width, <span class="keyword">int</span> height);
}

<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="comment">// MODERN INTERFACE (Java 8+) - With default and static methods</span>
<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="keyword">public interface</span> <span class="class-name">Drawable</span> {
    <span class="comment">// Constants</span>
    <span class="keyword">int</span> DEFAULT_COLOR = <span class="number">0x000000</span>;

    <span class="comment">// Abstract method - implementors MUST provide</span>
    <span class="keyword">void</span> <span class="function">draw</span>();

    <span class="comment">// Default method (Java 8+) - provides default implementation</span>
    <span class="comment">// Implementors CAN override, but don't have to</span>
    <span class="keyword">default void</span> <span class="function">display</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Displaying drawable..."</span>);
        draw();
    }

    <span class="comment">// Default method with common behavior</span>
    <span class="keyword">default void</span> <span class="function">hide</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Hiding drawable"</span>);
    }

    <span class="comment">// Static method (Java 8+) - utility method on the interface itself</span>
    <span class="keyword">static</span> <span class="class-name">Drawable</span> <span class="function">createEmpty</span>() {
        <span class="keyword">return</span> () -> {};  <span class="comment">// Lambda for functional interface</span>
    }

    <span class="comment">// Static utility method</span>
    <span class="keyword">static boolean</span> <span class="function">isVisible</span>(<span class="class-name">Drawable</span> d) {
        <span class="keyword">return</span> d != <span class="keyword">null</span>;
    }
}

<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="comment">// JAVA 9+ INTERFACE - With private methods for code reuse</span>
<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="keyword">public interface</span> <span class="class-name">Logger</span> {
    <span class="keyword">void</span> <span class="function">log</span>(<span class="class-name">String</span> message);

    <span class="keyword">default void</span> <span class="function">logInfo</span>(<span class="class-name">String</span> message) {
        log(formatMessage(<span class="string">"INFO"</span>, message));  <span class="comment">// Uses private method</span>
    }

    <span class="keyword">default void</span> <span class="function">logError</span>(<span class="class-name">String</span> message) {
        log(formatMessage(<span class="string">"ERROR"</span>, message));  <span class="comment">// Uses private method</span>
    }

    <span class="keyword">default void</span> <span class="function">logWarning</span>(<span class="class-name">String</span> message) {
        log(formatMessage(<span class="string">"WARNING"</span>, message));
    }

    <span class="comment">// Private method (Java 9+) - for code reuse within default methods</span>
    <span class="comment">// NOT visible to implementing classes</span>
    <span class="keyword">private</span> <span class="class-name">String</span> <span class="function">formatMessage</span>(<span class="class-name">String</span> level, <span class="class-name">String</span> message) {
        <span class="keyword">return</span> <span class="string">"["</span> + level + <span class="string">"] "</span> + <span class="class-name">java.time.LocalDateTime</span>.now() + <span class="string">": "</span> + message;
    }

    <span class="comment">// Private static method (Java 9+)</span>
    <span class="keyword">private static</span> <span class="class-name">String</span> <span class="function">getTimestamp</span>() {
        <span class="keyword">return</span> <span class="class-name">java.time.Instant</span>.now().toString();
    }
}</code></pre>

            <h3>Multiple Interface Implementation</h3>
            <pre><code><span class="comment">// A class can implement MULTIPLE interfaces - this is Java's answer to</span>
<span class="comment">// multiple inheritance (of type, not implementation)</span>

<span class="keyword">interface</span> <span class="class-name">Flyable</span> {
    <span class="keyword">void</span> <span class="function">fly</span>();
    <span class="keyword">default int</span> <span class="function">getMaxAltitude</span>() { <span class="keyword">return</span> <span class="number">10000</span>; }
}

<span class="keyword">interface</span> <span class="class-name">Swimmable</span> {
    <span class="keyword">void</span> <span class="function">swim</span>();
    <span class="keyword">default int</span> <span class="function">getMaxDepth</span>() { <span class="keyword">return</span> <span class="number">100</span>; }
}

<span class="keyword">interface</span> <span class="class-name">Walkable</span> {
    <span class="keyword">void</span> <span class="function">walk</span>();
}

<span class="comment">// Duck can fly, swim, AND walk!</span>
<span class="keyword">public class</span> <span class="class-name">Duck</span> <span class="keyword">implements</span> <span class="class-name">Flyable</span>, <span class="class-name">Swimmable</span>, <span class="class-name">Walkable</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;

    <span class="keyword">public</span> <span class="function">Duck</span>(<span class="class-name">String</span> name) {
        <span class="keyword">this</span>.name = name;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">fly</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is flying"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">swim</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is swimming"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">walk</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is walking"</span>);
    }
}

<span class="comment">// Penguin can swim and walk, but NOT fly</span>
<span class="keyword">public class</span> <span class="class-name">Penguin</span> <span class="keyword">implements</span> <span class="class-name">Swimmable</span>, <span class="class-name">Walkable</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">swim</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Penguin swimming gracefully"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">walk</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Penguin waddling"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public int</span> <span class="function">getMaxDepth</span>() {
        <span class="keyword">return</span> <span class="number">500</span>;  <span class="comment">// Penguins can dive deep!</span>
    }
}

<span class="comment">// Airplane can fly but is NOT an animal</span>
<span class="keyword">public class</span> <span class="class-name">Airplane</span> <span class="keyword">implements</span> <span class="class-name">Flyable</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">fly</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Airplane taking off"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public int</span> <span class="function">getMaxAltitude</span>() {
        <span class="keyword">return</span> <span class="number">40000</span>;  <span class="comment">// Commercial jets fly high</span>
    }
}

<span class="comment">// The beauty: process ANY flyable thing uniformly</span>
<span class="keyword">public void</span> <span class="function">takeOff</span>(<span class="class-name">Flyable</span> f) {
    f.fly();  <span class="comment">// Works with Duck, Airplane, or any future Flyable</span>
}</code></pre>

            <h3>Functional Interfaces and Lambdas</h3>
            <pre><code><span class="comment">// A functional interface has exactly ONE abstract method</span>
<span class="comment">// Can be used with lambda expressions</span>

<span class="annotation">@FunctionalInterface</span>  <span class="comment">// Optional but recommended - compiler enforces single abstract method</span>
<span class="keyword">public interface</span> <span class="class-name">Processor</span>&lt;<span class="class-name">T</span>&gt; {
    <span class="class-name">T</span> <span class="function">process</span>(<span class="class-name">T</span> input);

    <span class="comment">// Default and static methods don't count against "single abstract method" rule</span>
    <span class="keyword">default</span> <span class="class-name">Processor</span>&lt;<span class="class-name">T</span>&gt; <span class="function">andThen</span>(<span class="class-name">Processor</span>&lt;<span class="class-name">T</span>&gt; after) {
        <span class="keyword">return</span> input -> after.process(<span class="keyword">this</span>.process(input));
    }
}

<span class="comment">// Usage with lambda</span>
<span class="class-name">Processor</span>&lt;<span class="class-name">String</span>&gt; trimmer = s -> s.trim();
<span class="class-name">Processor</span>&lt;<span class="class-name">String</span>&gt; upper = s -> s.toUpperCase();
<span class="class-name">Processor</span>&lt;<span class="class-name">String</span>&gt; combined = trimmer.andThen(upper);

<span class="class-name">String</span> result = combined.process(<span class="string">"  hello world  "</span>);  <span class="comment">// "HELLO WORLD"</span>

<span class="comment">// Built-in functional interfaces in java.util.function:</span>
<span class="comment">// - Function&lt;T,R&gt;    : T -> R</span>
<span class="comment">// - Consumer&lt;T&gt;      : T -> void</span>
<span class="comment">// - Supplier&lt;T&gt;      : () -> T</span>
<span class="comment">// - Predicate&lt;T&gt;     : T -> boolean</span>
<span class="comment">// - BiFunction&lt;T,U,R&gt;: (T, U) -> R</span></code></pre>

            <div class="info-box tip">
                <div class="info-box-title">When to Use Interfaces</div>
                <ul>
                    <li><strong>Defining capabilities:</strong> Comparable, Serializable, Runnable</li>
                    <li><strong>Unrelated classes need same behavior:</strong> Both Duck and Airplane can Fly</li>
                    <li><strong>Multiple inheritance of type:</strong> Duck implements Flyable, Swimmable, Walkable</li>
                    <li><strong>API contracts:</strong> List, Set, Map define what collections can do</li>
                    <li><strong>Dependency injection:</strong> Program to interface, inject implementation</li>
                    <li><strong>Callback/strategy patterns:</strong> Pass behavior as parameter</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Abstract Classes In Depth</h2>
            <p>An abstract class is a class that cannot be instantiated and may contain both abstract methods (without implementation) and concrete methods (with implementation). Abstract classes serve as templates for related classes, providing shared code while requiring subclasses to implement specific behaviors.</p>

            <h3>Abstract Class Syntax</h3>
            <pre><code><span class="keyword">public abstract class</span> <span class="class-name">Animal</span> {
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// INSTANCE FIELDS - Can have state (interfaces cannot)</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">protected</span> <span class="class-name">String</span> name;
    <span class="keyword">protected</span> <span class="keyword">int</span> age;
    <span class="keyword">private</span> <span class="class-name">String</span> id;  <span class="comment">// Can have private fields</span>

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// CONSTRUCTORS - Can have constructors (interfaces cannot)</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public</span> <span class="function">Animal</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
        <span class="keyword">this</span>.id = generateId();
    }

    <span class="comment">// Overloaded constructor</span>
    <span class="keyword">public</span> <span class="function">Animal</span>(<span class="class-name">String</span> name) {
        <span class="keyword">this</span>(name, <span class="number">0</span>);  <span class="comment">// Constructor chaining</span>
    }

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// ABSTRACT METHODS - Must be implemented by concrete subclasses</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public abstract void</span> <span class="function">makeSound</span>();  <span class="comment">// Each animal sounds different</span>
    <span class="keyword">public abstract void</span> <span class="function">move</span>();       <span class="comment">// Each animal moves differently</span>
    <span class="keyword">protected abstract</span> <span class="class-name">String</span> <span class="function">getSpecies</span>();  <span class="comment">// Can have non-public abstract methods</span>

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// CONCRETE METHODS - Shared implementation inherited by all subclasses</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public void</span> <span class="function">eat</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is eating"</span>);
    }

    <span class="keyword">public void</span> <span class="function">sleep</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" is sleeping for 8 hours"</span>);
    }

    <span class="keyword">public void</span> <span class="function">displayInfo</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Animal: "</span> + name + <span class="string">", Age: "</span> + age + <span class="string">", Species: "</span> + getSpecies());
    }

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// FINAL METHODS - Cannot be overridden by subclasses</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public final</span> <span class="class-name">String</span> <span class="function">getId</span>() {
        <span class="keyword">return</span> id;  <span class="comment">// ID generation is fixed, subclasses can't change it</span>
    }

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// PRIVATE METHODS - Internal helpers not visible to subclasses</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">private</span> <span class="class-name">String</span> <span class="function">generateId</span>() {
        <span class="keyword">return</span> <span class="string">"ANIMAL-"</span> + <span class="class-name">System</span>.currentTimeMillis();
    }

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// STATIC METHODS - Belong to class, not instances</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public static boolean</span> <span class="function">isAdult</span>(<span class="class-name">Animal</span> animal) {
        <span class="keyword">return</span> animal.age >= <span class="number">2</span>;
    }

    <span class="comment">// Getters</span>
    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getName</span>() { <span class="keyword">return</span> name; }
    <span class="keyword">public int</span> <span class="function">getAge</span>() { <span class="keyword">return</span> age; }
}

<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="comment">// CONCRETE SUBCLASS - Implements all abstract methods</span>
<span class="comment">// ═══════════════════════════════════════════════════════════════════════════</span>
<span class="keyword">public class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> breed;

    <span class="keyword">public</span> <span class="function">Dog</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age, <span class="class-name">String</span> breed) {
        <span class="keyword">super</span>(name, age);  <span class="comment">// MUST call parent constructor</span>
        <span class="keyword">this</span>.breed = breed;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">makeSound</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" barks: Woof! Woof!"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">move</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" runs on four legs"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="class-name">String</span> <span class="function">getSpecies</span>() {
        <span class="keyword">return</span> <span class="string">"Canis familiaris"</span>;
    }

    <span class="comment">// Dog-specific method</span>
    <span class="keyword">public void</span> <span class="function">fetch</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" fetches the ball!"</span>);
    }
}

<span class="keyword">public class</span> <span class="class-name">Bird</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> wingspan;

    <span class="keyword">public</span> <span class="function">Bird</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age, <span class="keyword">double</span> wingspan) {
        <span class="keyword">super</span>(name, age);
        <span class="keyword">this</span>.wingspan = wingspan;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">makeSound</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" chirps: Tweet tweet!"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">move</span>() {
        <span class="class-name">System</span>.out.println(name + <span class="string">" flies with "</span> + wingspan + <span class="string">"m wingspan"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="class-name">String</span> <span class="function">getSpecies</span>() {
        <span class="keyword">return</span> <span class="string">"Aves"</span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">sleep</span>() {
        <span class="comment">// Override to customize</span>
        <span class="class-name">System</span>.out.println(name + <span class="string">" sleeps in a nest"</span>);
    }
}</code></pre>

            <h3>Template Method Pattern</h3>
            <pre><code><span class="comment">// Abstract classes are perfect for the Template Method pattern</span>
<span class="comment">// Define the skeleton of an algorithm, let subclasses fill in the steps</span>

<span class="keyword">public abstract class</span> <span class="class-name">DataProcessor</span> {
    <span class="comment">// TEMPLATE METHOD - final so subclasses can't change the algorithm</span>
    <span class="keyword">public final void</span> <span class="function">process</span>() {
        openConnection();
        readData();
        processData();       <span class="comment">// Abstract - subclasses customize</span>
        writeResults();      <span class="comment">// Abstract - subclasses customize</span>
        closeConnection();
    }

    <span class="comment">// Concrete methods - same for all subclasses</span>
    <span class="keyword">private void</span> <span class="function">openConnection</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Opening connection..."</span>);
    }

    <span class="keyword">private void</span> <span class="function">closeConnection</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Closing connection..."</span>);
    }

    <span class="keyword">protected void</span> <span class="function">readData</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Reading data..."</span>);
    }

    <span class="comment">// Abstract methods - subclasses MUST implement</span>
    <span class="keyword">protected abstract void</span> <span class="function">processData</span>();
    <span class="keyword">protected abstract void</span> <span class="function">writeResults</span>();
}

<span class="keyword">public class</span> <span class="class-name">CSVProcessor</span> <span class="keyword">extends</span> <span class="class-name">DataProcessor</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">processData</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Parsing CSV rows..."</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">writeResults</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Writing CSV output..."</span>);
    }
}

<span class="keyword">public class</span> <span class="class-name">JSONProcessor</span> <span class="keyword">extends</span> <span class="class-name">DataProcessor</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">processData</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Parsing JSON objects..."</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">writeResults</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Writing JSON output..."</span>);
    }
}</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">When to Use Abstract Classes</div>
                <ul>
                    <li><strong>Sharing code:</strong> Common implementation among related classes</li>
                    <li><strong>Non-static/non-final fields:</strong> Need instance variables</li>
                    <li><strong>Constructors:</strong> Complex initialization logic</li>
                    <li><strong>Template Method pattern:</strong> Define algorithm skeleton</li>
                    <li><strong>Protected members:</strong> Need package/subclass access</li>
                    <li><strong>"Is-a" relationship:</strong> Dog IS-A Animal, not just "can do animal things"</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Combining Interfaces and Abstract Classes</h2>
            <p>The most powerful designs often combine interfaces and abstract classes. This is exactly what the Java Collections Framework does.</p>

            <pre><code><span class="comment">/*
 * Real-World Pattern: Collections Framework Design
 * =================================================
 *
 *  INTERFACE (contract)           ABSTRACT CLASS (partial impl)      CONCRETE (full impl)
 *  ==================            =========================           ===================
 *
 *       List&lt;E&gt;                     AbstractList&lt;E&gt;                   ArrayList&lt;E&gt;
 *         │                              │                              LinkedList&lt;E&gt;
 *         │                              │
 *         └──────────────────────────────┴──────────────────────────────────┘
 *
 *  Why this design?
 *  - Interface: defines what ALL lists must do (add, get, remove, etc.)
 *  - Abstract class: provides common implementation (indexOf, equals, hashCode)
 *  - Concrete classes: provide specific storage mechanisms
 */</span>

<span class="comment">// Let's recreate this pattern for a messaging system</span>

<span class="comment">// STEP 1: Define the capability (interface)</span>
<span class="keyword">public interface</span> <span class="class-name">MessageSender</span> {
    <span class="keyword">void</span> <span class="function">send</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message);
    <span class="keyword">boolean</span> <span class="function">isAvailable</span>();

    <span class="keyword">default void</span> <span class="function">sendIfAvailable</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message) {
        <span class="keyword">if</span> (isAvailable()) {
            send(recipient, message);
        } <span class="keyword">else</span> {
            <span class="class-name">System</span>.out.println(<span class="string">"Service unavailable"</span>);
        }
    }
}

<span class="comment">// STEP 2: Provide shared implementation (abstract class)</span>
<span class="keyword">public abstract class</span> <span class="class-name">AbstractMessageSender</span> <span class="keyword">implements</span> <span class="class-name">MessageSender</span> {
    <span class="keyword">protected</span> <span class="class-name">String</span> senderName;
    <span class="keyword">protected</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; sentMessages = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();

    <span class="keyword">public</span> <span class="function">AbstractMessageSender</span>(<span class="class-name">String</span> senderName) {
        <span class="keyword">this</span>.senderName = senderName;
    }

    <span class="comment">// Template method</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public final void</span> <span class="function">send</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message) {
        validateRecipient(recipient);
        <span class="class-name">String</span> formattedMessage = formatMessage(message);
        doSend(recipient, formattedMessage);  <span class="comment">// Abstract - subclass provides</span>
        logMessage(recipient, formattedMessage);
    }

    <span class="comment">// Shared implementation</span>
    <span class="keyword">protected void</span> <span class="function">validateRecipient</span>(<span class="class-name">String</span> recipient) {
        <span class="keyword">if</span> (recipient == <span class="keyword">null</span> || recipient.isEmpty()) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Invalid recipient"</span>);
        }
    }

    <span class="keyword">protected</span> <span class="class-name">String</span> <span class="function">formatMessage</span>(<span class="class-name">String</span> message) {
        <span class="keyword">return</span> <span class="string">"["</span> + senderName + <span class="string">"] "</span> + message;
    }

    <span class="keyword">protected void</span> <span class="function">logMessage</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message) {
        sentMessages.add(recipient + <span class="string">": "</span> + message);
    }

    <span class="comment">// Abstract method - subclasses implement actual sending</span>
    <span class="keyword">protected abstract void</span> <span class="function">doSend</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message);

    <span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; <span class="function">getSentMessages</span>() {
        <span class="keyword">return new</span> <span class="class-name">ArrayList</span>&lt;&gt;(sentMessages);  <span class="comment">// Defensive copy</span>
    }
}

<span class="comment">// STEP 3: Concrete implementations</span>
<span class="keyword">public class</span> <span class="class-name">EmailSender</span> <span class="keyword">extends</span> <span class="class-name">AbstractMessageSender</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> smtpServer;

    <span class="keyword">public</span> <span class="function">EmailSender</span>(<span class="class-name">String</span> senderName, <span class="class-name">String</span> smtpServer) {
        <span class="keyword">super</span>(senderName);
        <span class="keyword">this</span>.smtpServer = smtpServer;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">doSend</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message) {
        <span class="class-name">System</span>.out.println(<span class="string">"Sending email via "</span> + smtpServer + <span class="string">" to "</span> + recipient);
        <span class="class-name">System</span>.out.println(<span class="string">"Content: "</span> + message);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public boolean</span> <span class="function">isAvailable</span>() {
        <span class="comment">// Check SMTP server connectivity</span>
        <span class="keyword">return true</span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">validateRecipient</span>(<span class="class-name">String</span> recipient) {
        <span class="keyword">super</span>.validateRecipient(recipient);
        <span class="keyword">if</span> (!recipient.contains(<span class="string">"@"</span>)) {
            <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>(<span class="string">"Invalid email address"</span>);
        }
    }
}

<span class="keyword">public class</span> <span class="class-name">SMSSender</span> <span class="keyword">extends</span> <span class="class-name">AbstractMessageSender</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> apiKey;

    <span class="keyword">public</span> <span class="function">SMSSender</span>(<span class="class-name">String</span> senderName, <span class="class-name">String</span> apiKey) {
        <span class="keyword">super</span>(senderName);
        <span class="keyword">this</span>.apiKey = apiKey;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected void</span> <span class="function">doSend</span>(<span class="class-name">String</span> recipient, <span class="class-name">String</span> message) {
        <span class="class-name">System</span>.out.println(<span class="string">"Sending SMS to "</span> + recipient);
        <span class="class-name">System</span>.out.println(<span class="string">"Content: "</span> + message.substring(<span class="number">0</span>, <span class="class-name">Math</span>.min(message.length(), <span class="number">160</span>)));
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public boolean</span> <span class="function">isAvailable</span>() {
        <span class="comment">// Check SMS API availability</span>
        <span class="keyword">return</span> apiKey != <span class="keyword">null</span>;
    }
}

<span class="comment">// Usage - polymorphism in action</span>
<span class="class-name">MessageSender</span> email = <span class="keyword">new</span> <span class="class-name">EmailSender</span>(<span class="string">"System"</span>, <span class="string">"smtp.example.com"</span>);
<span class="class-name">MessageSender</span> sms = <span class="keyword">new</span> <span class="class-name">SMSSender</span>(<span class="string">"System"</span>, <span class="string">"api-key-123"</span>);

<span class="comment">// Same code works with both!</span>
<span class="keyword">for</span> (<span class="class-name">MessageSender</span> sender : <span class="class-name">Arrays</span>.asList(email, sms)) {
    sender.sendIfAvailable(<span class="string">"user@example.com"</span>, <span class="string">"Hello!"</span>);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>The Diamond Problem and Default Methods</h2>
            <p>Java 8's default methods introduced potential ambiguity when a class implements multiple interfaces with the same default method. Java has specific rules to resolve this.</p>

            <pre><code><span class="keyword">interface</span> <span class="class-name">A</span> {
    <span class="keyword">default void</span> <span class="function">hello</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Hello from A"</span>);
    }
}

<span class="keyword">interface</span> <span class="class-name">B</span> {
    <span class="keyword">default void</span> <span class="function">hello</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Hello from B"</span>);
    }
}

<span class="comment">// Class implements both - which hello() is used?</span>
<span class="keyword">public class</span> <span class="class-name">C</span> <span class="keyword">implements</span> <span class="class-name">A</span>, <span class="class-name">B</span> {
    <span class="comment">// MUST override to resolve ambiguity</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">hello</span>() {
        <span class="comment">// Option 1: Provide your own implementation</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Hello from C"</span>);

        <span class="comment">// Option 2: Explicitly choose one interface's version</span>
        <span class="class-name">A</span>.<span class="keyword">super</span>.hello();  <span class="comment">// Calls A's default</span>

        <span class="comment">// Option 3: Call both</span>
        <span class="class-name">A</span>.<span class="keyword">super</span>.hello();
        <span class="class-name">B</span>.<span class="keyword">super</span>.hello();
    }
}

<span class="comment">/*
 * Diamond Problem Resolution Rules:
 * =================================
 *
 * 1. Class wins over interface
 *    - If a superclass provides a method, it beats interface defaults
 *
 * 2. Sub-interface wins over super-interface
 *    - More specific interface wins
 *
 * 3. No winner = Must override
 *    - If rules 1 and 2 don't resolve, class must explicitly override
 */</span>

<span class="comment">// Example: Class wins over interface</span>
<span class="keyword">class</span> <span class="class-name">Parent</span> {
    <span class="keyword">public void</span> <span class="function">hello</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Hello from Parent class"</span>);
    }
}

<span class="keyword">class</span> <span class="class-name">Child</span> <span class="keyword">extends</span> <span class="class-name">Parent</span> <span class="keyword">implements</span> <span class="class-name">A</span> {
    <span class="comment">// No override needed - Parent.hello() wins over A.hello()</span>
}

<span class="keyword">new</span> <span class="class-name">Child</span>().hello();  <span class="comment">// "Hello from Parent class"</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Best Practices</h2>

            <h3>Interface Design Guidelines</h3>
            <ul>
                <li><strong>Keep interfaces small and focused:</strong> Interface Segregation Principle</li>
                <li><strong>Use <code>@FunctionalInterface</code>:</strong> For single-method interfaces used with lambdas</li>
                <li><strong>Use default methods sparingly:</strong> For optional methods or gradual API evolution</li>
                <li><strong>Don't use interfaces for constants:</strong> Use a final class or enum instead</li>
                <li><strong>Document contracts clearly:</strong> What preconditions, postconditions, invariants?</li>
            </ul>

            <h3>Abstract Class Design Guidelines</h3>
            <ul>
                <li><strong>Design for inheritance:</strong> Document what can/should be overridden</li>
                <li><strong>Use <code>final</code> for non-overridable methods:</strong> Especially template methods</li>
                <li><strong>Prefer protected over public:</strong> For internal API used by subclasses</li>
                <li><strong>Call abstract methods from constructor carefully:</strong> Object isn't fully initialized</li>
                <li><strong>Keep hierarchies shallow:</strong> Prefer composition over deep inheritance</li>
            </ul>

            <pre><code><span class="comment">// ❌ BAD: Interface used for constants (anti-pattern)</span>
<span class="keyword">public interface</span> <span class="class-name">Constants</span> {
    <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;
    <span class="class-name">String</span> PREFIX = <span class="string">"APP_"</span>;
}
<span class="keyword">class</span> <span class="class-name">MyClass</span> <span class="keyword">implements</span> <span class="class-name">Constants</span> { ... }  <span class="comment">// Pollutes class hierarchy</span>

<span class="comment">// ✅ GOOD: Use final class for constants</span>
<span class="keyword">public final class</span> <span class="class-name">Constants</span> {
    <span class="keyword">public static final int</span> MAX_SIZE = <span class="number">100</span>;
    <span class="keyword">public static final</span> <span class="class-name">String</span> PREFIX = <span class="string">"APP_"</span>;
    <span class="keyword">private</span> <span class="function">Constants</span>() {}  <span class="comment">// Prevent instantiation</span>
}

<span class="comment">// ❌ BAD: Calling abstract method from constructor</span>
<span class="keyword">public abstract class</span> <span class="class-name">Dangerous</span> {
    <span class="keyword">public</span> <span class="function">Dangerous</span>() {
        initialize();  <span class="comment">// DANGER: Calls subclass method before subclass is initialized!</span>
    }
    <span class="keyword">protected abstract void</span> <span class="function">initialize</span>();
}

<span class="comment">// ✅ GOOD: Use factory method or separate initialization</span>
<span class="keyword">public abstract class</span> <span class="class-name">Safe</span> {
    <span class="keyword">public static</span> <span class="class-name">Safe</span> <span class="function">create</span>() {
        <span class="class-name">Safe</span> instance = <span class="keyword">new</span> <span class="class-name">ConcreteImplementation</span>();
        instance.initialize();
        <span class="keyword">return</span> instance;
    }
    <span class="keyword">protected abstract void</span> <span class="function">initialize</span>();
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Cannot Instantiate Abstract Types</div>
                <pre><code><span class="comment">// ❌ ERROR: Cannot instantiate</span>
<span class="class-name">Animal</span> animal = <span class="keyword">new</span> <span class="class-name">Animal</span>(<span class="string">"Rex"</span>, <span class="number">5</span>);  <span class="comment">// Abstract class</span>
<span class="class-name">Drawable</span> d = <span class="keyword">new</span> <span class="class-name">Drawable</span>();           <span class="comment">// Interface</span>

<span class="comment">// ✅ CORRECT: Instantiate concrete implementations</span>
<span class="class-name">Animal</span> dog = <span class="keyword">new</span> <span class="class-name">Dog</span>(<span class="string">"Rex"</span>, <span class="number">5</span>, <span class="string">"Labrador"</span>);
<span class="class-name">Drawable</span> circle = <span class="keyword">new</span> <span class="class-name">Circle</span>();

<span class="comment">// ✅ CORRECT: Anonymous class (creates unnamed subclass)</span>
<span class="class-name">Drawable</span> anonymous = <span class="keyword">new</span> <span class="class-name">Drawable</span>() {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">draw</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Drawing"</span>);
    }
};</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Forgetting to Call super Constructor</div>
                <pre><code><span class="keyword">public abstract class</span> <span class="class-name">Vehicle</span> {
    <span class="keyword">protected</span> <span class="class-name">String</span> brand;

    <span class="keyword">public</span> <span class="function">Vehicle</span>(<span class="class-name">String</span> brand) {  <span class="comment">// No default constructor!</span>
        <span class="keyword">this</span>.brand = brand;
    }
}

<span class="comment">// ❌ ERROR: No default constructor in Vehicle</span>
<span class="keyword">public class</span> <span class="class-name">Car</span> <span class="keyword">extends</span> <span class="class-name">Vehicle</span> {
    <span class="keyword">public</span> <span class="function">Car</span>() {
        <span class="comment">// Implicit super() call fails - Vehicle has no no-arg constructor</span>
    }
}

<span class="comment">// ✅ CORRECT: Explicitly call super with required argument</span>
<span class="keyword">public class</span> <span class="class-name">Car</span> <span class="keyword">extends</span> <span class="class-name">Vehicle</span> {
    <span class="keyword">public</span> <span class="function">Car</span>(<span class="class-name">String</span> brand) {
        <span class="keyword">super</span>(brand);  <span class="comment">// Must be first statement</span>
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Missing Abstract Method Implementation</div>
                <pre><code><span class="keyword">public abstract class</span> <span class="class-name">Shape</span> {
    <span class="keyword">public abstract double</span> <span class="function">area</span>();
    <span class="keyword">public abstract double</span> <span class="function">perimeter</span>();
}

<span class="comment">// ❌ ERROR: Circle is not abstract and does not override perimeter()</span>
<span class="keyword">public class</span> <span class="class-name">Circle</span> <span class="keyword">extends</span> <span class="class-name">Shape</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> radius;

    <span class="annotation">@Override</span>
    <span class="keyword">public double</span> <span class="function">area</span>() {
        <span class="keyword">return</span> <span class="class-name">Math</span>.PI * radius * radius;
    }
    <span class="comment">// Forgot perimeter()!</span>
}

<span class="comment">// ✅ CORRECT: Implement ALL abstract methods</span>
<span class="keyword">public class</span> <span class="class-name">Circle</span> <span class="keyword">extends</span> <span class="class-name">Shape</span> {
    <span class="keyword">private</span> <span class="keyword">double</span> radius;

    <span class="annotation">@Override</span>
    <span class="keyword">public double</span> <span class="function">area</span>() {
        <span class="keyword">return</span> <span class="class-name">Math</span>.PI * radius * radius;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public double</span> <span class="function">perimeter</span>() {
        <span class="keyword">return</span> <span class="number">2</span> * <span class="class-name">Math</span>.PI * radius;
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 4: Incorrect Access Modifier in Override</div>
                <pre><code><span class="keyword">interface</span> <span class="class-name">Service</span> {
    <span class="keyword">void</span> <span class="function">execute</span>();  <span class="comment">// Implicitly public</span>
}

<span class="comment">// ❌ ERROR: Cannot reduce visibility</span>
<span class="keyword">class</span> <span class="class-name">MyService</span> <span class="keyword">implements</span> <span class="class-name">Service</span> {
    <span class="keyword">void</span> <span class="function">execute</span>() {  <span class="comment">// Package-private - more restrictive than public!</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Executing"</span>);
    }
}

<span class="comment">// ✅ CORRECT: Must be public (same or more accessible)</span>
<span class="keyword">class</span> <span class="class-name">MyService</span> <span class="keyword">implements</span> <span class="class-name">Service</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">execute</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Executing"</span>);
    }
}</code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Troubleshooting Guide</h2>

            <h3>Error: "Class is not abstract and does not override abstract method"</h3>
            <pre><code><span class="comment">// Problem: Concrete class doesn't implement all abstract methods</span>
<span class="comment">// Solution: Either implement the method OR make the class abstract</span>

<span class="comment">// Option 1: Implement the missing method</span>
<span class="keyword">public class</span> <span class="class-name">MyClass</span> <span class="keyword">implements</span> <span class="class-name">MyInterface</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">missingMethod</span>() {
        <span class="comment">// Implementation here</span>
    }
}

<span class="comment">// Option 2: Make the class abstract (defer implementation to subclasses)</span>
<span class="keyword">public abstract class</span> <span class="class-name">MyClass</span> <span class="keyword">implements</span> <span class="class-name">MyInterface</span> {
    <span class="comment">// missingMethod() stays abstract</span>
}</code></pre>

            <h3>Error: "Constructor call must be first statement in constructor"</h3>
            <pre><code><span class="comment">// Problem: super() or this() not first</span>
<span class="keyword">public</span> <span class="function">Child</span>(<span class="class-name">String</span> name) {
    validate(name);  <span class="comment">// ERROR: Can't do this before super()</span>
    <span class="keyword">super</span>(name);
}

<span class="comment">// Solution: Put super() first, validate after</span>
<span class="keyword">public</span> <span class="function">Child</span>(<span class="class-name">String</span> name) {
    <span class="keyword">super</span>(name);  <span class="comment">// First!</span>
    validate(name);
}

<span class="comment">// Or use static validation in super() call</span>
<span class="keyword">public</span> <span class="function">Child</span>(<span class="class-name">String</span> name) {
    <span class="keyword">super</span>(validateAndReturn(name));  <span class="comment">// Static method call is OK</span>
}

<span class="keyword">private static</span> <span class="class-name">String</span> <span class="function">validateAndReturn</span>(<span class="class-name">String</span> name) {
    <span class="keyword">if</span> (name == <span class="keyword">null</span>) <span class="keyword">throw new</span> <span class="class-name">IllegalArgumentException</span>();
    <span class="keyword">return</span> name;
}</code></pre>

            <h3>Error: "Duplicate default methods"</h3>
            <pre><code><span class="comment">// Problem: Multiple interfaces have same default method</span>
<span class="keyword">interface</span> <span class="class-name">A</span> { <span class="keyword">default void</span> <span class="function">foo</span>() { } }
<span class="keyword">interface</span> <span class="class-name">B</span> { <span class="keyword">default void</span> <span class="function">foo</span>() { } }
<span class="keyword">class</span> <span class="class-name">C</span> <span class="keyword">implements</span> <span class="class-name">A</span>, <span class="class-name">B</span> { }  <span class="comment">// ERROR: inherits unrelated defaults</span>

<span class="comment">// Solution: Override and choose which to use</span>
<span class="keyword">class</span> <span class="class-name">C</span> <span class="keyword">implements</span> <span class="class-name">A</span>, <span class="class-name">B</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">foo</span>() {
        <span class="class-name">A</span>.<span class="keyword">super</span>.foo();  <span class="comment">// Choose A's version</span>
        <span class="comment">// OR: B.super.foo();</span>
        <span class="comment">// OR: your own implementation</span>
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Q1: What is the difference between an interface and an abstract class?</div>
                <p><strong>Answer:</strong> Key differences: (1) A class can implement multiple interfaces but extend only one abstract class. (2) Interfaces can only have constants; abstract classes can have any fields. (3) Interface methods are implicitly public; abstract classes can have any access modifier. (4) Interfaces define capabilities (CAN-DO); abstract classes define identity (IS-A). (5) Pre-Java 8, interfaces had no implementation; now they can have default/static/private methods. Use interfaces for contracts across unrelated classes; use abstract classes for sharing code among related classes.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q2: Can an interface extend another interface? Can it extend multiple?</div>
                <p><strong>Answer:</strong> Yes, an interface can extend one or MORE interfaces (using extends, not implements). This creates an interface that inherits all methods from parent interfaces. Example: <code>interface C extends A, B { }</code>. This is different from classes, which can only extend one class.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q3: What are default methods and why were they added?</div>
                <p><strong>Answer:</strong> Default methods (Java 8+) allow interfaces to have method implementations. They were added primarily to enable API evolution - adding methods to interfaces (like <code>forEach()</code> to <code>Iterable</code>) without breaking existing implementations. Without default methods, adding any method to an interface would break all implementing classes.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q4: Can we have static methods in an interface?</div>
                <p><strong>Answer:</strong> Yes, since Java 8. Static methods in interfaces are useful for utility methods related to the interface. They're called using the interface name: <code>InterfaceName.staticMethod()</code>. Unlike default methods, static methods are not inherited by implementing classes or sub-interfaces.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q5: What happens when a class implements two interfaces with the same default method?</div>
                <p><strong>Answer:</strong> The compiler reports an error - the class must override the method to resolve ambiguity. In the override, you can: (1) provide your own implementation, (2) call one interface's version using <code>InterfaceName.super.method()</code>, or (3) call both versions.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q6: Can an abstract class have a constructor?</div>
                <p><strong>Answer:</strong> Yes. Although you cannot instantiate an abstract class directly, its constructors are called when concrete subclasses are instantiated (via <code>super()</code>). Constructors initialize fields and enforce invariants. This is a key difference from interfaces, which cannot have constructors.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q7: When would you use an abstract class with only abstract methods?</div>
                <p><strong>Answer:</strong> Rarely now that interfaces have default methods. However, you might use an abstract class over an interface when you need: (1) constructors for initialization, (2) non-public methods, (3) non-static/non-final fields, or (4) to prevent multiple inheritance (Java classes can extend only one class). Before Java 8, this pattern was more common.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q8: What is a functional interface?</div>
                <p><strong>Answer:</strong> A functional interface has exactly one abstract method (SAM - Single Abstract Method). It can have any number of default and static methods. Functional interfaces can be implemented using lambda expressions or method references. Examples: <code>Runnable</code>, <code>Comparator</code>, <code>Function</code>. The <code>@FunctionalInterface</code> annotation is optional but recommended as it enables compiler checking.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="oop-principles.html">OOP Principles</a> &ndash; Understanding abstraction and inheritance</li>
                <li><a href="access-modifiers.html">Access Modifiers</a> &ndash; Visibility in interfaces vs classes</li>
                <li><a href="lambda-streams.html">Lambda & Streams</a> &ndash; Using functional interfaces</li>
                <li><a href="../advanced/design-patterns.html">Design Patterns</a> &ndash; Strategy, Template Method patterns</li>
                <li><a href="../best-practices/solid-principles.html">SOLID Principles</a> &ndash; Interface Segregation Principle</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="oop-principles.html" class="related-link">OOP Principles</a>
                <a href="access-modifiers.html" class="related-link">Access Modifiers</a>
                <a href="lambda-streams.html" class="related-link">Lambda & Streams</a>
                <a href="generics.html" class="related-link">Generics</a>
                <a href="../advanced/design-patterns.html" class="related-link">Design Patterns</a>
                <a href="../best-practices/solid-principles.html" class="related-link">SOLID Principles</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
