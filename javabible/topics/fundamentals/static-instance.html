<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static vs Instance - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#fundamentals">Java Fundamentals</a> / Static vs Instance
            </nav>
            <h1>Static vs Instance Members</h1>
            <p class="topic-subtitle">Understanding Class-Level vs Object-Level Members</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What is Static vs Instance?</h2>
            <p>In Java, every class member (field, method, or nested class) belongs to either the <strong>class itself</strong> (static) or to <strong>individual objects</strong> (instance). This distinction is fundamental to how Java organizes data and behavior, and understanding it is essential for writing effective object-oriented code.</p>

            <p><strong>Static members</strong> are shared across all instances of a class&mdash;there's exactly one copy that belongs to the class. <strong>Instance members</strong> are unique to each object&mdash;every object has its own copy. This difference affects memory allocation, access patterns, and design decisions throughout your code.</p>

            <p>The choice between static and instance is more than a technical detail; it's a design decision that communicates intent. Static members say "this is shared by all" or "this doesn't depend on any particular object's state." Instance members say "this varies from object to object" or "this depends on the object's specific state."</p>

            <h3>Historical Context: Why Static Exists</h3>
            <p>The <code>static</code> keyword in Java comes from C and C++, where it originally meant "statically allocated" (as opposed to dynamically allocated on the heap). In Java, static members are loaded when the class is first loaded by the JVM, before any objects are created. This makes them available immediately and ensures there's only one copy regardless of how many objects exist.</p>

            <p>Static was also Java's solution for providing class-level functionality in a language where everything (except primitives) is an object. Methods like <code>Math.sqrt()</code> don't need an instance of Math because they don't depend on any state&mdash;they just compute a result from their parameters. Similarly, constants like <code>Math.PI</code> are the same for everyone, so it makes no sense for each Math object (if they existed) to have its own copy.</p>

            <h3>The Big Picture: How Static Fits in Java Design</h3>
            <p>Static members are everywhere in Java:</p>
            <ul>
                <li><strong>Utility classes:</strong> <code>Math</code>, <code>Arrays</code>, <code>Collections</code>, <code>Objects</code></li>
                <li><strong>Constants:</strong> <code>Integer.MAX_VALUE</code>, <code>System.out</code></li>
                <li><strong>Factory methods:</strong> <code>String.valueOf()</code>, <code>List.of()</code></li>
                <li><strong>Main method:</strong> <code>public static void main(String[] args)</code></li>
                <li><strong>Singleton pattern:</strong> A private static instance</li>
            </ul>

            <h3>Real-World Analogy: A School</h3>
            <p>Imagine a school with students:</p>
            <ul>
                <li><strong>Static (Class-level):</strong> The school name, the principal, total student count
                    <br><em>&rarr; Shared by ALL students, belongs to the school itself</em></li>
                <li><strong>Instance (Object-level):</strong> Each student's name, age, grade, GPA
                    <br><em>&rarr; Unique to EACH student, each object has its own copy</em></li>
            </ul>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Student</span> {
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// STATIC MEMBERS - Shared by ALL students (belongs to the CLASS)</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">private static</span> <span class="class-name">String</span> schoolName = <span class="string">"Java High School"</span>;
    <span class="keyword">private static int</span> totalStudents = <span class="number">0</span>;
    <span class="keyword">private static final int</span> MAX_STUDENTS = <span class="number">1000</span>;  <span class="comment">// Constant</span>

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// INSTANCE MEMBERS - Unique to EACH student (belongs to OBJECTS)</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">private</span> <span class="class-name">String</span> name;
    <span class="keyword">private int</span> age;
    <span class="keyword">private int</span> grade;
    <span class="keyword">private double</span> gpa;

    <span class="keyword">public</span> <span class="function">Student</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age, <span class="keyword">int</span> grade) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
        <span class="keyword">this</span>.grade = grade;
        <span class="keyword">this</span>.gpa = <span class="number">0.0</span>;
        totalStudents++;  <span class="comment">// Increment SHARED counter</span>
    }

    <span class="comment">// Static method - operates on class-level data</span>
    <span class="keyword">public static int</span> <span class="function">getTotalStudents</span>() {
        <span class="keyword">return</span> totalStudents;
    }

    <span class="comment">// Instance method - operates on this object's data</span>
    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getName</span>() {
        <span class="keyword">return</span> name;
    }
}

<span class="comment">// Usage demonstration</span>
<span class="class-name">Student</span> alice = <span class="keyword">new</span> <span class="class-name">Student</span>(<span class="string">"Alice"</span>, <span class="number">15</span>, <span class="number">9</span>);
<span class="class-name">Student</span> bob = <span class="keyword">new</span> <span class="class-name">Student</span>(<span class="string">"Bob"</span>, <span class="number">16</span>, <span class="number">10</span>);
<span class="class-name">Student</span> carol = <span class="keyword">new</span> <span class="class-name">Student</span>(<span class="string">"Carol"</span>, <span class="number">17</span>, <span class="number">11</span>);

<span class="comment">// Instance members - DIFFERENT for each student</span>
<span class="class-name">System</span>.out.println(alice.getName());  <span class="comment">// "Alice"</span>
<span class="class-name">System</span>.out.println(bob.getName());    <span class="comment">// "Bob"</span>

<span class="comment">// Static members - SAME for all students (access via class name)</span>
<span class="class-name">System</span>.out.println(<span class="class-name">Student</span>.getTotalStudents());  <span class="comment">// 3</span></code></pre>

            <h3>Memory Visualization</h3>
            <pre><code><span class="comment">/*
 * Memory Layout: Static vs Instance
 * ==================================
 *
 *  ┌──────────────────────────────────────────────────────────────────────┐
 *  │                    METHOD AREA (Class Data)                          │
 *  │                                                                      │
 *  │   Student.class                                                      │
 *  │   ├── static schoolName: "Java High School"                          │
 *  │   ├── static totalStudents: 3                                        │
 *  │   ├── static MAX_STUDENTS: 1000                                      │
 *  │   ├── static methods: getTotalStudents()                             │
 *  │   └── instance method templates: getName(), etc.                     │
 *  │                                                                      │
 *  │   (ONE copy, loaded when class is first used)                        │
 *  └──────────────────────────────────────────────────────────────────────┘
 *
 *  ┌──────────────────────────────────────────────────────────────────────┐
 *  │                         HEAP (Object Data)                           │
 *  │                                                                      │
 *  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐      │
 *  │  │ alice (Student) │  │  bob (Student)  │  │ carol (Student) │      │
 *  │  │ name: "Alice"   │  │ name: "Bob"     │  │ name: "Carol"   │      │
 *  │  │ age: 15         │  │ age: 16         │  │ age: 17         │      │
 *  │  │ grade: 9        │  │ grade: 10       │  │ grade: 11       │      │
 *  │  │ gpa: 0.0        │  │ gpa: 0.0        │  │ gpa: 0.0        │      │
 *  │  └─────────────────┘  └─────────────────┘  └─────────────────┘      │
 *  │                                                                      │
 *  │  (SEPARATE copy for each object, created with 'new')                 │
 *  └──────────────────────────────────────────────────────────────────────┘
 */</span></code></pre>

            <div class="info-box note">
                <div class="info-box-title">Key Differences Summary</div>
                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>Static</th>
                        <th>Instance</th>
                    </tr>
                    <tr>
                        <td><strong>Belongs to</strong></td>
                        <td>The CLASS itself</td>
                        <td>Individual OBJECTS</td>
                    </tr>
                    <tr>
                        <td><strong>Copies</strong></td>
                        <td>ONE copy, shared by all</td>
                        <td>Each object has its own</td>
                    </tr>
                    <tr>
                        <td><strong>Access syntax</strong></td>
                        <td><code>ClassName.member</code></td>
                        <td><code>objectRef.member</code></td>
                    </tr>
                    <tr>
                        <td><strong>Keyword</strong></td>
                        <td>Uses <code>static</code></td>
                        <td>No keyword (default)</td>
                    </tr>
                    <tr>
                        <td><strong>Created when</strong></td>
                        <td>Class is loaded</td>
                        <td>Object is created (<code>new</code>)</td>
                    </tr>
                    <tr>
                        <td><strong>Memory location</strong></td>
                        <td>Method Area</td>
                        <td>Heap</td>
                    </tr>
                    <tr>
                        <td><strong>Lifetime</strong></td>
                        <td>Until class is unloaded</td>
                        <td>Until object is garbage collected</td>
                    </tr>
                    <tr>
                        <td><strong>Can access</strong></td>
                        <td>Only static members</td>
                        <td>Both static and instance</td>
                    </tr>
                </table>
            </div>
        </section>

        <section class="content-section">
            <h2>Static Members In Depth</h2>

            <h3>Static Variables (Class Variables)</h3>
            <p>Static variables belong to the class, not to any instance. They're shared among all objects and exist even when no objects have been created.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">Counter</span> {
    <span class="comment">// Static variable - ONE copy shared by all instances</span>
    <span class="keyword">private static int</span> count = <span class="number">0</span>;

    <span class="comment">// Instance variable - each object has its own</span>
    <span class="keyword">private final int</span> id;

    <span class="keyword">public</span> <span class="function">Counter</span>() {
        count++;           <span class="comment">// Increment shared counter</span>
        <span class="keyword">this</span>.id = count;   <span class="comment">// Assign unique ID to this instance</span>
    }

    <span class="keyword">public static int</span> <span class="function">getCount</span>() {
        <span class="keyword">return</span> count;
    }

    <span class="keyword">public int</span> <span class="function">getId</span>() {
        <span class="keyword">return</span> id;
    }
}

<span class="comment">// Before any objects exist</span>
<span class="class-name">System</span>.out.println(<span class="class-name">Counter</span>.getCount());  <span class="comment">// 0</span>

<span class="comment">// Create objects</span>
<span class="class-name">Counter</span> c1 = <span class="keyword">new</span> <span class="class-name">Counter</span>();  <span class="comment">// id=1, count becomes 1</span>
<span class="class-name">Counter</span> c2 = <span class="keyword">new</span> <span class="class-name">Counter</span>();  <span class="comment">// id=2, count becomes 2</span>
<span class="class-name">Counter</span> c3 = <span class="keyword">new</span> <span class="class-name">Counter</span>();  <span class="comment">// id=3, count becomes 3</span>

<span class="comment">// Static count is shared - same value everywhere</span>
<span class="class-name">System</span>.out.println(<span class="class-name">Counter</span>.getCount());  <span class="comment">// 3</span>

<span class="comment">// Instance IDs are unique to each object</span>
<span class="class-name">System</span>.out.println(c1.getId());  <span class="comment">// 1</span>
<span class="class-name">System</span>.out.println(c2.getId());  <span class="comment">// 2</span>
<span class="class-name">System</span>.out.println(c3.getId());  <span class="comment">// 3</span></code></pre>

            <h3>Static Constants</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">PhysicsConstants</span> {
    <span class="comment">// Static final = constant (cannot be changed)</span>
    <span class="keyword">public static final double</span> SPEED_OF_LIGHT = <span class="number">299792458.0</span>;  <span class="comment">// m/s</span>
    <span class="keyword">public static final double</span> GRAVITATIONAL_CONSTANT = <span class="number">6.67430e-11</span>;
    <span class="keyword">public static final double</span> PLANCK_CONSTANT = <span class="number">6.62607e-34</span>;

    <span class="comment">// Private constructor - utility class shouldn't be instantiated</span>
    <span class="keyword">private</span> <span class="function">PhysicsConstants</span>() {
        <span class="keyword">throw new</span> <span class="class-name">AssertionError</span>(<span class="string">"Cannot instantiate constants class"</span>);
    }
}

<span class="comment">// Usage - no object needed!</span>
<span class="keyword">double</span> energy = mass * <span class="class-name">PhysicsConstants</span>.SPEED_OF_LIGHT * <span class="class-name">PhysicsConstants</span>.SPEED_OF_LIGHT;

<span class="comment">// Java's built-in constants work the same way:</span>
<span class="keyword">double</span> pi = <span class="class-name">Math</span>.PI;                 <span class="comment">// 3.141592653589793</span>
<span class="keyword">int</span> maxInt = <span class="class-name">Integer</span>.MAX_VALUE;     <span class="comment">// 2147483647</span>
<span class="class-name">String</span> lineSep = <span class="class-name">System</span>.lineSeparator();</code></pre>

            <h3>Static Methods</h3>
            <p>Static methods belong to the class and don't require an instance. They cannot access instance variables or call instance methods directly.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">MathUtils</span> {
    <span class="comment">// Static methods - don't need an object, just input → output</span>

    <span class="keyword">public static int</span> <span class="function">add</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
        <span class="keyword">return</span> a + b;
    }

    <span class="keyword">public static int</span> <span class="function">square</span>(<span class="keyword">int</span> x) {
        <span class="keyword">return</span> x * x;
    }

    <span class="keyword">public static int</span> <span class="function">factorial</span>(<span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n <= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;
        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);
    }

    <span class="keyword">public static boolean</span> <span class="function">isPrime</span>(<span class="keyword">int</span> n) {
        <span class="keyword">if</span> (n < <span class="number">2</span>) <span class="keyword">return false</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i <= <span class="class-name">Math</span>.sqrt(n); i++) {
            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return false</span>;
        }
        <span class="keyword">return true</span>;
    }

    <span class="keyword">private</span> <span class="function">MathUtils</span>() { }  <span class="comment">// Prevent instantiation</span>
}

<span class="comment">// Usage - call directly on the class, no object needed</span>
<span class="keyword">int</span> sum = <span class="class-name">MathUtils</span>.add(<span class="number">5</span>, <span class="number">10</span>);       <span class="comment">// 15</span>
<span class="keyword">int</span> squared = <span class="class-name">MathUtils</span>.square(<span class="number">4</span>);   <span class="comment">// 16</span>
<span class="keyword">int</span> fact = <span class="class-name">MathUtils</span>.factorial(<span class="number">5</span>);  <span class="comment">// 120</span>
<span class="keyword">boolean</span> prime = <span class="class-name">MathUtils</span>.isPrime(<span class="number">17</span>);  <span class="comment">// true</span>

<span class="comment">// Java's Math class works the same way:</span>
<span class="keyword">double</span> sqrt = <span class="class-name">Math</span>.sqrt(<span class="number">16</span>);    <span class="comment">// 4.0</span>
<span class="keyword">double</span> max = <span class="class-name">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">// 20</span>
<span class="keyword">double</span> rand = <span class="class-name">Math</span>.random();    <span class="comment">// 0.0 to 1.0</span></code></pre>

            <h3>Static Blocks (Static Initializers)</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Database</span> {
    <span class="keyword">private static final</span> <span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">String</span>&gt; CONFIG;
    <span class="keyword">private static final</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; SUPPORTED_DATABASES;

    <span class="comment">// Static block - runs ONCE when the class is first loaded</span>
    <span class="comment">// Use for complex static initialization</span>
    <span class="keyword">static</span> {
        <span class="class-name">System</span>.out.println(<span class="string">"Database class loading..."</span>);

        <span class="comment">// Initialize complex static fields</span>
        CONFIG = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();
        CONFIG.put(<span class="string">"host"</span>, <span class="string">"localhost"</span>);
        CONFIG.put(<span class="string">"port"</span>, <span class="string">"5432"</span>);
        CONFIG.put(<span class="string">"database"</span>, <span class="string">"myapp"</span>);

        SUPPORTED_DATABASES = <span class="class-name">List</span>.of(<span class="string">"PostgreSQL"</span>, <span class="string">"MySQL"</span>, <span class="string">"Oracle"</span>, <span class="string">"SQLite"</span>);

        <span class="comment">// Could also load from a config file, register JDBC drivers, etc.</span>
        <span class="class-name">System</span>.out.println(<span class="string">"Database class loaded!"</span>);
    }

    <span class="comment">// Multiple static blocks run in order</span>
    <span class="keyword">static</span> {
        <span class="class-name">System</span>.out.println(<span class="string">"Second static block"</span>);
    }

    <span class="keyword">public static</span> <span class="class-name">String</span> <span class="function">getConfig</span>(<span class="class-name">String</span> key) {
        <span class="keyword">return</span> CONFIG.get(key);
    }
}

<span class="comment">// Static block runs when class is first referenced</span>
<span class="class-name">String</span> host = <span class="class-name">Database</span>.getConfig(<span class="string">"host"</span>);  <span class="comment">// Triggers class loading</span>
<span class="comment">// Output:</span>
<span class="comment">// Database class loading...</span>
<span class="comment">// Database class loaded!</span>
<span class="comment">// Second static block</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Instance Members In Depth</h2>
            <p>Instance members belong to individual objects. Each object has its own copy of instance variables, and instance methods operate on that specific object's data.</p>

            <pre><code><span class="keyword">public class</span> <span class="class-name">BankAccount</span> {
    <span class="comment">// Instance variables - each account has its own values</span>
    <span class="keyword">private final</span> <span class="class-name">String</span> accountNumber;
    <span class="keyword">private</span> <span class="class-name">String</span> ownerName;
    <span class="keyword">private double</span> balance;
    <span class="keyword">private final</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; transactions;

    <span class="comment">// Instance initializer block - runs before constructor</span>
    {
        <span class="keyword">this</span>.transactions = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
        <span class="class-name">System</span>.out.println(<span class="string">"Instance initializer: Creating transaction list"</span>);
    }

    <span class="comment">// Constructor - initializes instance variables</span>
    <span class="keyword">public</span> <span class="function">BankAccount</span>(<span class="class-name">String</span> accountNumber, <span class="class-name">String</span> ownerName) {
        <span class="keyword">this</span>.accountNumber = accountNumber;
        <span class="keyword">this</span>.ownerName = ownerName;
        <span class="keyword">this</span>.balance = <span class="number">0.0</span>;
    }

    <span class="comment">// Instance methods - operate on THIS object's data</span>
    <span class="keyword">public void</span> <span class="function">deposit</span>(<span class="keyword">double</span> amount) {
        <span class="keyword">if</span> (amount > <span class="number">0</span>) {
            <span class="keyword">this</span>.balance += amount;  <span class="comment">// Modifies THIS account's balance</span>
            transactions.add(<span class="string">"DEPOSIT: $"</span> + amount);
        }
    }

    <span class="keyword">public boolean</span> <span class="function">withdraw</span>(<span class="keyword">double</span> amount) {
        <span class="keyword">if</span> (amount > <span class="number">0</span> && amount <= <span class="keyword">this</span>.balance) {
            <span class="keyword">this</span>.balance -= amount;
            transactions.add(<span class="string">"WITHDRAWAL: $"</span> + amount);
            <span class="keyword">return true</span>;
        }
        <span class="keyword">return false</span>;
    }

    <span class="keyword">public double</span> <span class="function">getBalance</span>() {
        <span class="keyword">return this</span>.balance;  <span class="comment">// Returns THIS account's balance</span>
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">getAccountNumber</span>() {
        <span class="keyword">return this</span>.accountNumber;
    }
}

<span class="comment">// Each object has independent state</span>
<span class="class-name">BankAccount</span> aliceAccount = <span class="keyword">new</span> <span class="class-name">BankAccount</span>(<span class="string">"ACC001"</span>, <span class="string">"Alice"</span>);
<span class="class-name">BankAccount</span> bobAccount = <span class="keyword">new</span> <span class="class-name">BankAccount</span>(<span class="string">"ACC002"</span>, <span class="string">"Bob"</span>);

aliceAccount.deposit(<span class="number">1000</span>);
aliceAccount.deposit(<span class="number">500</span>);
bobAccount.deposit(<span class="number">200</span>);

<span class="comment">// Each account has its own balance</span>
<span class="class-name">System</span>.out.println(aliceAccount.getBalance());  <span class="comment">// 1500.0</span>
<span class="class-name">System</span>.out.println(bobAccount.getBalance());    <span class="comment">// 200.0</span>

<span class="comment">// Operations on one don't affect the other</span>
aliceAccount.withdraw(<span class="number">300</span>);
<span class="class-name">System</span>.out.println(aliceAccount.getBalance());  <span class="comment">// 1200.0</span>
<span class="class-name">System</span>.out.println(bobAccount.getBalance());    <span class="comment">// Still 200.0</span></code></pre>

            <h3>The 'this' Keyword</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Person</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;
    <span class="keyword">private int</span> age;

    <span class="keyword">public</span> <span class="function">Person</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
        <span class="comment">// 'this' refers to the current object</span>
        <span class="comment">// Distinguishes instance variable from parameter with same name</span>
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
    }

    <span class="keyword">public</span> <span class="class-name">Person</span> <span class="function">withName</span>(<span class="class-name">String</span> name) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">return this</span>;  <span class="comment">// Return current object for method chaining</span>
    }

    <span class="keyword">public</span> <span class="class-name">Person</span> <span class="function">withAge</span>(<span class="keyword">int</span> age) {
        <span class="keyword">this</span>.age = age;
        <span class="keyword">return this</span>;
    }

    <span class="keyword">public void</span> <span class="function">introduce</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Hi, I'm "</span> + <span class="keyword">this</span>.name + <span class="string">", age "</span> + <span class="keyword">this</span>.age);
    }

    <span class="keyword">public void</span> <span class="function">compareAge</span>(<span class="class-name">Person</span> other) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.age > other.age) {
            <span class="class-name">System</span>.out.println(<span class="keyword">this</span>.name + <span class="string">" is older than "</span> + other.name);
        } <span class="keyword">else if</span> (<span class="keyword">this</span>.age < other.age) {
            <span class="class-name">System</span>.out.println(<span class="keyword">this</span>.name + <span class="string">" is younger than "</span> + other.name);
        } <span class="keyword">else</span> {
            <span class="class-name">System</span>.out.println(<span class="keyword">this</span>.name + <span class="string">" and "</span> + other.name + <span class="string">" are the same age"</span>);
        }
    }
}

<span class="comment">// Method chaining using 'this'</span>
<span class="class-name">Person</span> person = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"John"</span>, <span class="number">20</span>)
    .withName(<span class="string">"Jane"</span>)
    .withAge(<span class="number">25</span>);
person.introduce();  <span class="comment">// "Hi, I'm Jane, age 25"</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Access Rules</h2>

            <div class="info-box important">
                <div class="info-box-title">Critical Access Rules</div>
                <ul>
                    <li><strong>Static methods CANNOT access instance members directly</strong> (no implicit <code>this</code>)</li>
                    <li><strong>Static methods CANNOT use <code>this</code> or <code>super</code></strong></li>
                    <li><strong>Instance methods CAN access both static and instance members</strong></li>
                    <li><strong>Static members CAN be accessed from instance context</strong> (but shouldn't be)</li>
                </ul>
            </div>

            <pre><code><span class="keyword">public class</span> <span class="class-name">AccessRulesDemo</span> {
    <span class="comment">// Static member</span>
    <span class="keyword">private static</span> <span class="class-name">String</span> staticField = <span class="string">"I'm static"</span>;

    <span class="comment">// Instance member</span>
    <span class="keyword">private</span> <span class="class-name">String</span> instanceField = <span class="string">"I'm instance"</span>;

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// STATIC METHOD - Can only access static members directly</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public static void</span> <span class="function">staticMethod</span>() {
        <span class="class-name">System</span>.out.println(staticField);     <span class="comment">// ✅ OK - static accessing static</span>
        staticHelper();                       <span class="comment">// ✅ OK - static calling static</span>

        <span class="comment">// System.out.println(instanceField); // ❌ ERROR - no 'this' reference</span>
        <span class="comment">// instanceMethod();                  // ❌ ERROR - needs an object</span>
        <span class="comment">// System.out.println(this.instanceField); // ❌ ERROR - 'this' not available</span>

        <span class="comment">// To access instance members from static context, you need an object:</span>
        <span class="class-name">AccessRulesDemo</span> obj = <span class="keyword">new</span> <span class="class-name">AccessRulesDemo</span>();
        <span class="class-name">System</span>.out.println(obj.instanceField);  <span class="comment">// ✅ OK - accessing via object</span>
        obj.instanceMethod();                    <span class="comment">// ✅ OK - calling via object</span>
    }

    <span class="keyword">private static void</span> <span class="function">staticHelper</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Static helper"</span>);
    }

    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="comment">// INSTANCE METHOD - Can access BOTH static and instance members</span>
    <span class="comment">// ═══════════════════════════════════════════════════════════════════════</span>
    <span class="keyword">public void</span> <span class="function">instanceMethod</span>() {
        <span class="class-name">System</span>.out.println(instanceField);   <span class="comment">// ✅ OK - instance accessing instance</span>
        <span class="class-name">System</span>.out.println(<span class="keyword">this</span>.instanceField); <span class="comment">// ✅ OK - explicit this</span>
        instanceHelper();                     <span class="comment">// ✅ OK - instance calling instance</span>

        <span class="class-name">System</span>.out.println(staticField);     <span class="comment">// ✅ OK - instance can access static</span>
        staticMethod();                       <span class="comment">// ✅ OK - instance can call static</span>
    }

    <span class="keyword">private void</span> <span class="function">instanceHelper</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Instance helper"</span>);
    }
}

<span class="comment">// The main method is static - that's why you can't call instance methods directly!</span>
<span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
    <span class="comment">// This is a static context</span>
    <span class="class-name">AccessRulesDemo</span>.staticMethod();  <span class="comment">// ✅ OK</span>

    <span class="comment">// Need an object for instance methods</span>
    <span class="class-name">AccessRulesDemo</span> demo = <span class="keyword">new</span> <span class="class-name">AccessRulesDemo</span>();
    demo.instanceMethod();  <span class="comment">// ✅ OK</span>
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Common Use Cases</h2>

            <h3>When to Use Static</h3>

            <h4>1. Utility/Helper Methods</h4>
            <pre><code><span class="keyword">public final class</span> <span class="class-name">StringUtils</span> {
    <span class="keyword">private</span> <span class="function">StringUtils</span>() { }  <span class="comment">// Prevent instantiation</span>

    <span class="keyword">public static boolean</span> <span class="function">isEmpty</span>(<span class="class-name">String</span> str) {
        <span class="keyword">return</span> str == <span class="keyword">null</span> || str.isEmpty();
    }

    <span class="keyword">public static boolean</span> <span class="function">isBlank</span>(<span class="class-name">String</span> str) {
        <span class="keyword">return</span> str == <span class="keyword">null</span> || str.trim().isEmpty();
    }

    <span class="keyword">public static</span> <span class="class-name">String</span> <span class="function">capitalize</span>(<span class="class-name">String</span> str) {
        <span class="keyword">if</span> (isEmpty(str)) <span class="keyword">return</span> str;
        <span class="keyword">return</span> <span class="class-name">Character</span>.toUpperCase(str.charAt(<span class="number">0</span>)) + str.substring(<span class="number">1</span>).toLowerCase();
    }

    <span class="keyword">public static</span> <span class="class-name">String</span> <span class="function">reverse</span>(<span class="class-name">String</span> str) {
        <span class="keyword">if</span> (str == <span class="keyword">null</span>) <span class="keyword">return null</span>;
        <span class="keyword">return new</span> <span class="class-name">StringBuilder</span>(str).reverse().toString();
    }
}</code></pre>

            <h4>2. Factory Methods</h4>
            <pre><code><span class="keyword">public class</span> <span class="class-name">User</span> {
    <span class="keyword">private final</span> <span class="class-name">String</span> name;
    <span class="keyword">private final</span> <span class="class-name">String</span> email;
    <span class="keyword">private final</span> <span class="class-name">UserType</span> type;

    <span class="keyword">private</span> <span class="function">User</span>(<span class="class-name">String</span> name, <span class="class-name">String</span> email, <span class="class-name">UserType</span> type) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.email = email;
        <span class="keyword">this</span>.type = type;
    }

    <span class="comment">// Static factory methods - clearer than multiple constructors</span>
    <span class="keyword">public static</span> <span class="class-name">User</span> <span class="function">createAdmin</span>(<span class="class-name">String</span> name, <span class="class-name">String</span> email) {
        <span class="keyword">return new</span> <span class="class-name">User</span>(name, email, <span class="class-name">UserType</span>.ADMIN);
    }

    <span class="keyword">public static</span> <span class="class-name">User</span> <span class="function">createRegular</span>(<span class="class-name">String</span> name, <span class="class-name">String</span> email) {
        <span class="keyword">return new</span> <span class="class-name">User</span>(name, email, <span class="class-name">UserType</span>.REGULAR);
    }

    <span class="keyword">public static</span> <span class="class-name">User</span> <span class="function">createGuest</span>() {
        <span class="keyword">return new</span> <span class="class-name">User</span>(<span class="string">"Guest"</span>, <span class="keyword">null</span>, <span class="class-name">UserType</span>.GUEST);
    }
}

<span class="comment">// Usage - very readable</span>
<span class="class-name">User</span> admin = <span class="class-name">User</span>.createAdmin(<span class="string">"Alice"</span>, <span class="string">"alice@example.com"</span>);
<span class="class-name">User</span> guest = <span class="class-name">User</span>.createGuest();</code></pre>

            <h4>3. Singleton Pattern</h4>
            <pre><code><span class="keyword">public class</span> <span class="class-name">DatabaseConnection</span> {
    <span class="comment">// Static instance - only one exists</span>
    <span class="keyword">private static</span> <span class="class-name">DatabaseConnection</span> instance;

    <span class="comment">// Private constructor - prevents external instantiation</span>
    <span class="keyword">private</span> <span class="function">DatabaseConnection</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Creating database connection..."</span>);
    }

    <span class="comment">// Static method provides global access point</span>
    <span class="keyword">public static</span> <span class="class-name">DatabaseConnection</span> <span class="function">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> <span class="class-name">DatabaseConnection</span>();
        }
        <span class="keyword">return</span> instance;
    }

    <span class="keyword">public void</span> <span class="function">query</span>(<span class="class-name">String</span> sql) {
        <span class="class-name">System</span>.out.println(<span class="string">"Executing: "</span> + sql);
    }
}

<span class="comment">// Usage - always returns the same instance</span>
<span class="class-name">DatabaseConnection</span> db1 = <span class="class-name">DatabaseConnection</span>.getInstance();
<span class="class-name">DatabaseConnection</span> db2 = <span class="class-name">DatabaseConnection</span>.getInstance();
<span class="class-name">System</span>.out.println(db1 == db2);  <span class="comment">// true - same object</span></code></pre>

            <h4>4. Counters and Shared State</h4>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Order</span> {
    <span class="keyword">private static int</span> orderCounter = <span class="number">0</span>;  <span class="comment">// Shared counter</span>

    <span class="keyword">private final int</span> orderId;  <span class="comment">// Instance-specific</span>
    <span class="keyword">private final</span> <span class="class-name">String</span> customerName;
    <span class="keyword">private final</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; items;

    <span class="keyword">public</span> <span class="function">Order</span>(<span class="class-name">String</span> customerName) {
        <span class="keyword">this</span>.orderId = ++orderCounter;  <span class="comment">// Auto-increment ID</span>
        <span class="keyword">this</span>.customerName = customerName;
        <span class="keyword">this</span>.items = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
    }

    <span class="keyword">public int</span> <span class="function">getOrderId</span>() { <span class="keyword">return</span> orderId; }

    <span class="keyword">public static int</span> <span class="function">getTotalOrdersCreated</span>() {
        <span class="keyword">return</span> orderCounter;
    }
}

<span class="class-name">Order</span> o1 = <span class="keyword">new</span> <span class="class-name">Order</span>(<span class="string">"Alice"</span>);  <span class="comment">// orderId = 1</span>
<span class="class-name">Order</span> o2 = <span class="keyword">new</span> <span class="class-name">Order</span>(<span class="string">"Bob"</span>);    <span class="comment">// orderId = 2</span>
<span class="class-name">Order</span> o3 = <span class="keyword">new</span> <span class="class-name">Order</span>(<span class="string">"Carol"</span>);  <span class="comment">// orderId = 3</span>
<span class="class-name">System</span>.out.println(<span class="class-name">Order</span>.getTotalOrdersCreated());  <span class="comment">// 3</span></code></pre>

            <h3>When to Use Instance</h3>
            <ul>
                <li><strong>Object-specific data:</strong> Name, balance, state that varies per object</li>
                <li><strong>Behavior that depends on state:</strong> Methods that use instance variables</li>
                <li><strong>Polymorphic behavior:</strong> Methods that can be overridden</li>
                <li><strong>Most of the time!</strong> Default to instance unless you have a reason for static</li>
            </ul>
        </section>

        <section class="content-section">
            <h2>Best Practices</h2>

            <div class="info-box tip">
                <div class="info-box-title">Static Best Practices</div>
                <ul>
                    <li><strong>Use for utility methods:</strong> Pure functions with no state</li>
                    <li><strong>Use for constants:</strong> <code>public static final</code></li>
                    <li><strong>Use for factory methods:</strong> Alternative constructors with descriptive names</li>
                    <li><strong>Avoid mutable static state:</strong> Can cause threading issues and hidden dependencies</li>
                    <li><strong>Make utility classes final with private constructor</strong></li>
                    <li><strong>Access via class name:</strong> <code>Math.sqrt()</code>, not <code>obj.sqrt()</code></li>
                </ul>
            </div>

            <div class="info-box tip">
                <div class="info-box-title">Instance Best Practices</div>
                <ul>
                    <li><strong>Default to instance:</strong> Unless you have a specific reason for static</li>
                    <li><strong>Use for object state:</strong> Data that varies between objects</li>
                    <li><strong>Encapsulate fields:</strong> Private fields with getters/setters</li>
                    <li><strong>Prefer immutable objects:</strong> Final fields where possible</li>
                    <li><strong>Use 'this' explicitly:</strong> When parameter names match field names</li>
                </ul>
            </div>

            <pre><code><span class="comment">// ❌ BAD: Accessing static through instance (confusing)</span>
<span class="class-name">Counter</span> c = <span class="keyword">new</span> <span class="class-name">Counter</span>();
<span class="keyword">int</span> count = c.getCount();  <span class="comment">// Works but misleading - implies instance behavior</span>

<span class="comment">// ✅ GOOD: Access static through class name (clear)</span>
<span class="keyword">int</span> count = <span class="class-name">Counter</span>.getCount();  <span class="comment">// Clear that it's class-level</span>

<span class="comment">// ❌ BAD: Mutable static state (thread-unsafe, hidden dependency)</span>
<span class="keyword">public class</span> <span class="class-name">UserService</span> {
    <span class="keyword">private static</span> <span class="class-name">Connection</span> connection;  <span class="comment">// Shared mutable state!</span>

    <span class="keyword">public static void</span> <span class="function">setConnection</span>(<span class="class-name">Connection</span> conn) {
        connection = conn;  <span class="comment">// Changes affect ALL code using this class</span>
    }
}

<span class="comment">// ✅ GOOD: Inject dependencies, use instance state</span>
<span class="keyword">public class</span> <span class="class-name">UserService</span> {
    <span class="keyword">private final</span> <span class="class-name">Connection</span> connection;  <span class="comment">// Instance, final, injected</span>

    <span class="keyword">public</span> <span class="function">UserService</span>(<span class="class-name">Connection</span> connection) {
        <span class="keyword">this</span>.connection = connection;
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Accessing Instance from Static Context</div>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Wrong</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name = <span class="string">"Instance Field"</span>;

    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="comment">// ❌ ERROR: Cannot access instance member from static context</span>
        <span class="comment">// System.out.println(name);</span>

        <span class="comment">// ✅ SOLUTION: Create an instance first</span>
        <span class="class-name">Wrong</span> obj = <span class="keyword">new</span> <span class="class-name">Wrong</span>();
        <span class="class-name">System</span>.out.println(obj.name);
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Using 'this' in Static Context</div>
                <pre><code><span class="keyword">public class</span> <span class="class-name">Wrong</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;

    <span class="keyword">public static void</span> <span class="function">staticMethod</span>() {
        <span class="comment">// ❌ ERROR: 'this' cannot be used in static context</span>
        <span class="comment">// System.out.println(this.name);</span>

        <span class="comment">// 'this' refers to the current OBJECT</span>
        <span class="comment">// Static methods don't have a current object!</span>
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Static Mutable State (Thread Safety)</div>
                <pre><code><span class="comment">// ❌ BAD: Mutable static state is NOT thread-safe</span>
<span class="keyword">public class</span> <span class="class-name">Counter</span> {
    <span class="keyword">private static int</span> count = <span class="number">0</span>;

    <span class="keyword">public static void</span> <span class="function">increment</span>() {
        count++;  <span class="comment">// Race condition in multithreaded code!</span>
    }
}

<span class="comment">// ✅ BETTER: Use AtomicInteger for thread-safe static counter</span>
<span class="keyword">public class</span> <span class="class-name">SafeCounter</span> {
    <span class="keyword">private static final</span> <span class="class-name">AtomicInteger</span> count = <span class="keyword">new</span> <span class="class-name">AtomicInteger</span>(<span class="number">0</span>);

    <span class="keyword">public static int</span> <span class="function">increment</span>() {
        <span class="keyword">return</span> count.incrementAndGet();  <span class="comment">// Thread-safe</span>
    }
}</code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 4: Static Methods Cannot Be Overridden</div>
                <pre><code><span class="keyword">class</span> <span class="class-name">Parent</span> {
    <span class="keyword">public static void</span> <span class="function">staticMethod</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Parent static"</span>);
    }

    <span class="keyword">public void</span> <span class="function">instanceMethod</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Parent instance"</span>);
    }
}

<span class="keyword">class</span> <span class="class-name">Child</span> <span class="keyword">extends</span> <span class="class-name">Parent</span> {
    <span class="comment">// This is METHOD HIDING, not overriding!</span>
    <span class="keyword">public static void</span> <span class="function">staticMethod</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Child static"</span>);
    }

    <span class="annotation">@Override</span>  <span class="comment">// This IS overriding</span>
    <span class="keyword">public void</span> <span class="function">instanceMethod</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Child instance"</span>);
    }
}

<span class="class-name">Parent</span> p = <span class="keyword">new</span> <span class="class-name">Child</span>();

<span class="comment">// Static: Reference type determines which method is called</span>
p.staticMethod();  <span class="comment">// "Parent static" - NOT polymorphic!</span>

<span class="comment">// Instance: Object type determines which method is called</span>
p.instanceMethod();  <span class="comment">// "Child instance" - polymorphic</span></code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Troubleshooting Guide</h2>

            <h3>Error: "Non-static field cannot be referenced from a static context"</h3>
            <pre><code><span class="comment">// Problem: Trying to access instance member from static method</span>
<span class="keyword">public class</span> <span class="class-name">Example</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> name;

    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="class-name">System</span>.out.println(name);  <span class="comment">// ERROR!</span>
    }
}

<span class="comment">// Solution 1: Make the field static (if appropriate)</span>
<span class="keyword">private static</span> <span class="class-name">String</span> name;

<span class="comment">// Solution 2: Create an instance (usually better)</span>
<span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
    <span class="class-name">Example</span> obj = <span class="keyword">new</span> <span class="class-name">Example</span>();
    obj.name = <span class="string">"Test"</span>;
    <span class="class-name">System</span>.out.println(obj.name);
}

<span class="comment">// Solution 3: Move logic to instance method</span>
<span class="keyword">public void</span> <span class="function">run</span>() {
    <span class="class-name">System</span>.out.println(name);  <span class="comment">// Works in instance method</span>
}

<span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
    <span class="keyword">new</span> <span class="class-name">Example</span>().run();
}</code></pre>

            <h3>Error: "'this' cannot be referenced from a static context"</h3>
            <pre><code><span class="comment">// Problem: Using 'this' in static method</span>
<span class="keyword">public static void</span> <span class="function">staticMethod</span>() {
    <span class="keyword">this</span>.doSomething();  <span class="comment">// ERROR!</span>
}

<span class="comment">// Solution: 'this' only exists in instance context</span>
<span class="comment">// Either make the method non-static, or don't use 'this'</span></code></pre>

            <h3>Problem: Static variable holds stale data between tests</h3>
            <pre><code><span class="comment">// Problem: Static state persists between test runs</span>
<span class="keyword">public class</span> <span class="class-name">Counter</span> {
    <span class="keyword">private static int</span> count = <span class="number">0</span>;

    <span class="keyword">public static void</span> <span class="function">increment</span>() { count++; }
    <span class="keyword">public static int</span> <span class="function">getCount</span>() { <span class="keyword">return</span> count; }
}

<span class="comment">// Test 1 runs: count becomes 5</span>
<span class="comment">// Test 2 runs: count starts at 5, not 0!</span>

<span class="comment">// Solution: Add a reset method for testing</span>
<span class="keyword">public static void</span> <span class="function">reset</span>() {
    count = <span class="number">0</span>;  <span class="comment">// Call in @BeforeEach</span>
}

<span class="comment">// Better solution: Avoid static state when possible</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Q1: What is the difference between static and instance members?</div>
                <p><strong>Answer:</strong> Static members belong to the class and are shared by all instances - there's one copy loaded when the class loads. Instance members belong to individual objects - each object has its own copy created with <code>new</code>. Static members are accessed via class name (<code>Math.PI</code>), instance members via object reference (<code>obj.name</code>).</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q2: Why can't static methods access instance variables?</div>
                <p><strong>Answer:</strong> Static methods don't have a <code>this</code> reference because they're not called on any specific object. When you call <code>Math.sqrt(4)</code>, there's no Math object, so there's no instance context. Instance variables require knowing "which object's variable?" - static methods have no way to answer that question.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q3: Can we override static methods?</div>
                <p><strong>Answer:</strong> No. Static methods belong to the class, not to objects, so polymorphism doesn't apply. If a subclass declares a static method with the same signature, it's called <em>method hiding</em>, not overriding. The method called depends on the reference type at compile time, not the object type at runtime.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q4: What is a static block and when is it executed?</div>
                <p><strong>Answer:</strong> A static block is a block of code that runs once when the class is first loaded into the JVM. It's used for complex static initialization that can't be done in a single expression. Multiple static blocks run in the order they appear in the source code.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q5: Why is the main method static?</div>
                <p><strong>Answer:</strong> The JVM needs to call <code>main()</code> before any objects exist. If <code>main()</code> were an instance method, you'd need an object to call it, but you need <code>main()</code> to run code to create objects - a chicken-and-egg problem. Making it static allows the JVM to call it directly on the class.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q6: Can static methods use 'this' or 'super'?</div>
                <p><strong>Answer:</strong> No. <code>this</code> refers to "the current object," and <code>super</code> refers to "the current object's parent." Static methods aren't associated with any object, so these references are meaningless and cause compile errors.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q7: Is it good practice to access static members through instances?</div>
                <p><strong>Answer:</strong> No. Although <code>obj.staticMethod()</code> compiles, it's misleading because it suggests the method depends on the object when it doesn't. Always use <code>ClassName.staticMethod()</code> to make it clear the method is class-level. Most IDEs and linters warn about this.</p>
            </div>

            <div class="info-box note">
                <div class="info-box-title">Q8: What are the thread-safety implications of static variables?</div>
                <p><strong>Answer:</strong> Static variables are shared across all threads, which can cause race conditions if multiple threads modify them simultaneously. Solutions include: using <code>synchronized</code>, using atomic classes like <code>AtomicInteger</code>, using thread-local storage, or avoiding mutable static state altogether. Immutable static fields (constants) are inherently thread-safe.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="methods.html">Methods & Functions</a> &ndash; Method declaration and calling</li>
                <li><a href="access-modifiers.html">Access Modifiers</a> &ndash; Controlling visibility</li>
                <li><a href="oop-principles.html">OOP Principles</a> &ndash; Encapsulation and class design</li>
                <li><a href="constructors.html">Constructors</a> &ndash; Object initialization</li>
                <li><a href="../advanced/design-patterns.html">Design Patterns</a> &ndash; Singleton and other patterns</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="methods.html" class="related-link">Methods & Functions</a>
                <a href="access-modifiers.html" class="related-link">Access Modifiers</a>
                <a href="oop-principles.html" class="related-link">OOP Principles</a>
                <a href="constructors.html" class="related-link">Constructors</a>
                <a href="variables-datatypes.html" class="related-link">Variables & Data Types</a>
                <a href="../advanced/design-patterns.html" class="related-link">Design Patterns</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
