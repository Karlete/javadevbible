<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Core (IoC & DI) - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#spring">Spring Framework</a> / Spring Core
            </nav>
            <h1>Spring Core: IoC & DI</h1>
            <p class="topic-subtitle">Inversion of Control and Dependency Injection</p>
            <a href="../../index.html" class="back-btn">‚Üê Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <!-- What It Is -->
        <section class="content-section">
            <h2>What is Spring Core?</h2>
            <p>Spring Core is the foundation of the Spring Framework, providing the fundamental features of Inversion of Control (IoC) and Dependency Injection (DI). It manages the lifecycle and configuration of application objects (beans).</p>

            <div class="info-box note">
                <div class="info-box-title">Core Concepts</div>
                <ul>
                    <li><strong>IoC Container</strong> - Manages object creation and lifecycle</li>
                    <li><strong>Dependency Injection</strong> - Objects receive their dependencies instead of creating them</li>
                    <li><strong>Beans</strong> - Objects managed by the Spring IoC container</li>
                    <li><strong>Application Context</strong> - The IoC container implementation</li>
                </ul>
            </div>
        </section>

        <!-- Inversion of Control -->
        <section class="content-section">
            <h2>Inversion of Control (IoC)</h2>
            <p>IoC is a design principle where the control of object creation and lifecycle is inverted from the application code to a container or framework.</p>

            <h3>Traditional Approach (Without IoC)</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">UserService</span> {
    <span class="keyword">private</span> <span class="class-name">UserRepository</span> userRepository;

    <span class="keyword">public</span> <span class="function">UserService</span>() {
        <span class="comment">// Application code controls object creation</span>
        <span class="keyword">this</span>.userRepository = <span class="keyword">new</span> <span class="class-name">UserRepositoryImpl</span>();
    }

    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">getUserById</span>(<span class="keyword">int</span> id) {
        <span class="keyword">return</span> userRepository.findById(id);
    }
}</code></pre>

            <h3>IoC Approach (With Spring)</h3>
            <pre><code><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="keyword">import</span> org.springframework.stereotype.Service;

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">UserService</span> {
    <span class="keyword">private final</span> <span class="class-name">UserRepository</span> userRepository;

    <span class="comment">// Spring container controls object creation and injection</span>
    <span class="annotation">@Autowired</span>
    <span class="keyword">public</span> <span class="function">UserService</span>(<span class="class-name">UserRepository</span> userRepository) {
        <span class="keyword">this</span>.userRepository = userRepository;
    }

    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">getUserById</span>(<span class="keyword">int</span> id) {
        <span class="keyword">return</span> userRepository.findById(id);
    }
}</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Benefits of IoC</div>
                <ul>
                    <li>Loose coupling between classes</li>
                    <li>Easier testing (can inject mocks)</li>
                    <li>Better separation of concerns</li>
                    <li>Centralized configuration</li>
                </ul>
            </div>
        </section>

        <!-- Dependency Injection -->
        <section class="content-section">
            <h2>Dependency Injection (DI)</h2>
            <p>DI is the implementation of IoC where dependencies are "injected" into objects by the container instead of objects creating their own dependencies.</p>

            <h3>Types of Dependency Injection</h3>

            <h4>1. Constructor Injection (Recommended)</h4>
            <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">OrderService</span> {
    <span class="keyword">private final</span> <span class="class-name">OrderRepository</span> orderRepository;
    <span class="keyword">private final</span> <span class="class-name">PaymentService</span> paymentService;

    <span class="comment">// Constructor injection - dependencies are injected via constructor</span>
    <span class="annotation">@Autowired</span> <span class="comment">// @Autowired is optional if there's only one constructor</span>
    <span class="keyword">public</span> <span class="function">OrderService</span>(<span class="class-name">OrderRepository</span> orderRepository,
                       <span class="class-name">PaymentService</span> paymentService) {
        <span class="keyword">this</span>.orderRepository = orderRepository;
        <span class="keyword">this</span>.paymentService = paymentService;
    }

    <span class="keyword">public void</span> <span class="function">processOrder</span>(<span class="class-name">Order</span> order) {
        orderRepository.save(order);
        paymentService.processPayment(order);
    }
}</code></pre>

            <h4>2. Setter Injection</h4>
            <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">EmailService</span> {
    <span class="keyword">private</span> <span class="class-name">EmailProvider</span> emailProvider;

    <span class="comment">// Setter injection - dependency injected via setter method</span>
    <span class="annotation">@Autowired</span>
    <span class="keyword">public void</span> <span class="function">setEmailProvider</span>(<span class="class-name">EmailProvider</span> emailProvider) {
        <span class="keyword">this</span>.emailProvider = emailProvider;
    }

    <span class="keyword">public void</span> <span class="function">sendEmail</span>(<span class="class-name">String</span> to, <span class="class-name">String</span> message) {
        emailProvider.send(to, message);
    }
}</code></pre>

            <h4>3. Field Injection (Not Recommended)</h4>
            <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">NotificationService</span> {
    <span class="comment">// Field injection - less preferred</span>
    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="class-name">EmailService</span> emailService;

    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="class-name">SmsService</span> smsService;

    <span class="keyword">public void</span> <span class="function">notifyUser</span>(<span class="class-name">User</span> user) {
        emailService.sendEmail(user.getEmail(), <span class="string">"Hello!"</span>);
        smsService.sendSms(user.getPhone(), <span class="string">"Hello!"</span>);
    }
}</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Why Constructor Injection is Preferred</div>
                <ul>
                    <li>Promotes immutability (final fields)</li>
                    <li>Makes dependencies explicit and required</li>
                    <li>Easier to test (can instantiate without Spring)</li>
                    <li>Prevents NullPointerExceptions</li>
                </ul>
            </div>
        </section>

        <!-- Spring Beans -->
        <section class="content-section">
            <h2>Spring Beans</h2>
            <p>A bean is an object that is instantiated, assembled, and managed by the Spring IoC container.</p>

            <h3>Declaring Beans with Annotations</h3>

            <h4>Component Scanning</h4>
            <pre><code><span class="comment">// Spring automatically detects and registers these as beans</span>

<span class="annotation">@Component</span>  <span class="comment">// Generic stereotype</span>
<span class="keyword">public class</span> <span class="class-name">UtilityComponent</span> {
    <span class="comment">// Component logic</span>
}

<span class="annotation">@Service</span>  <span class="comment">// Service layer stereotype</span>
<span class="keyword">public class</span> <span class="class-name">UserService</span> {
    <span class="comment">// Business logic</span>
}

<span class="annotation">@Repository</span>  <span class="comment">// Data access layer stereotype</span>
<span class="keyword">public class</span> <span class="class-name">UserRepository</span> {
    <span class="comment">// Database operations</span>
}

<span class="annotation">@Controller</span>  <span class="comment">// Presentation layer stereotype</span>
<span class="keyword">public class</span> <span class="class-name">UserController</span> {
    <span class="comment">// HTTP request handling</span>
}</code></pre>

            <h4>Java Configuration</h4>
            <pre><code><span class="keyword">import</span> org.springframework.context.annotation.*;

<span class="annotation">@Configuration</span>
<span class="keyword">public class</span> <span class="class-name">AppConfig</span> {

    <span class="annotation">@Bean</span>
    <span class="keyword">public</span> <span class="class-name">UserService</span> <span class="function">userService</span>() {
        <span class="keyword">return new</span> <span class="class-name">UserService</span>(userRepository());
    }

    <span class="annotation">@Bean</span>
    <span class="keyword">public</span> <span class="class-name">UserRepository</span> <span class="function">userRepository</span>() {
        <span class="keyword">return new</span> <span class="class-name">UserRepositoryImpl</span>();
    }

    <span class="comment">// Bean with custom name</span>
    <span class="annotation">@Bean</span>(name = <span class="string">"emailSender"</span>)
    <span class="keyword">public</span> <span class="class-name">EmailService</span> <span class="function">emailService</span>() {
        <span class="keyword">return new</span> <span class="class-name">EmailServiceImpl</span>();
    }
}</code></pre>
        </section>

        <!-- Bean Scopes -->
        <section class="content-section">
            <h2>Bean Scopes</h2>
            <p>Bean scope defines the lifecycle and visibility of bean instances.</p>

            <h3>Common Scopes</h3>

            <h4>Singleton (Default)</h4>
            <pre><code><span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(<span class="string">"singleton"</span>)  <span class="comment">// This is the default, can be omitted</span>
<span class="keyword">public class</span> <span class="class-name">ConfigService</span> {
    <span class="comment">// One instance per Spring container</span>
    <span class="comment">// Shared across the entire application</span>
}</code></pre>

            <h4>Prototype</h4>
            <pre><code><span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(<span class="string">"prototype"</span>)
<span class="keyword">public class</span> <span class="class-name">TaskProcessor</span> {
    <span class="comment">// New instance created every time it's requested</span>
    <span class="comment">// Useful for stateful objects</span>
}</code></pre>

            <h4>Web Scopes (Spring Web)</h4>
            <pre><code><span class="comment">// Request scope - one instance per HTTP request</span>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(value = <span class="class-name">WebApplicationContext</span>.SCOPE_REQUEST,
      proxyMode = <span class="class-name">ScopedProxyMode</span>.TARGET_CLASS)
<span class="keyword">public class</span> <span class="class-name">RequestContext</span> {
    <span class="comment">// New instance for each HTTP request</span>
}

<span class="comment">// Session scope - one instance per HTTP session</span>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(value = <span class="class-name">WebApplicationContext</span>.SCOPE_SESSION,
      proxyMode = <span class="class-name">ScopedProxyMode</span>.TARGET_CLASS)
<span class="keyword">public class</span> <span class="class-name">ShoppingCart</span> {
    <span class="comment">// Same instance throughout user's session</span>
}</code></pre>

            <div class="info-box note">
                <div class="info-box-title">Scope Summary</div>
                <ul>
                    <li><strong>singleton</strong> - One instance per container (default)</li>
                    <li><strong>prototype</strong> - New instance every time</li>
                    <li><strong>request</strong> - One per HTTP request (web apps)</li>
                    <li><strong>session</strong> - One per HTTP session (web apps)</li>
                    <li><strong>application</strong> - One per ServletContext (web apps)</li>
                </ul>
            </div>
        </section>

        <!-- Application Context -->
        <section class="content-section">
            <h2>Application Context</h2>
            <p>The ApplicationContext is the central interface for providing configuration to a Spring application.</p>

            <h3>Creating Application Context</h3>

            <h4>With Spring Boot (Recommended)</h4>
            <pre><code><span class="keyword">import</span> org.springframework.boot.SpringApplication;
<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="annotation">@SpringBootApplication</span>  <span class="comment">// Combines @Configuration, @EnableAutoConfiguration, @ComponentScan</span>
<span class="keyword">public class</span> <span class="class-name">Application</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="comment">// Spring Boot creates and manages the ApplicationContext</span>
        <span class="class-name">SpringApplication</span>.run(<span class="class-name">Application</span>.<span class="keyword">class</span>, args);
    }
}</code></pre>

            <h4>Programmatic Creation (Without Spring Boot)</h4>
            <pre><code><span class="keyword">import</span> org.springframework.context.ApplicationContext;
<span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;

<span class="keyword">public class</span> <span class="class-name">Main</span> {
    <span class="keyword">public static void</span> <span class="function">main</span>(<span class="class-name">String</span>[] args) {
        <span class="comment">// Create context from Java configuration</span>
        <span class="class-name">ApplicationContext</span> context =
            <span class="keyword">new</span> <span class="class-name">AnnotationConfigApplicationContext</span>(<span class="class-name">AppConfig</span>.<span class="keyword">class</span>);

        <span class="comment">// Retrieve beans</span>
        <span class="class-name">UserService</span> userService = context.getBean(<span class="class-name">UserService</span>.<span class="keyword">class</span>);
        userService.doSomething();

        <span class="comment">// Close context (important!)</span>
        ((<span class="class-name">AnnotationConfigApplicationContext</span>) context).close();
    }
}</code></pre>
        </section>

        <!-- Practical Example -->
        <section class="content-section">
            <h2>Complete Example</h2>
            <p>Here's a complete example showing IoC and DI in action:</p>

            <h3>1. Repository Layer</h3>
            <pre><code><span class="keyword">import</span> org.springframework.stereotype.Repository;
<span class="keyword">import</span> java.util.*;

<span class="annotation">@Repository</span>
<span class="keyword">public class</span> <span class="class-name">UserRepository</span> {
    <span class="keyword">private</span> <span class="class-name">Map</span>&lt;<span class="class-name">Long</span>, <span class="class-name">User</span>&gt; database = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();

    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">findById</span>(<span class="class-name">Long</span> id) {
        <span class="keyword">return</span> database.get(id);
    }

    <span class="keyword">public void</span> <span class="function">save</span>(<span class="class-name">User</span> user) {
        database.put(user.getId(), user);
    }

    <span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">findAll</span>() {
        <span class="keyword">return new</span> <span class="class-name">ArrayList</span>&lt;&gt;(database.values());
    }
}</code></pre>

            <h3>2. Service Layer</h3>
            <pre><code><span class="keyword">import</span> org.springframework.stereotype.Service;
<span class="keyword">import</span> java.util.*;

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">UserService</span> {
    <span class="keyword">private final</span> <span class="class-name">UserRepository</span> userRepository;
    <span class="keyword">private final</span> <span class="class-name">EmailService</span> emailService;

    <span class="comment">// Constructor injection</span>
    <span class="keyword">public</span> <span class="function">UserService</span>(<span class="class-name">UserRepository</span> userRepository,
                       <span class="class-name">EmailService</span> emailService) {
        <span class="keyword">this</span>.userRepository = userRepository;
        <span class="keyword">this</span>.emailService = emailService;
    }

    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">createUser</span>(<span class="class-name">User</span> user) {
        userRepository.save(user);
        emailService.sendWelcomeEmail(user.getEmail());
        <span class="keyword">return</span> user;
    }

    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">getUserById</span>(<span class="class-name">Long</span> id) {
        <span class="keyword">return</span> userRepository.findById(id);
    }

    <span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">getAllUsers</span>() {
        <span class="keyword">return</span> userRepository.findAll();
    }
}</code></pre>

            <h3>3. Supporting Service</h3>
            <pre><code><span class="keyword">import</span> org.springframework.stereotype.Service;

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">EmailService</span> {
    <span class="keyword">public void</span> <span class="function">sendWelcomeEmail</span>(<span class="class-name">String</span> email) {
        <span class="class-name">System</span>.out.println(<span class="string">"Sending welcome email to: "</span> + email);
        <span class="comment">// Email sending logic</span>
    }
}</code></pre>

            <h3>4. Controller (Optional)</h3>
            <pre><code><span class="keyword">import</span> org.springframework.web.bind.annotation.*;

<span class="annotation">@RestController</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/api/users"</span>)
<span class="keyword">public class</span> <span class="class-name">UserController</span> {
    <span class="keyword">private final</span> <span class="class-name">UserService</span> userService;

    <span class="keyword">public</span> <span class="function">UserController</span>(<span class="class-name">UserService</span> userService) {
        <span class="keyword">this</span>.userService = userService;
    }

    <span class="annotation">@GetMapping</span>
    <span class="keyword">public</span> <span class="class-name">List</span>&lt;<span class="class-name">User</span>&gt; <span class="function">getAllUsers</span>() {
        <span class="keyword">return</span> userService.getAllUsers();
    }

    <span class="annotation">@PostMapping</span>
    <span class="keyword">public</span> <span class="class-name">User</span> <span class="function">createUser</span>(<span class="annotation">@RequestBody</span> <span class="class-name">User</span> user) {
        <span class="keyword">return</span> userService.createUser(user);
    }
}</code></pre>
        </section>

        <!-- Why It Matters -->
        <section class="content-section">
            <h2>Why Spring Core Matters</h2>
            <ul>
                <li><strong>Loose Coupling</strong> - Classes depend on abstractions, not concrete implementations</li>
                <li><strong>Testability</strong> - Easy to inject mocks for unit testing</li>
                <li><strong>Maintainability</strong> - Changes in one class don't cascade to others</li>
                <li><strong>Flexibility</strong> - Easy to swap implementations</li>
                <li><strong>Centralized Configuration</strong> - All bean definitions in one place</li>
            </ul>
        </section>

        <!-- Common Pitfalls -->
        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">Circular Dependencies</div>
                <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">A</span> {
    <span class="keyword">private final</span> <span class="class-name">B</span> b;
    <span class="keyword">public</span> <span class="function">A</span>(<span class="class-name">B</span> b) { <span class="keyword">this</span>.b = b; }
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">B</span> {
    <span class="keyword">private final</span> <span class="class-name">A</span> a;
    <span class="keyword">public</span> <span class="function">B</span>(<span class="class-name">A</span> a) { <span class="keyword">this</span>.a = a; }  <span class="comment">// CIRCULAR DEPENDENCY!</span>
}

<span class="comment">// Solution: Redesign your classes or use @Lazy annotation</span></code></pre>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Field Injection Makes Testing Harder</div>
                <p>Use constructor injection instead of field injection for better testability and to make dependencies explicit.</p>
            </div>
        </section>

        <!-- Related Topics -->
        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="boot.html" class="related-link">Spring Boot Basics</a>
                <a href="mvc.html" class="related-link">Spring MVC</a>
                <a href="../jakarta-ee/cdi.html" class="related-link">CDI (Jakarta EE)</a>
                <a href="../fundamentals/oop-principles.html" class="related-link">OOP Principles</a>
                <a href="../best-practices/solid.html" class="related-link">SOLID Principles</a>
                <a href="../tools/testing.html" class="related-link">Testing</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
