<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transactions (ACID) - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#databases">Databases & Persistence</a> / Transactions (ACID)
            </nav>
            <h1>Transactions (ACID)</h1>
            <p class="topic-subtitle">Ensuring data integrity and consistency</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>What is a Transaction?</h2>
            <p>A <strong>transaction</strong> is a sequence of database operations that are treated as a single, indivisible unit of work. Either ALL operations complete successfully (commit), or NONE of them do (rollback). Transactions are fundamental to maintaining data integrity.</p>

            <h3>The Classic Example: Bank Transfer</h3>
            <pre><code><span class="comment">// Transfer $100 from Account A to Account B</span>
<span class="comment">// This MUST be atomic - both operations or neither!</span>

BEGIN TRANSACTION;

<span class="comment">// Step 1: Debit from Account A</span>
UPDATE accounts SET balance = balance - 100 WHERE id = 'A';

<span class="comment">// Step 2: Credit to Account B</span>
UPDATE accounts SET balance = balance + 100 WHERE id = 'B';

<span class="comment">// If both succeed</span>
COMMIT;

<span class="comment">// If anything fails</span>
ROLLBACK;

<span class="comment">// Without transactions, if step 1 succeeds but step 2 fails:</span>
<span class="comment">// - Account A loses $100</span>
<span class="comment">// - Account B doesn't gain $100</span>
<span class="comment">// - $100 just vanishes! BAD!</span></code></pre>
        </section>

        <section class="content-section">
            <h2>ACID Properties</h2>
            <p>ACID is the set of properties that guarantee transaction reliability.</p>

            <h3>A - Atomicity</h3>
            <pre><code><span class="comment">// ATOMICITY: "All or Nothing"</span>
<span class="comment">// A transaction is an atomic unit - it either completes entirely or not at all.</span>

┌───────────────────────────────────────────────────────────┐
│                     TRANSACTION                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │
│  │ Operation 1 │─▶│ Operation 2 │─▶│ Operation 3 │       │
│  └─────────────┘  └─────────────┘  └─────────────┘       │
│                                                           │
│  If ANY operation fails → ROLLBACK ALL                   │
│  If ALL operations succeed → COMMIT ALL                  │
└───────────────────────────────────────────────────────────┘

<span class="comment">// Example: Creating an order</span>
<span class="keyword">try</span> {
    tx.begin();

    <span class="comment">// 1. Create order</span>
    em.persist(order);

    <span class="comment">// 2. Create order items</span>
    <span class="keyword">for</span> (OrderItem item : items) {
        em.persist(item);
    }

    <span class="comment">// 3. Update inventory</span>
    <span class="keyword">for</span> (OrderItem item : items) {
        Product p = em.find(Product.<span class="keyword">class</span>, item.getProductId());
        p.setStock(p.getStock() - item.getQuantity());
    }

    <span class="comment">// 4. Charge customer</span>
    paymentService.charge(order.getCustomerId(), order.getTotal());

    tx.commit();  <span class="comment">// All 4 steps complete together</span>
} <span class="keyword">catch</span> (Exception e) {
    tx.rollback();  <span class="comment">// All 4 steps undone</span>
}</code></pre>

            <h3>C - Consistency</h3>
            <pre><code><span class="comment">// CONSISTENCY: Database moves from one valid state to another</span>
<span class="comment">// Transactions must maintain all database rules and constraints.</span>

<span class="comment">// Example constraints that must be maintained:</span>
<span class="comment">// - Primary key uniqueness</span>
<span class="comment">// - Foreign key references</span>
<span class="comment">// - Check constraints (balance >= 0)</span>
<span class="comment">// - Unique constraints (email must be unique)</span>

<span class="comment">// Before transaction: Total money in system = $10,000</span>
<span class="comment">// After transaction: Total money in system = $10,000</span>
<span class="comment">// Money doesn't appear or disappear!</span>

┌─────────────────┐                      ┌─────────────────┐
│  VALID STATE    │                      │  VALID STATE    │
│                 │                      │                 │
│  Account A: 500 │      Transaction     │  Account A: 400 │
│  Account B: 300 │  ─────────────────▶  │  Account B: 400 │
│  ─────────────  │                      │  ─────────────  │
│  Total:    800  │                      │  Total:    800  │
└─────────────────┘                      └─────────────────┘</code></pre>

            <h3>I - Isolation</h3>
            <pre><code><span class="comment">// ISOLATION: Concurrent transactions don't interfere with each other</span>
<span class="comment">// Each transaction sees a consistent snapshot of data.</span>

<span class="comment">// Problem without isolation (Lost Update):</span>

Time    Transaction 1             Transaction 2
───────────────────────────────────────────────────
T1      Read balance = 100
T2                                Read balance = 100
T3      Balance = 100 + 50
T4      Write balance = 150
T5                                Balance = 100 + 30
T6                                Write balance = 130  <span class="comment">← T1's update LOST!</span>

<span class="comment">// With proper isolation:</span>
Time    Transaction 1             Transaction 2
───────────────────────────────────────────────────
T1      Read balance = 100
T2                                Read balance = 100 (waits or sees 100)
T3      Balance = 100 + 50
T4      Write balance = 150
T5      COMMIT
T6                                Read balance = 150
T7                                Balance = 150 + 30
T8                                Write balance = 180  <span class="comment">← Both updates preserved!</span></code></pre>

            <h3>D - Durability</h3>
            <pre><code><span class="comment">// DURABILITY: Once committed, data survives any failure</span>
<span class="comment">// Power outage, crash, hardware failure - data persists!</span>

<span class="comment">// How databases achieve durability:</span>

┌─────────────────────────────────────────────────────────────────┐
│                    COMMIT PROCESS                                │
│                                                                  │
│  1. Write changes to TRANSACTION LOG (Write-Ahead Logging)      │
│     └─▶ Log is on persistent storage (disk)                     │
│                                                                  │
│  2. Flush log to disk (fsync)                                   │
│     └─▶ Data guaranteed on stable storage                       │
│                                                                  │
│  3. Return "commit successful" to application                   │
│                                                                  │
│  4. Write actual data pages to disk (can be lazy)               │
│     └─▶ If crash before this, recover from log                  │
│                                                                  │
│  After commit: Even if server explodes, data is safe!           │
└─────────────────────────────────────────────────────────────────┘</code></pre>

            <div class="info-box">
                <p><strong>ACID Summary:</strong></p>
                <ul>
                    <li><strong>Atomicity:</strong> All or nothing</li>
                    <li><strong>Consistency:</strong> Valid state to valid state</li>
                    <li><strong>Isolation:</strong> Transactions don't interfere</li>
                    <li><strong>Durability:</strong> Committed = permanent</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Transaction Isolation Levels</h2>
            <p>Isolation levels control how much transactions are isolated from each other. Higher isolation = more safety but less performance.</p>

            <h3>Concurrency Problems</h3>
            <pre><code><span class="comment">// 1. DIRTY READ: Reading uncommitted data from another transaction</span>
Transaction 1                    Transaction 2
─────────────────────────────────────────────────
UPDATE balance SET val=150
                                 SELECT val FROM balance  <span class="comment">→ 150 (dirty!)</span>
ROLLBACK
                                 <span class="comment">Uses 150, but actual value is still 100!</span>

<span class="comment">// 2. NON-REPEATABLE READ: Same query returns different results</span>
Transaction 1                    Transaction 2
─────────────────────────────────────────────────
SELECT val FROM balance <span class="comment">→ 100</span>
                                 UPDATE balance SET val=150
                                 COMMIT
SELECT val FROM balance <span class="comment">→ 150</span>   <span class="comment">Different result!</span>

<span class="comment">// 3. PHANTOM READ: New rows appear in repeated query</span>
Transaction 1                    Transaction 2
─────────────────────────────────────────────────
SELECT * WHERE age > 25  <span class="comment">→ 3 rows</span>
                                 INSERT INTO users (age=30)
                                 COMMIT
SELECT * WHERE age > 25  <span class="comment">→ 4 rows</span>  <span class="comment">Phantom row!</span></code></pre>

            <h3>Isolation Levels Comparison</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Isolation Level</th>
                        <th>Dirty Read</th>
                        <th>Non-Repeatable</th>
                        <th>Phantom Read</th>
                        <th>Performance</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>READ_UNCOMMITTED</strong></td>
                        <td>Possible</td>
                        <td>Possible</td>
                        <td>Possible</td>
                        <td>Fastest</td>
                    </tr>
                    <tr>
                        <td><strong>READ_COMMITTED</strong></td>
                        <td>Prevented</td>
                        <td>Possible</td>
                        <td>Possible</td>
                        <td>Fast</td>
                    </tr>
                    <tr>
                        <td><strong>REPEATABLE_READ</strong></td>
                        <td>Prevented</td>
                        <td>Prevented</td>
                        <td>Possible</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td><strong>SERIALIZABLE</strong></td>
                        <td>Prevented</td>
                        <td>Prevented</td>
                        <td>Prevented</td>
                        <td>Slowest</td>
                    </tr>
                </tbody>
            </table>

            <h3>Setting Isolation Levels</h3>
            <pre><code><span class="comment">// JDBC</span>
Connection conn = dataSource.getConnection();
conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);

<span class="comment">// JPA/Hibernate</span>
<span class="annotation">@PersistenceContext</span>
EntityManager em;

Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();
props.put(<span class="string">"jakarta.persistence.lock.timeout"</span>, 3000);
em.find(Account.<span class="keyword">class</span>, accountId, LockModeType.PESSIMISTIC_WRITE, props);

<span class="comment">// Spring @Transactional</span>
<span class="annotation">@Transactional</span>(isolation = Isolation.SERIALIZABLE)
<span class="keyword">public void</span> <span class="function">criticalOperation</span>() {
    <span class="comment">// Highest isolation</span>
}

<span class="annotation">@Transactional</span>(isolation = Isolation.READ_COMMITTED)  <span class="comment">// Default for most DBs</span>
<span class="keyword">public void</span> <span class="function">normalOperation</span>() {
    <span class="comment">// Standard isolation</span>
}</code></pre>

            <div class="info-box tip">
                <div class="info-box-title">Default Isolation Levels</div>
                <ul>
                    <li><strong>MySQL (InnoDB):</strong> REPEATABLE_READ</li>
                    <li><strong>PostgreSQL:</strong> READ_COMMITTED</li>
                    <li><strong>Oracle:</strong> READ_COMMITTED</li>
                    <li><strong>SQL Server:</strong> READ_COMMITTED</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Transactions in Java</h2>

            <h3>JDBC Transactions</h3>
            <pre><code><span class="keyword">public void</span> <span class="function">transferFunds</span>(<span class="keyword">long</span> fromId, <span class="keyword">long</span> toId, BigDecimal amount) {
    Connection conn = <span class="keyword">null</span>;

    <span class="keyword">try</span> {
        conn = dataSource.getConnection();

        <span class="comment">// 1. Disable auto-commit (start transaction)</span>
        conn.setAutoCommit(<span class="keyword">false</span>);

        <span class="comment">// 2. Debit source account</span>
        <span class="keyword">try</span> (PreparedStatement debitStmt = conn.prepareStatement(
                <span class="string">"UPDATE accounts SET balance = balance - ? WHERE id = ? AND balance >= ?"</span>)) {
            debitStmt.setBigDecimal(1, amount);
            debitStmt.setLong(2, fromId);
            debitStmt.setBigDecimal(3, amount);

            <span class="keyword">if</span> (debitStmt.executeUpdate() == 0) {
                <span class="keyword">throw new</span> RuntimeException(<span class="string">"Insufficient funds"</span>);
            }
        }

        <span class="comment">// 3. Credit destination account</span>
        <span class="keyword">try</span> (PreparedStatement creditStmt = conn.prepareStatement(
                <span class="string">"UPDATE accounts SET balance = balance + ? WHERE id = ?"</span>)) {
            creditStmt.setBigDecimal(1, amount);
            creditStmt.setLong(2, toId);
            creditStmt.executeUpdate();
        }

        <span class="comment">// 4. Commit transaction</span>
        conn.commit();

    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// 5. Rollback on any error</span>
        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                conn.rollback();
            } <span class="keyword">catch</span> (SQLException ex) {
                ex.printStackTrace();
            }
        }
        <span class="keyword">throw new</span> RuntimeException(<span class="string">"Transfer failed"</span>, e);

    } <span class="keyword">finally</span> {
        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                conn.setAutoCommit(<span class="keyword">true</span>);  <span class="comment">// Reset for connection pool</span>
                conn.close();
            } <span class="keyword">catch</span> (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>

            <h3>JPA/Hibernate Transactions</h3>
            <pre><code><span class="keyword">public void</span> <span class="function">transferFunds</span>(<span class="keyword">long</span> fromId, <span class="keyword">long</span> toId, BigDecimal amount) {
    EntityManager em = emf.createEntityManager();
    EntityTransaction tx = em.getTransaction();

    <span class="keyword">try</span> {
        tx.begin();

        Account fromAccount = em.find(Account.<span class="keyword">class</span>, fromId, LockModeType.PESSIMISTIC_WRITE);
        Account toAccount = em.find(Account.<span class="keyword">class</span>, toId, LockModeType.PESSIMISTIC_WRITE);

        <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) < 0) {
            <span class="keyword">throw new</span> RuntimeException(<span class="string">"Insufficient funds"</span>);
        }

        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        toAccount.setBalance(toAccount.getBalance().add(amount));

        tx.commit();

    } <span class="keyword">catch</span> (Exception e) {
        <span class="keyword">if</span> (tx.isActive()) {
            tx.rollback();
        }
        <span class="keyword">throw</span> e;

    } <span class="keyword">finally</span> {
        em.close();
    }
}</code></pre>

            <h3>Spring @Transactional</h3>
            <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">AccountService</span> {

    <span class="keyword">private final</span> AccountRepository accountRepository;

    <span class="comment">// Basic transaction</span>
    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">transferFunds</span>(Long fromId, Long toId, BigDecimal amount) {
        Account from = accountRepository.findById(fromId)
            .orElseThrow(() -> <span class="keyword">new</span> AccountNotFoundException(fromId));
        Account to = accountRepository.findById(toId)
            .orElseThrow(() -> <span class="keyword">new</span> AccountNotFoundException(toId));

        <span class="keyword">if</span> (from.getBalance().compareTo(amount) < 0) {
            <span class="keyword">throw new</span> InsufficientFundsException();
        }

        from.withdraw(amount);
        to.deposit(amount);
        <span class="comment">// Commit happens automatically if no exception</span>
        <span class="comment">// Rollback happens automatically on RuntimeException</span>
    }

    <span class="comment">// Read-only transaction (optimization)</span>
    <span class="annotation">@Transactional</span>(readOnly = <span class="keyword">true</span>)
    <span class="keyword">public</span> Account <span class="function">getAccount</span>(Long id) {
        <span class="keyword">return</span> accountRepository.findById(id).orElseThrow();
    }

    <span class="comment">// Custom timeout</span>
    <span class="annotation">@Transactional</span>(timeout = 30)  <span class="comment">// 30 seconds</span>
    <span class="keyword">public void</span> <span class="function">longRunningOperation</span>() {
        <span class="comment">// ...</span>
    }

    <span class="comment">// Specify which exceptions cause rollback</span>
    <span class="annotation">@Transactional</span>(
        rollbackFor = Exception.<span class="keyword">class</span>,           <span class="comment">// Rollback for all exceptions</span>
        noRollbackFor = EmailException.<span class="keyword">class</span>    <span class="comment">// Except this one</span>
    )
    <span class="keyword">public void</span> <span class="function">createUserAndNotify</span>(User user) {
        userRepository.save(user);
        emailService.sendWelcome(user);  <span class="comment">// Email failure won't rollback user creation</span>
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Transaction Propagation (Spring)</h2>
            <p>Propagation defines how transactions behave when one @Transactional method calls another.</p>

            <pre><code><span class="comment">// REQUIRED (default): Join existing or create new</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.REQUIRED)
<span class="keyword">public void</span> <span class="function">methodA</span>() {
    <span class="comment">// If called without transaction → creates new</span>
    <span class="comment">// If called within transaction → joins it</span>
}

<span class="comment">// REQUIRES_NEW: Always create new (suspends existing)</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)
<span class="keyword">public void</span> <span class="function">auditLog</span>(String action) {
    <span class="comment">// Always runs in its own transaction</span>
    <span class="comment">// Commits even if outer transaction rolls back</span>
}

<span class="comment">// MANDATORY: Must run within existing transaction</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.MANDATORY)
<span class="keyword">public void</span> <span class="function">mustBeInTransaction</span>() {
    <span class="comment">// Throws exception if no transaction exists</span>
}

<span class="comment">// SUPPORTS: Use transaction if exists, otherwise non-transactional</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.SUPPORTS)
<span class="keyword">public</span> Account <span class="function">findAccount</span>(Long id) {
    <span class="comment">// Works with or without transaction</span>
}

<span class="comment">// NOT_SUPPORTED: Always run non-transactionally</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)
<span class="keyword">public void</span> <span class="function">nonTransactionalOperation</span>() {
    <span class="comment">// Suspends existing transaction</span>
}

<span class="comment">// NEVER: Must NOT run within transaction</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.NEVER)
<span class="keyword">public void</span> <span class="function">mustNotBeInTransaction</span>() {
    <span class="comment">// Throws exception if transaction exists</span>
}

<span class="comment">// NESTED: Nested transaction with savepoint</span>
<span class="annotation">@Transactional</span>(propagation = Propagation.NESTED)
<span class="keyword">public void</span> <span class="function">nestedOperation</span>() {
    <span class="comment">// Creates savepoint, can rollback independently</span>
}</code></pre>

            <h3>Propagation Example</h3>
            <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">OrderService</span> {

    <span class="keyword">private final</span> PaymentService paymentService;
    <span class="keyword">private final</span> AuditService auditService;

    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">placeOrder</span>(Order order) {
        <span class="comment">// Save order (within this transaction)</span>
        orderRepository.save(order);

        <span class="comment">// Process payment (within this transaction - REQUIRED)</span>
        paymentService.processPayment(order);  <span class="comment">// Joins transaction</span>

        <span class="comment">// Audit log (separate transaction - REQUIRES_NEW)</span>
        auditService.logOrderPlaced(order);  <span class="comment">// Own transaction</span>

        <span class="comment">// If payment fails, order is rolled back</span>
        <span class="comment">// But audit log is already committed!</span>
    }
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">PaymentService</span> {

    <span class="annotation">@Transactional</span>(propagation = Propagation.REQUIRED)  <span class="comment">// Default</span>
    <span class="keyword">public void</span> <span class="function">processPayment</span>(Order order) {
        <span class="comment">// Part of outer transaction</span>
    }
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">AuditService</span> {

    <span class="annotation">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)
    <span class="keyword">public void</span> <span class="function">logOrderPlaced</span>(Order order) {
        <span class="comment">// Always commits, even if outer rolls back</span>
    }
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Locking Strategies</h2>

            <h3>Optimistic Locking</h3>
            <pre><code><span class="comment">// Optimistic: Assume no conflicts, detect them at commit time</span>
<span class="comment">// Best for read-heavy workloads with rare conflicts</span>

<span class="annotation">@Entity</span>
<span class="keyword">public class</span> <span class="class-name">Product</span> {

    <span class="annotation">@Id</span>
    <span class="keyword">private</span> Long id;

    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> Integer quantity;

    <span class="annotation">@Version</span>  <span class="comment">// Optimistic locking version field</span>
    <span class="keyword">private</span> Long version;
}

<span class="comment">// How it works:</span>
<span class="comment">// 1. Read product (version = 1)</span>
<span class="comment">// 2. Modify product</span>
<span class="comment">// 3. UPDATE product SET ..., version = 2 WHERE id = ? AND version = 1</span>
<span class="comment">// 4. If 0 rows updated → OptimisticLockException (someone else modified!)</span>

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">ProductService</span> {

    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">updateQuantity</span>(Long productId, Integer newQuantity) {
        <span class="keyword">try</span> {
            Product product = productRepository.findById(productId).orElseThrow();
            product.setQuantity(newQuantity);
            <span class="comment">// On save, JPA checks version</span>
        } <span class="keyword">catch</span> (OptimisticLockException e) {
            <span class="comment">// Another transaction modified this product</span>
            <span class="keyword">throw new</span> ConcurrentModificationException(<span class="string">"Product was modified by another user"</span>);
        }
    }
}</code></pre>

            <h3>Pessimistic Locking</h3>
            <pre><code><span class="comment">// Pessimistic: Assume conflicts, prevent them with locks</span>
<span class="comment">// Best for high-contention scenarios</span>

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">InventoryService</span> {

    <span class="annotation">@PersistenceContext</span>
    <span class="keyword">private</span> EntityManager em;

    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">decrementStock</span>(Long productId, <span class="keyword">int</span> quantity) {
        <span class="comment">// Acquire exclusive lock (FOR UPDATE)</span>
        Product product = em.find(
            Product.<span class="keyword">class</span>,
            productId,
            LockModeType.PESSIMISTIC_WRITE  <span class="comment">// SELECT ... FOR UPDATE</span>
        );

        <span class="keyword">if</span> (product.getStock() < quantity) {
            <span class="keyword">throw new</span> InsufficientStockException();
        }

        product.setStock(product.getStock() - quantity);
        <span class="comment">// Lock released on commit/rollback</span>
    }
}

<span class="comment">// Lock modes:</span>
LockModeType.PESSIMISTIC_READ   <span class="comment">// Shared lock (read allowed, write blocked)</span>
LockModeType.PESSIMISTIC_WRITE  <span class="comment">// Exclusive lock (all access blocked)</span>
LockModeType.PESSIMISTIC_FORCE_INCREMENT  <span class="comment">// Exclusive + increment version</span>

<span class="comment">// With JPQL</span>
List&lt;Product&gt; products = em.createQuery(
    <span class="string">"SELECT p FROM Product p WHERE p.category = :cat"</span>, Product.<span class="keyword">class</span>)
    .setParameter(<span class="string">"cat"</span>, category)
    .setLockMode(LockModeType.PESSIMISTIC_WRITE)
    .getResultList();

<span class="comment">// Spring Data JPA</span>
<span class="keyword">public interface</span> <span class="class-name">ProductRepository</span> <span class="keyword">extends</span> JpaRepository&lt;Product, Long&gt; {

    <span class="annotation">@Lock</span>(LockModeType.PESSIMISTIC_WRITE)
    <span class="annotation">@Query</span>(<span class="string">"SELECT p FROM Product p WHERE p.id = :id"</span>)
    Optional&lt;Product&gt; <span class="function">findByIdForUpdate</span>(<span class="annotation">@Param</span>(<span class="string">"id"</span>) Long id);
}</code></pre>

            <h3>Optimistic vs Pessimistic</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Optimistic</th>
                        <th>Pessimistic</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Approach</strong></td>
                        <td>Detect conflicts</td>
                        <td>Prevent conflicts</td>
                    </tr>
                    <tr>
                        <td><strong>Locking</strong></td>
                        <td>No actual locks</td>
                        <td>Database row locks</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>Better for reads</td>
                        <td>Better for high contention</td>
                    </tr>
                    <tr>
                        <td><strong>Conflict handling</strong></td>
                        <td>Exception at commit</td>
                        <td>Blocked until lock released</td>
                    </tr>
                    <tr>
                        <td><strong>Deadlock risk</strong></td>
                        <td>None</td>
                        <td>Possible</td>
                    </tr>
                    <tr>
                        <td><strong>Use case</strong></td>
                        <td>Web applications</td>
                        <td>Financial systems</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="content-section">
            <h2>Common Transaction Pitfalls</h2>

            <div class="best-practices">
                <h3>1. Self-Invocation (Proxy Bypass)</h3>
                <pre><code><span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">OrderService</span> {

    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">placeOrder</span>(Order order) {
        saveOrder(order);    <span class="comment">// Calls method below</span>
        processPayment(order);
    }

    <span class="annotation">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)
    <span class="keyword">public void</span> <span class="function">saveOrder</span>(Order order) {
        <span class="comment">// THIS DOESN'T GET ITS OWN TRANSACTION!</span>
        <span class="comment">// Self-invocation bypasses the proxy!</span>
    }
}

<span class="comment">// Solution: Inject self or use separate service</span>
<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class-name">OrderService</span> {

    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> OrderPersistenceService persistenceService;

    <span class="annotation">@Transactional</span>
    <span class="keyword">public void</span> <span class="function">placeOrder</span>(Order order) {
        persistenceService.saveOrder(order);  <span class="comment">// Proxy is used!</span>
        processPayment(order);
    }
}</code></pre>

                <h3>2. Catching Exceptions</h3>
                <pre><code><span class="comment">// BAD: Swallowing exception prevents rollback</span>
<span class="annotation">@Transactional</span>
<span class="keyword">public void</span> <span class="function">badMethod</span>() {
    <span class="keyword">try</span> {
        riskyOperation();
    } <span class="keyword">catch</span> (Exception e) {
        log.error(<span class="string">"Error"</span>, e);
        <span class="comment">// Transaction commits! Data may be inconsistent!</span>
    }
}

<span class="comment">// GOOD: Re-throw or manually rollback</span>
<span class="annotation">@Transactional</span>
<span class="keyword">public void</span> <span class="function">goodMethod</span>() {
    <span class="keyword">try</span> {
        riskyOperation();
    } <span class="keyword">catch</span> (Exception e) {
        log.error(<span class="string">"Error"</span>, e);
        <span class="keyword">throw</span> e;  <span class="comment">// Transaction rolls back</span>
    }
}

<span class="comment">// OR: Mark for rollback manually</span>
<span class="annotation">@Autowired</span>
TransactionStatus status;

<span class="keyword">try</span> {
    riskyOperation();
} <span class="keyword">catch</span> (Exception e) {
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
}</code></pre>

                <h3>3. Long Transactions</h3>
                <pre><code><span class="comment">// BAD: Transaction held during external call</span>
<span class="annotation">@Transactional</span>
<span class="keyword">public void</span> <span class="function">processOrder</span>(Order order) {
    orderRepository.save(order);
    externalPaymentService.charge(order);  <span class="comment">// HTTP call! 5 seconds!</span>
    <span class="comment">// Database connection held for entire time</span>
}

<span class="comment">// GOOD: External calls outside transaction</span>
<span class="keyword">public void</span> <span class="function">processOrder</span>(Order order) {
    Order savedOrder = saveOrder(order);  <span class="comment">// Transaction 1</span>
    PaymentResult result = externalPaymentService.charge(order);  <span class="comment">// No tx</span>
    updateOrderStatus(savedOrder, result);  <span class="comment">// Transaction 2</span>
}

<span class="annotation">@Transactional</span>
<span class="keyword">private</span> Order <span class="function">saveOrder</span>(Order order) {
    <span class="keyword">return</span> orderRepository.save(order);
}</code></pre>
            </div>
        </section>

        <section class="content-section">
            <h2>Summary</h2>
            <div class="info-box">
                <ul>
                    <li><strong>Transaction:</strong> Atomic unit of database work</li>
                    <li><strong>ACID:</strong> Atomicity, Consistency, Isolation, Durability</li>
                    <li><strong>Isolation Levels:</strong> READ_UNCOMMITTED to SERIALIZABLE</li>
                    <li><strong>@Transactional:</strong> Spring's declarative transaction management</li>
                    <li><strong>Propagation:</strong> How transactions interact when nested</li>
                    <li><strong>Optimistic Locking:</strong> @Version field, detect conflicts</li>
                    <li><strong>Pessimistic Locking:</strong> FOR UPDATE, prevent conflicts</li>
                    <li><strong>Common pitfalls:</strong> Self-invocation, swallowed exceptions, long transactions</li>
                </ul>
            </div>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="jdbc.html" class="related-link">JDBC</a>
                <a href="jpa-hibernate.html" class="related-link">JPA & Hibernate</a>
                <a href="connection-pooling.html" class="related-link">Connection Pooling</a>
                <a href="../jakarta-ee/transactions.html" class="related-link">Jakarta EE Transactions</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
