<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Runtime vs Compile Time - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#java-versions">Java Versions</a> / Runtime vs Compile Time
            </nav>
            <h1>Runtime vs Compile Time</h1>
            <p class="topic-subtitle">Understanding When Things Happen in Java</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>The Two Phases of Java</h2>
            <p>Java programs go through two distinct phases: compilation (when source code becomes bytecode) and runtime (when bytecode executes on the JVM). Understanding what happens in each phase is fundamental to Java development.</p>

            <div class="info-box note">
                <div class="info-box-title">Key Distinction</div>
                <ul>
                    <li><strong>Compile Time</strong> - Source code (.java) &rarr; Bytecode (.class)</li>
                    <li><strong>Runtime</strong> - JVM executes the bytecode</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Compile Time</h2>
            <p>Compile time is when the Java compiler (javac) processes your source code. The compiler performs syntax checking, type checking, and generates bytecode.</p>

            <h3>What Happens at Compile Time</h3>
            <pre><code><span class="comment">// 1. Syntax checking</span>
<span class="keyword">int</span> x = <span class="number">5</span>  <span class="comment">// Error: missing semicolon</span>

<span class="comment">// 2. Type checking</span>
<span class="class-name">String</span> name = <span class="number">42</span>;  <span class="comment">// Error: incompatible types</span>

<span class="comment">// 3. Symbol resolution</span>
<span class="class-name">System</span>.out.printn(<span class="string">"Hi"</span>);  <span class="comment">// Error: cannot find symbol 'printn'</span>

<span class="comment">// 4. Access checking</span>
<span class="keyword">private</span> <span class="keyword">int</span> secret = <span class="number">10</span>;
obj.secret = <span class="number">20</span>;  <span class="comment">// Error: secret has private access</span>

<span class="comment">// 5. Constant folding (optimization)</span>
<span class="keyword">int</span> result = <span class="number">2</span> + <span class="number">3</span>;  <span class="comment">// Compiled as: int result = 5;</span></code></pre>

            <h3>Compile-Time Constants</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Constants</span> {
    <span class="comment">// Compile-time constant (known at compilation)</span>
    <span class="keyword">static final int</span> MAX_SIZE = <span class="number">100</span>;

    <span class="comment">// NOT a compile-time constant (computed at runtime)</span>
    <span class="keyword">static final int</span> RANDOM = <span class="keyword">new</span> <span class="class-name">Random</span>().nextInt();

    <span class="comment">// Compile-time constant expression</span>
    <span class="keyword">static final int</span> DOUBLE_MAX = MAX_SIZE * <span class="number">2</span>;  <span class="comment">// Evaluated at compile time</span>
}

<span class="comment">// Usage - MAX_SIZE is inlined at compile time</span>
<span class="keyword">int</span> limit = <span class="class-name">Constants</span>.MAX_SIZE;  <span class="comment">// Compiled as: int limit = 100;</span></code></pre>

            <h3>Compile-Time Errors</h3>
            <pre><code><span class="comment">// These errors prevent compilation:</span>

<span class="comment">// Syntax error</span>
<span class="keyword">public class</span> { }  <span class="comment">// Missing class name</span>

<span class="comment">// Type mismatch</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; names = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;<span class="class-name">Integer</span>&gt;();  <span class="comment">// Error!</span>

<span class="comment">// Unchecked exception not caught</span>
<span class="keyword">public void</span> <span class="function">read</span>() {
    <span class="keyword">new</span> <span class="class-name">FileReader</span>(<span class="string">"file.txt"</span>);  <span class="comment">// Error: unhandled IOException</span>
}

<span class="comment">// Missing return statement</span>
<span class="keyword">public int</span> <span class="function">getValue</span>() {
    <span class="keyword">int</span> x = <span class="number">5</span>;
    <span class="comment">// Error: missing return statement</span>
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Runtime</h2>
            <p>Runtime is when the JVM loads and executes the compiled bytecode. Many operations that can't be checked at compile time happen here.</p>

            <h3>What Happens at Runtime</h3>
            <pre><code><span class="comment">// 1. Object creation</span>
<span class="class-name">Object</span> obj = <span class="keyword">new</span> <span class="class-name">MyClass</span>();  <span class="comment">// Memory allocated at runtime</span>

<span class="comment">// 2. Method dispatch (polymorphism)</span>
<span class="class-name">Animal</span> animal = getAnimal();  <span class="comment">// Could be Dog, Cat, etc.</span>
animal.speak();  <span class="comment">// Actual method determined at runtime</span>

<span class="comment">// 3. Array bounds checking</span>
<span class="keyword">int</span>[] arr = <span class="keyword">new int</span>[<span class="number">5</span>];
arr[<span class="number">10</span>] = <span class="number">1</span>;  <span class="comment">// ArrayIndexOutOfBoundsException at runtime</span>

<span class="comment">// 4. Null checks</span>
<span class="class-name">String</span> s = <span class="keyword">null</span>;
s.length();  <span class="comment">// NullPointerException at runtime</span>

<span class="comment">// 5. Class loading</span>
<span class="class-name">Class</span>&lt;?&gt; clazz = <span class="class-name">Class</span>.forName(<span class="string">"com.example.MyClass"</span>);  <span class="comment">// Loaded at runtime</span></code></pre>

            <h3>Runtime Exceptions</h3>
            <pre><code><span class="comment">// These errors occur during execution:</span>

<span class="comment">// NullPointerException</span>
<span class="class-name">String</span> name = <span class="keyword">null</span>;
name.toUpperCase();  <span class="comment">// Crashes at runtime</span>

<span class="comment">// ClassCastException</span>
<span class="class-name">Object</span> obj = <span class="string">"Hello"</span>;
<span class="class-name">Integer</span> num = (<span class="class-name">Integer</span>) obj;  <span class="comment">// Crashes at runtime</span>

<span class="comment">// ArithmeticException</span>
<span class="keyword">int</span> result = <span class="number">10</span> / <span class="number">0</span>;  <span class="comment">// Crashes at runtime</span>

<span class="comment">// OutOfMemoryError</span>
<span class="class-name">List</span>&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
<span class="keyword">while</span> (<span class="keyword">true</span>) {
    list.add(<span class="keyword">new byte</span>[<span class="number">1_000_000</span>]);  <span class="comment">// Eventually crashes</span>
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Type Erasure: Compile Time vs Runtime</h2>
            <p>Generics in Java are a compile-time feature. Due to type erasure, generic type information is removed at runtime.</p>

            <pre><code><span class="comment">// At compile time - type checking happens</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; strings = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
strings.add(<span class="string">"hello"</span>);
strings.add(<span class="number">42</span>);  <span class="comment">// Compile error!</span>

<span class="comment">// At runtime - type is erased</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; strings = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
<span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; ints = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();

<span class="comment">// At runtime, both are just "List" (raw type)</span>
<span class="class-name">System</span>.out.println(strings.getClass() == ints.getClass());  <span class="comment">// true!</span>

<span class="comment">// This is why you can't do:</span>
<span class="keyword">if</span> (list <span class="keyword">instanceof</span> <span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt;) { }  <span class="comment">// Compile error!</span>
<span class="keyword">if</span> (list <span class="keyword">instanceof</span> <span class="class-name">List</span>&lt;?&gt;) { }      <span class="comment">// OK - unbounded wildcard</span></code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Type Erasure Implications</div>
                <p>Generic type parameters are not available at runtime. You cannot create generic arrays, check instanceof with generic types, or get generic type info via reflection (without extra tricks).</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Annotations: Compile vs Runtime</h2>
            <p>Annotations can be retained for different phases based on their retention policy.</p>

            <pre><code><span class="comment">// SOURCE - discarded after compilation</span>
<span class="annotation">@Retention</span>(<span class="class-name">RetentionPolicy</span>.SOURCE)
<span class="keyword">public @interface</span> <span class="class-name">Todo</span> { }  <span class="comment">// Not in .class file</span>

<span class="comment">// CLASS - in .class file, not available at runtime (default)</span>
<span class="annotation">@Retention</span>(<span class="class-name">RetentionPolicy</span>.CLASS)
<span class="keyword">public @interface</span> <span class="class-name">InBytecode</span> { }

<span class="comment">// RUNTIME - available via reflection at runtime</span>
<span class="annotation">@Retention</span>(<span class="class-name">RetentionPolicy</span>.RUNTIME)
<span class="keyword">public @interface</span> <span class="class-name">MyAnnotation</span> { }

<span class="comment">// Common examples:</span>
<span class="annotation">@Override</span>      <span class="comment">// SOURCE - compiler checks, then discarded</span>
<span class="annotation">@Deprecated</span>   <span class="comment">// RUNTIME - available for reflection</span>
<span class="annotation">@Entity</span>       <span class="comment">// RUNTIME - JPA reads at runtime</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Static vs Dynamic Binding</h2>

            <h3>Static Binding (Compile Time)</h3>
            <pre><code><span class="keyword">public class</span> <span class="class-name">Example</span> {
    <span class="comment">// Method overloading - resolved at compile time</span>
    <span class="keyword">public void</span> <span class="function">print</span>(<span class="class-name">String</span> s) {
        <span class="class-name">System</span>.out.println(<span class="string">"String: "</span> + s);
    }

    <span class="keyword">public void</span> <span class="function">print</span>(<span class="class-name">Integer</span> i) {
        <span class="class-name">System</span>.out.println(<span class="string">"Integer: "</span> + i);
    }

    <span class="comment">// Static methods - bound at compile time</span>
    <span class="keyword">public static void</span> <span class="function">staticMethod</span>() { }

    <span class="comment">// Private methods - bound at compile time</span>
    <span class="keyword">private void</span> <span class="function">privateMethod</span>() { }

    <span class="comment">// Final methods - bound at compile time</span>
    <span class="keyword">public final void</span> <span class="function">finalMethod</span>() { }
}</code></pre>

            <h3>Dynamic Binding (Runtime)</h3>
            <pre><code><span class="keyword">class</span> <span class="class-name">Animal</span> {
    <span class="keyword">public void</span> <span class="function">speak</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Animal speaks"</span>);
    }
}

<span class="keyword">class</span> <span class="class-name">Dog</span> <span class="keyword">extends</span> <span class="class-name">Animal</span> {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">speak</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Dog barks"</span>);
    }
}

<span class="comment">// Dynamic binding - actual method determined at runtime</span>
<span class="class-name">Animal</span> animal = <span class="keyword">new</span> <span class="class-name">Dog</span>();
animal.speak();  <span class="comment">// Prints "Dog barks" (determined at runtime)</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Reflection: Runtime Introspection</h2>
            <pre><code><span class="comment">// Reflection provides runtime access to class information</span>

<span class="class-name">Class</span>&lt;?&gt; clazz = <span class="class-name">MyClass</span>.<span class="keyword">class</span>;

<span class="comment">// Get methods at runtime</span>
<span class="class-name">Method</span>[] methods = clazz.getDeclaredMethods();

<span class="comment">// Create instance at runtime</span>
<span class="class-name">Object</span> instance = clazz.getDeclaredConstructor().newInstance();

<span class="comment">// Invoke method at runtime</span>
<span class="class-name">Method</span> method = clazz.getMethod(<span class="string">"myMethod"</span>);
method.invoke(instance);

<span class="comment">// Check annotations at runtime</span>
<span class="keyword">if</span> (clazz.isAnnotationPresent(<span class="class-name">MyAnnotation</span>.<span class="keyword">class</span>)) {
    <span class="class-name">MyAnnotation</span> ann = clazz.getAnnotation(<span class="class-name">MyAnnotation</span>.<span class="keyword">class</span>);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>Practical Comparison</h2>

            <table class="info-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Compile Time</th>
                        <th>Runtime</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Type Checking</td>
                        <td>Generics, method signatures</td>
                        <td>instanceof, casting</td>
                    </tr>
                    <tr>
                        <td>Method Resolution</td>
                        <td>Overloading, static methods</td>
                        <td>Overriding (polymorphism)</td>
                    </tr>
                    <tr>
                        <td>Errors</td>
                        <td>Syntax, type mismatches</td>
                        <td>Null pointers, out of bounds</td>
                    </tr>
                    <tr>
                        <td>Optimization</td>
                        <td>Constant folding, dead code</td>
                        <td>JIT compilation, inlining</td>
                    </tr>
                    <tr>
                        <td>Information</td>
                        <td>Full source code</td>
                        <td>Bytecode, limited generics</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="jdk-jre-jvm.html" class="related-link">JDK vs JRE vs JVM</a>
                <a href="../advanced/jvm-internals.html" class="related-link">JVM Internals</a>
                <a href="../fundamentals/generics.html" class="related-link">Generics</a>
            </div>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
