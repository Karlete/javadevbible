<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Version History - JavaDev Bible</title>
    <link rel="stylesheet" href="../../css/main.css">
    <link rel="stylesheet" href="../../css/syntax-highlighting.css">
</head>
<body class="topic-page">
    <header class="topic-header">
        <div class="header-content">
            <nav class="breadcrumb">
                <a href="../../index.html">Home</a> / <a href="../../index.html#java-versions">Java Versions</a> / Version History
            </nav>
            <h1>Java Version History</h1>
            <p class="topic-subtitle">The Complete Evolution of Java from 1.0 to Modern Releases</p>
            <a href="../../index.html" class="back-btn">&larr; Back to Index</a>
        </div>
    </header>

    <main class="topic-content">
        <section class="content-section">
            <h2>Introduction</h2>
            <p>Java's version history is a fascinating journey through nearly three decades of programming language evolution. From its humble beginnings as a language for interactive television to becoming the backbone of enterprise computing worldwide, each Java release has brought innovations that shaped how we write software today.</p>

            <p>Understanding Java's version history isn't just academic curiosity—it's essential practical knowledge for every Java developer. When you encounter legacy codebases, you need to know which features were available in which versions. When planning upgrades, you must understand what breaking changes occurred between releases. When reading job requirements or documentation, version numbers tell you exactly what capabilities to expect.</p>

            <p>Java's commitment to backward compatibility is legendary in the software industry. Code written in Java 1.0 in 1996 can still run on Java 21 today—a remarkable achievement that few other languages can claim. This stability, combined with continuous innovation, explains why Java remains one of the world's most popular programming languages after nearly 30 years.</p>

            <div class="info-box note">
                <div class="info-box-title">Key Facts About Java Releases</div>
                <ul>
                    <li><strong>First Release:</strong> Java 1.0 on January 23, 1996</li>
                    <li><strong>Current LTS:</strong> Java 21 (September 2023)</li>
                    <li><strong>Release Cycle:</strong> Every 6 months since Java 9 (March and September)</li>
                    <li><strong>LTS Cycle:</strong> Every 2 years (Java 11, 17, 21...)</li>
                    <li><strong>Total Major Versions:</strong> 21+ and counting</li>
                    <li><strong>Stewarded By:</strong> Oracle (since 2010, previously Sun Microsystems)</li>
                </ul>
            </div>
        </section>

        <section class="content-section">
            <h2>Understanding Java's Release Model</h2>
            <p>Before diving into specific versions, it's crucial to understand how Java releases work. This knowledge helps you make informed decisions about which version to use in your projects.</p>

            <h3>The Two-Track System</h3>
            <pre><code><span class="comment">/*
 * Java Release Timeline Visualization
 * =====================================
 *
 *  Feature Releases (every 6 months)
 *  ─────────────────────────────────────────────────────────────────────▶
 *     │    │    │    │    │    │    │    │    │    │    │    │
 *     9   10   11   12   13   14   15   16   17   18   19   20   21   22
 *     │         │                        │                   │
 *     │        LTS                      LTS                 LTS
 *     │    (3 years)                (3 years)           (3 years)
 *     │         │                        │                   │
 *     └─────────┴────────────────────────┴───────────────────┴──────────▶
 *           Long-Term Support Track (updates for years)
 *
 *  Non-LTS versions: Support for 6 months only
 *  LTS versions: Extended support (typically 8+ years with paid support)
 */</span></code></pre>

            <h3>LTS vs Non-LTS: What's the Difference?</h3>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>LTS Versions</th>
                    <th>Non-LTS Versions</th>
                </tr>
                <tr>
                    <td><strong>Support Duration</strong></td>
                    <td>Minimum 3 years (often 8+ with Oracle)</td>
                    <td>6 months only</td>
                </tr>
                <tr>
                    <td><strong>Security Updates</strong></td>
                    <td>Years of patches</td>
                    <td>Until next release</td>
                </tr>
                <tr>
                    <td><strong>Production Use</strong></td>
                    <td>Recommended</td>
                    <td>For testing new features</td>
                </tr>
                <tr>
                    <td><strong>Examples</strong></td>
                    <td>Java 8, 11, 17, 21</td>
                    <td>Java 9, 10, 12-16, 18-20</td>
                </tr>
            </table>

            <div class="info-box warning">
                <div class="info-box-title">Critical Decision: Choosing a Java Version</div>
                <p><strong>For Production:</strong> Always use an LTS version (Java 17 or 21 recommended)</p>
                <p><strong>For Legacy Systems:</strong> Java 8 or 11 if dependencies require it</p>
                <p><strong>For Learning/Experimentation:</strong> Latest release to explore new features</p>
                <p><strong>Never in Production:</strong> Non-LTS versions (9, 10, 12-16, 18-20)</p>
            </div>
        </section>

        <section class="content-section">
            <h2>The Foundation Era (1996-2004)</h2>
            <p>These early versions established Java's core identity and fundamental features that remain unchanged today.</p>

            <h3>Java 1.0 (January 1996) - "Oak"</h3>
            <p>The first public release, originally developed under the codename "Oak" for interactive television. Java 1.0 introduced the revolutionary concept of "Write Once, Run Anywhere."</p>

            <div class="info-box note">
                <div class="info-box-title">Java 1.0 Key Features</div>
                <ul>
                    <li><strong>Applets</strong> - Run Java in web browsers (revolutionary at the time)</li>
                    <li><strong>AWT</strong> - Abstract Window Toolkit for GUIs</li>
                    <li><strong>Core Classes</strong> - java.lang, java.io, java.util basics</li>
                    <li><strong>Garbage Collection</strong> - Automatic memory management</li>
                    <li><strong>Security Model</strong> - Sandbox for untrusted code</li>
                </ul>
            </div>

            <h3>Java 1.1 (February 1997)</h3>
            <p>A major improvement that added features still heavily used today:</p>
            <pre><code><span class="comment">// Inner classes - new in Java 1.1</span>
<span class="keyword">public class</span> <span class="class-name">Outer</span> {
    <span class="keyword">private</span> <span class="class-name">String</span> message = <span class="string">"Hello"</span>;

    <span class="keyword">class</span> <span class="class-name">Inner</span> {
        <span class="keyword">void</span> <span class="function">printMessage</span>() {
            <span class="class-name">System</span>.out.println(message);  <span class="comment">// Can access outer class members</span>
        }
    }

    <span class="comment">// Anonymous inner classes - event handling pattern</span>
    <span class="class-name">Button</span> button = <span class="keyword">new</span> <span class="class-name">Button</span>();
    button.addActionListener(<span class="keyword">new</span> <span class="class-name">ActionListener</span>() {
        <span class="annotation">@Override</span>
        <span class="keyword">public void</span> <span class="function">actionPerformed</span>(<span class="class-name">ActionEvent</span> e) {
            <span class="class-name">System</span>.out.println(<span class="string">"Button clicked!"</span>);
        }
    });
}

<span class="comment">// JDBC - Database connectivity</span>
<span class="class-name">Connection</span> conn = <span class="class-name">DriverManager</span>.getConnection(
    <span class="string">"jdbc:mysql://localhost/mydb"</span>, <span class="string">"user"</span>, <span class="string">"pass"</span>
);
<span class="class-name">Statement</span> stmt = conn.createStatement();
<span class="class-name">ResultSet</span> rs = stmt.executeQuery(<span class="string">"SELECT * FROM users"</span>);

<span class="comment">// Reflection - inspect classes at runtime</span>
<span class="class-name">Class</span>&lt;?&gt; clazz = <span class="class-name">String</span>.<span class="keyword">class</span>;
<span class="class-name">Method</span>[] methods = clazz.getMethods();
<span class="keyword">for</span> (<span class="class-name">Method</span> m : methods) {
    <span class="class-name">System</span>.out.println(m.getName());
}</code></pre>

            <h3>Java 1.2 (December 1998) - "Java 2"</h3>
            <p>Such a significant release that Sun rebranded it as "Java 2." This version introduced the Collections Framework, which remains the foundation of Java data structures today.</p>
            <pre><code><span class="comment">// The Collections Framework - still used exactly like this today!</span>
<span class="class-name">List</span> list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>();      <span class="comment">// Note: no generics yet</span>
<span class="class-name">Set</span> set = <span class="keyword">new</span> <span class="class-name">HashSet</span>();
<span class="class-name">Map</span> map = <span class="keyword">new</span> <span class="class-name">HashMap</span>();

list.add(<span class="string">"Hello"</span>);
list.add(<span class="string">"World"</span>);

<span class="comment">// Iterator pattern</span>
<span class="class-name">Iterator</span> it = list.iterator();
<span class="keyword">while</span> (it.hasNext()) {
    <span class="class-name">String</span> s = (<span class="class-name">String</span>) it.next();  <span class="comment">// Casting required without generics</span>
    <span class="class-name">System</span>.out.println(s);
}

<span class="comment">// Swing GUI toolkit - replaced AWT for rich interfaces</span>
<span class="class-name">JFrame</span> frame = <span class="keyword">new</span> <span class="class-name">JFrame</span>(<span class="string">"My Application"</span>);
<span class="class-name">JButton</span> button = <span class="keyword">new</span> <span class="class-name">JButton</span>(<span class="string">"Click Me"</span>);
frame.add(button);
frame.setVisible(<span class="keyword">true</span>);</code></pre>

            <h3>Java 1.3 (May 2000) - "Kestrel"</h3>
            <ul>
                <li><strong>HotSpot JVM</strong> became the default - massive performance improvement</li>
                <li><strong>JNDI</strong> (Java Naming and Directory Interface) added to core</li>
                <li><strong>Java Sound API</strong> for audio processing</li>
                <li><strong>RMI over IIOP</strong> for CORBA interoperability</li>
            </ul>

            <h3>Java 1.4 (February 2002) - "Merlin"</h3>
            <p>The last version before the major Java 5 overhaul, 1.4 added crucial features:</p>
            <pre><code><span class="comment">// assert keyword - Design by Contract</span>
<span class="keyword">public void</span> <span class="function">setAge</span>(<span class="keyword">int</span> age) {
    <span class="keyword">assert</span> age &gt;= <span class="number">0</span> : <span class="string">"Age cannot be negative"</span>;
    <span class="keyword">this</span>.age = age;
}

<span class="comment">// Regular expressions - finally!</span>
<span class="keyword">import</span> java.util.regex.*;

<span class="class-name">Pattern</span> pattern = <span class="class-name">Pattern</span>.compile(<span class="string">"\\d{3}-\\d{4}"</span>);
<span class="class-name">Matcher</span> matcher = pattern.matcher(<span class="string">"Call 555-1234 today"</span>);
<span class="keyword">if</span> (matcher.find()) {
    <span class="class-name">System</span>.out.println(<span class="string">"Found: "</span> + matcher.group());  <span class="comment">// 555-1234</span>
}

<span class="comment">// NIO - Non-blocking I/O</span>
<span class="class-name">FileChannel</span> channel = <span class="class-name">FileChannel</span>.open(<span class="class-name">Paths</span>.get(<span class="string">"file.txt"</span>));
<span class="class-name">ByteBuffer</span> buffer = <span class="class-name">ByteBuffer</span>.allocate(<span class="number">1024</span>);
channel.read(buffer);

<span class="comment">// Chained exceptions</span>
<span class="keyword">try</span> {
    riskyOperation();
} <span class="keyword">catch</span> (<span class="class-name">SQLException</span> e) {
    <span class="keyword">throw new</span> <span class="class-name">DataAccessException</span>(<span class="string">"Failed to access data"</span>, e);
}</code></pre>
        </section>

        <section class="content-section">
            <h2>The Modern Java Era (2004-2014)</h2>
            <p>Java 5 through 8 transformed Java from a verbose, ceremonial language into a more expressive, modern programming language.</p>

            <h3>Java 5 (September 2004) - "Tiger" - Revolutionary Release</h3>
            <p>Java 5 was the most significant update in Java's history up to that point. It introduced features that fundamentally changed how Java code is written.</p>

            <pre><code><span class="comment">/*
 * GENERICS - Type-safe collections
 * Before Java 5, collections stored Objects and required casting
 */</span>

<span class="comment">// Before Java 5 (dangerous!)</span>
<span class="class-name">List</span> oldList = <span class="keyword">new</span> <span class="class-name">ArrayList</span>();
oldList.add(<span class="string">"Hello"</span>);
oldList.add(<span class="number">123</span>);  <span class="comment">// No compile error - bug waiting to happen!</span>
<span class="class-name">String</span> s = (<span class="class-name">String</span>) oldList.get(<span class="number">1</span>);  <span class="comment">// ClassCastException at runtime!</span>

<span class="comment">// Java 5+ (safe!)</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; newList = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;<span class="class-name">String</span>&gt;();
newList.add(<span class="string">"Hello"</span>);
<span class="comment">// newList.add(123);  // Compile error! Type safety enforced</span>
<span class="class-name">String</span> str = newList.get(<span class="number">0</span>);  <span class="comment">// No casting needed</span>

<span class="comment">/*
 * ENHANCED FOR LOOP - Cleaner iteration
 */</span>
<span class="comment">// Before</span>
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {
    <span class="class-name">System</span>.out.println(array[i]);
}

<span class="comment">// After</span>
<span class="keyword">for</span> (<span class="class-name">String</span> item : array) {
    <span class="class-name">System</span>.out.println(item);
}

<span class="comment">/*
 * AUTOBOXING - Automatic primitive/wrapper conversion
 */</span>
<span class="class-name">Integer</span> boxed = <span class="number">42</span>;           <span class="comment">// Auto-boxing: int → Integer</span>
<span class="keyword">int</span> unboxed = boxed;           <span class="comment">// Auto-unboxing: Integer → int</span>

<span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt; numbers = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
numbers.add(<span class="number">1</span>);                <span class="comment">// Auto-boxing</span>
<span class="keyword">int</span> first = numbers.get(<span class="number">0</span>);    <span class="comment">// Auto-unboxing</span>

<span class="comment">/*
 * ENUMS - Type-safe constants
 */</span>
<span class="keyword">public enum</span> <span class="class-name">Day</span> {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;

    <span class="keyword">public boolean</span> <span class="function">isWeekend</span>() {
        <span class="keyword">return this</span> == SATURDAY || <span class="keyword">this</span> == SUNDAY;
    }
}

<span class="class-name">Day</span> today = <span class="class-name">Day</span>.MONDAY;
<span class="keyword">if</span> (!today.isWeekend()) {
    <span class="class-name">System</span>.out.println(<span class="string">"Time to work!"</span>);
}

<span class="comment">/*
 * VARARGS - Variable number of arguments
 */</span>
<span class="keyword">public void</span> <span class="function">printAll</span>(<span class="class-name">String</span>... messages) {
    <span class="keyword">for</span> (<span class="class-name">String</span> msg : messages) {
        <span class="class-name">System</span>.out.println(msg);
    }
}
printAll(<span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"!"</span>);

<span class="comment">/*
 * ANNOTATIONS - Metadata for code
 */</span>
<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="class-name">String</span> <span class="function">toString</span>() {
    <span class="keyword">return</span> <span class="string">"MyClass instance"</span>;
}

<span class="annotation">@Deprecated</span>
<span class="keyword">public void</span> <span class="function">oldMethod</span>() { }

<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)
<span class="keyword">public void</span> <span class="function">legacyCode</span>() { }</code></pre>

            <h3>Java 6 (December 2006) - "Mustang"</h3>
            <p>Focused on performance and developer productivity rather than language changes:</p>
            <ul>
                <li><strong>Scripting API (JSR 223)</strong> - Embed JavaScript, Groovy, etc. in Java</li>
                <li><strong>Compiler API</strong> - Compile Java code programmatically</li>
                <li><strong>JDBC 4.0</strong> - Auto-loading of drivers</li>
                <li><strong>Performance</strong> - Significant JVM improvements</li>
                <li><strong>Pluggable Annotations</strong> - Process annotations at compile time</li>
            </ul>

            <h3>Java 7 (July 2011) - "Dolphin"</h3>
            <p>After a long gap, Java 7 brought welcome syntactic improvements:</p>
            <pre><code><span class="comment">/*
 * DIAMOND OPERATOR - Less verbose generics
 */</span>
<span class="comment">// Before Java 7</span>
<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt;&gt; map = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;<span class="class-name">String</span>, <span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt;&gt;();

<span class="comment">// Java 7+ - type inference</span>
<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt;&gt; map = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;&gt;();

<span class="comment">/*
 * TRY-WITH-RESOURCES - Automatic resource management
 */</span>
<span class="comment">// Before Java 7 (verbose and error-prone)</span>
<span class="class-name">BufferedReader</span> br = <span class="keyword">null</span>;
<span class="keyword">try</span> {
    br = <span class="keyword">new</span> <span class="class-name">BufferedReader</span>(<span class="keyword">new</span> <span class="class-name">FileReader</span>(path));
    <span class="keyword">return</span> br.readLine();
} <span class="keyword">finally</span> {
    <span class="keyword">if</span> (br != <span class="keyword">null</span>) {
        <span class="keyword">try</span> {
            br.close();
        } <span class="keyword">catch</span> (<span class="class-name">IOException</span> e) {
            <span class="comment">// Swallowed exception!</span>
        }
    }
}

<span class="comment">// Java 7+ (clean and safe)</span>
<span class="keyword">try</span> (<span class="class-name">BufferedReader</span> br = <span class="keyword">new</span> <span class="class-name">BufferedReader</span>(<span class="keyword">new</span> <span class="class-name">FileReader</span>(path))) {
    <span class="keyword">return</span> br.readLine();
}  <span class="comment">// Automatically closed, even if exception thrown</span>

<span class="comment">/*
 * MULTI-CATCH - Handle multiple exceptions together
 */</span>
<span class="keyword">try</span> {
    riskyOperation();
} <span class="keyword">catch</span> (<span class="class-name">IOException</span> | <span class="class-name">SQLException</span> | <span class="class-name">ParseException</span> e) {
    logger.error(<span class="string">"Operation failed"</span>, e);
}

<span class="comment">/*
 * BINARY LITERALS AND UNDERSCORES
 */</span>
<span class="keyword">int</span> binary = <span class="number">0b1010_1010</span>;           <span class="comment">// Binary literal</span>
<span class="keyword">long</span> creditCard = <span class="number">1234_5678_9012_3456L</span>;  <span class="comment">// Readable numbers</span>
<span class="keyword">int</span> million = <span class="number">1_000_000</span>;

<span class="comment">/*
 * STRINGS IN SWITCH
 */</span>
<span class="class-name">String</span> day = <span class="string">"Monday"</span>;
<span class="keyword">switch</span> (day) {
    <span class="keyword">case</span> <span class="string">"Monday"</span>:
    <span class="keyword">case</span> <span class="string">"Tuesday"</span>:
        <span class="class-name">System</span>.out.println(<span class="string">"Early week"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">"Friday"</span>:
        <span class="class-name">System</span>.out.println(<span class="string">"TGIF!"</span>);
        <span class="keyword">break</span>;
}</code></pre>

            <h3>Java 8 (March 2014) - The Functional Revolution</h3>
            <p>Java 8 is arguably the most important release since Java 5. It brought functional programming to Java and remains the most widely used version in production systems.</p>

            <pre><code><span class="comment">/*
 * LAMBDA EXPRESSIONS - Functions as first-class citizens
 */</span>
<span class="comment">// Before Java 8 - anonymous inner class</span>
<span class="class-name">Runnable</span> oldWay = <span class="keyword">new</span> <span class="class-name">Runnable</span>() {
    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> <span class="function">run</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Hello!"</span>);
    }
};

<span class="comment">// Java 8 - lambda expression</span>
<span class="class-name">Runnable</span> newWay = () -&gt; <span class="class-name">System</span>.out.println(<span class="string">"Hello!"</span>);

<span class="comment">// With parameters</span>
<span class="class-name">Comparator</span>&lt;<span class="class-name">String</span>&gt; byLength = (s1, s2) -&gt; s1.length() - s2.length();

<span class="comment">/*
 * STREAM API - Functional data processing
 */</span>
<span class="class-name">List</span>&lt;<span class="class-name">Person</span>&gt; people = <span class="class-name">Arrays</span>.asList(
    <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Alice"</span>, <span class="number">30</span>),
    <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Bob"</span>, <span class="number">25</span>),
    <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Charlie"</span>, <span class="number">35</span>)
);

<span class="comment">// Find names of adults, sorted alphabetically</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; adultNames = people.stream()
    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)
    .map(<span class="class-name">Person</span>::getName)
    .sorted()
    .collect(<span class="class-name">Collectors</span>.toList());

<span class="comment">// Parallel processing - automatic multi-threading</span>
<span class="keyword">long</span> count = hugeList.parallelStream()
    .filter(item -&gt; item.isValid())
    .count();

<span class="comment">/*
 * OPTIONAL - No more NullPointerException
 */</span>
<span class="class-name">Optional</span>&lt;<span class="class-name">User</span>&gt; user = userRepository.findById(id);

<span class="comment">// Safe access</span>
user.ifPresent(u -&gt; <span class="class-name">System</span>.out.println(u.getName()));

<span class="comment">// Default value</span>
<span class="class-name">String</span> name = user.map(<span class="class-name">User</span>::getName).orElse(<span class="string">"Unknown"</span>);

<span class="comment">// Throw if empty</span>
<span class="class-name">User</span> u = user.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="class-name">NotFoundException</span>(<span class="string">"User not found"</span>));

<span class="comment">/*
 * METHOD REFERENCES - Even cleaner lambdas
 */</span>
<span class="comment">// Lambda</span>
names.forEach(name -&gt; <span class="class-name">System</span>.out.println(name));

<span class="comment">// Method reference</span>
names.forEach(<span class="class-name">System</span>.out::println);

<span class="comment">// Constructor reference</span>
<span class="class-name">Supplier</span>&lt;<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt;&gt; listFactory = <span class="class-name">ArrayList</span>::<span class="keyword">new</span>;

<span class="comment">/*
 * DEFAULT METHODS IN INTERFACES
 */</span>
<span class="keyword">public interface</span> <span class="class-name">Vehicle</span> {
    <span class="keyword">void</span> <span class="function">start</span>();

    <span class="comment">// Default implementation - no need to implement in every class</span>
    <span class="keyword">default void</span> <span class="function">honk</span>() {
        <span class="class-name">System</span>.out.println(<span class="string">"Beep!"</span>);
    }

    <span class="comment">// Static method in interface</span>
    <span class="keyword">static</span> <span class="class-name">Vehicle</span> <span class="function">create</span>(<span class="class-name">String</span> type) {
        <span class="keyword">return</span> type.equals(<span class="string">"car"</span>) ? <span class="keyword">new</span> <span class="class-name">Car</span>() : <span class="keyword">new</span> <span class="class-name">Bike</span>();
    }
}

<span class="comment">/*
 * NEW DATE/TIME API - Finally, dates done right!
 */</span>
<span class="comment">// Immutable and thread-safe</span>
<span class="class-name">LocalDate</span> today = <span class="class-name">LocalDate</span>.now();
<span class="class-name">LocalDate</span> birthday = <span class="class-name">LocalDate</span>.of(<span class="number">1990</span>, <span class="class-name">Month</span>.JANUARY, <span class="number">15</span>);

<span class="class-name">LocalDateTime</span> now = <span class="class-name">LocalDateTime</span>.now();
<span class="class-name">LocalDateTime</span> meeting = <span class="class-name">LocalDateTime</span>.of(<span class="number">2026</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">30</span>);

<span class="comment">// Time zones handled properly</span>
<span class="class-name">ZonedDateTime</span> zonedNow = <span class="class-name">ZonedDateTime</span>.now(<span class="class-name">ZoneId</span>.of(<span class="string">"America/New_York"</span>));

<span class="comment">// Duration and Period</span>
<span class="class-name">Duration</span> duration = <span class="class-name">Duration</span>.between(start, end);
<span class="class-name">Period</span> age = <span class="class-name">Period</span>.between(birthday, today);</code></pre>
        </section>

        <section class="content-section">
            <h2>The Rapid Release Era (2017-Present)</h2>
            <p>Starting with Java 9, Oracle moved to a six-month release cycle, delivering features faster but requiring more attention to version management.</p>

            <h3>Java 9 (September 2017) - The Module System</h3>
            <p>Java 9 introduced the controversial module system (Project Jigsaw), the biggest structural change to Java since its creation.</p>

            <pre><code><span class="comment">/*
 * MODULE SYSTEM - Modular Java platform
 */</span>
<span class="comment">// module-info.java - declares module dependencies</span>
<span class="keyword">module</span> com.myapp {
    <span class="keyword">requires</span> java.sql;           <span class="comment">// Needs JDBC</span>
    <span class="keyword">requires</span> java.logging;       <span class="comment">// Needs logging</span>
    <span class="keyword">requires transitive</span> com.lib; <span class="comment">// Passes dependency to users</span>

    <span class="keyword">exports</span> com.myapp.api;       <span class="comment">// Public API</span>
    <span class="keyword">exports</span> com.myapp.spi <span class="keyword">to</span> com.plugin;  <span class="comment">// Restricted export</span>

    <span class="keyword">opens</span> com.myapp.internal <span class="keyword">to</span> com.framework;  <span class="comment">// For reflection</span>
}

<span class="comment">/*
 * COLLECTION FACTORY METHODS
 */</span>
<span class="comment">// Before Java 9</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
list.add(<span class="string">"a"</span>);
list.add(<span class="string">"b"</span>);
list = <span class="class-name">Collections</span>.unmodifiableList(list);

<span class="comment">// Java 9+ - immutable collections</span>
<span class="class-name">List</span>&lt;<span class="class-name">String</span>&gt; list = <span class="class-name">List</span>.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);
<span class="class-name">Set</span>&lt;<span class="class-name">Integer</span>&gt; set = <span class="class-name">Set</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);
<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">Integer</span>&gt; map = <span class="class-name">Map</span>.of(<span class="string">"one"</span>, <span class="number">1</span>, <span class="string">"two"</span>, <span class="number">2</span>);

<span class="comment">/*
 * JSHELL - Interactive Java (REPL)
 */</span>
<span class="comment">// $ jshell</span>
<span class="comment">// jshell> int x = 5</span>
<span class="comment">// x ==> 5</span>
<span class="comment">// jshell> x * 10</span>
<span class="comment">// $2 ==> 50</span>

<span class="comment">/*
 * PRIVATE METHODS IN INTERFACES
 */</span>
<span class="keyword">public interface</span> <span class="class-name">Logging</span> {
    <span class="keyword">default void</span> <span class="function">logInfo</span>(<span class="class-name">String</span> msg) {
        log(<span class="string">"INFO"</span>, msg);
    }

    <span class="keyword">default void</span> <span class="function">logError</span>(<span class="class-name">String</span> msg) {
        log(<span class="string">"ERROR"</span>, msg);
    }

    <span class="comment">// Private method for code reuse</span>
    <span class="keyword">private void</span> <span class="function">log</span>(<span class="class-name">String</span> level, <span class="class-name">String</span> msg) {
        <span class="class-name">System</span>.out.println(<span class="string">"["</span> + level + <span class="string">"] "</span> + msg);
    }
}

<span class="comment">/*
 * STREAM IMPROVEMENTS
 */</span>
<span class="comment">// takeWhile and dropWhile</span>
<span class="class-name">Stream</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)
    .takeWhile(n -&gt; n &lt; <span class="number">4</span>)
    .forEach(<span class="class-name">System</span>.out::println);  <span class="comment">// 1, 2, 3</span>

<span class="comment">// ofNullable</span>
<span class="class-name">Stream</span>.ofNullable(nullableValue)
    .forEach(<span class="class-name">System</span>.out::println);</code></pre>

            <h3>Java 10 (March 2018)</h3>
            <pre><code><span class="comment">/*
 * LOCAL VARIABLE TYPE INFERENCE (var)
 */</span>
<span class="comment">// Instead of explicit types...</span>
<span class="class-name">Map</span>&lt;<span class="class-name">String</span>, <span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt;&gt; map = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;<span class="class-name">String</span>, <span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt;&gt;();

<span class="comment">// ...use var (type inferred by compiler)</span>
<span class="keyword">var</span> map = <span class="keyword">new</span> <span class="class-name">HashMap</span>&lt;<span class="class-name">String</span>, <span class="class-name">List</span>&lt;<span class="class-name">Integer</span>&gt;&gt;();
<span class="keyword">var</span> list = <span class="class-name">List</span>.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);
<span class="keyword">var</span> stream = list.stream();

<span class="comment">// Works in loops</span>
<span class="keyword">for</span> (<span class="keyword">var</span> item : list) {
    <span class="class-name">System</span>.out.println(item);
}

<span class="comment">// NOT allowed: fields, parameters, return types</span>
<span class="comment">// private var field;  // Error!</span></code></pre>

            <h3>Java 11 (September 2018) - LTS</h3>
            <p>The first LTS release under the new model, Java 11 is widely adopted in production:</p>
            <pre><code><span class="comment">/*
 * HTTP CLIENT API (Standard)
 */</span>
<span class="class-name">HttpClient</span> client = <span class="class-name">HttpClient</span>.newBuilder()
    .version(<span class="class-name">HttpClient</span>.<span class="class-name">Version</span>.HTTP_2)
    .connectTimeout(<span class="class-name">Duration</span>.ofSeconds(<span class="number">10</span>))
    .build();

<span class="class-name">HttpRequest</span> request = <span class="class-name">HttpRequest</span>.newBuilder()
    .uri(<span class="class-name">URI</span>.create(<span class="string">"https://api.example.com/data"</span>))
    .header(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
    .GET()
    .build();

<span class="class-name">HttpResponse</span>&lt;<span class="class-name">String</span>&gt; response = client.send(
    request, <span class="class-name">HttpResponse</span>.<span class="class-name">BodyHandlers</span>.ofString()
);

<span class="comment">// Async version</span>
client.sendAsync(request, <span class="class-name">HttpResponse</span>.<span class="class-name">BodyHandlers</span>.ofString())
    .thenApply(<span class="class-name">HttpResponse</span>::body)
    .thenAccept(<span class="class-name">System</span>.out::println);

<span class="comment">/*
 * NEW STRING METHODS
 */</span>
<span class="string">"  hello  "</span>.strip();          <span class="comment">// "hello" - better than trim()</span>
<span class="string">"  hello  "</span>.stripLeading();   <span class="comment">// "hello  "</span>
<span class="string">"  hello  "</span>.stripTrailing();  <span class="comment">// "  hello"</span>
<span class="string">"hello"</span>.repeat(<span class="number">3</span>);            <span class="comment">// "hellohellohello"</span>
<span class="string">""</span>.isBlank();                  <span class="comment">// true (also " ".isBlank() is true)</span>
<span class="string">"line1\nline2"</span>.lines();        <span class="comment">// Stream&lt;String&gt;</span>

<span class="comment">/*
 * VAR IN LAMBDA PARAMETERS
 */</span>
<span class="comment">// Allows annotations on lambda parameters</span>
(<span class="annotation">@NotNull</span> <span class="keyword">var</span> x, <span class="annotation">@Nullable</span> <span class="keyword">var</span> y) -&gt; x + y

<span class="comment">/*
 * RUN SINGLE-FILE PROGRAMS DIRECTLY
 */</span>
<span class="comment">// java HelloWorld.java (no javac needed for single files)</span></code></pre>

            <h3>Java 12-16 (2019-2021) - Preview Features</h3>
            <p>These versions introduced features as previews that became standard in Java 17:</p>

            <pre><code><span class="comment">/*
 * SWITCH EXPRESSIONS (Java 12-14, standard in 14)
 */</span>
<span class="comment">// Before - statement</span>
<span class="class-name">String</span> result;
<span class="keyword">switch</span> (day) {
    <span class="keyword">case</span> MONDAY:
    <span class="keyword">case</span> FRIDAY:
        result = <span class="string">"Work"</span>;
        <span class="keyword">break</span>;
    <span class="keyword">case</span> SATURDAY:
    <span class="keyword">case</span> SUNDAY:
        result = <span class="string">"Rest"</span>;
        <span class="keyword">break</span>;
    <span class="keyword">default</span>:
        result = <span class="string">"Unknown"</span>;
}

<span class="comment">// After - expression (returns a value)</span>
<span class="class-name">String</span> result = <span class="keyword">switch</span> (day) {
    <span class="keyword">case</span> MONDAY, FRIDAY -&gt; <span class="string">"Work"</span>;
    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; <span class="string">"Rest"</span>;
    <span class="keyword">default</span> -&gt; <span class="string">"Unknown"</span>;
};

<span class="comment">// With yield for complex cases</span>
<span class="class-name">String</span> result = <span class="keyword">switch</span> (day) {
    <span class="keyword">case</span> MONDAY -&gt; {
        log(<span class="string">"Starting week"</span>);
        <span class="keyword">yield</span> <span class="string">"Work hard"</span>;
    }
    <span class="keyword">default</span> -&gt; <span class="string">"Regular day"</span>;
};

<span class="comment">/*
 * TEXT BLOCKS (Java 13-15, standard in 15)
 */</span>
<span class="comment">// Before - escaped strings</span>
<span class="class-name">String</span> json = <span class="string">"{\n"</span> +
              <span class="string">"  \"name\": \"John\",\n"</span> +
              <span class="string">"  \"age\": 30\n"</span> +
              <span class="string">"}"</span>;

<span class="comment">// After - text blocks</span>
<span class="class-name">String</span> json = <span class="string">"""
    {
        "name": "John",
        "age": 30
    }
    """</span>;

<span class="comment">// HTML, SQL, etc. all become readable</span>
<span class="class-name">String</span> html = <span class="string">"""
    &lt;html&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello, World!&lt;/h1&gt;
        &lt;/body&gt;
    &lt;/html&gt;
    """</span>;

<span class="comment">/*
 * RECORDS (Java 14-16, standard in 16)
 */</span>
<span class="comment">// Before - verbose data class</span>
<span class="keyword">public class</span> <span class="class-name">PersonOld</span> {
    <span class="keyword">private final</span> <span class="class-name">String</span> name;
    <span class="keyword">private final int</span> age;

    <span class="keyword">public</span> <span class="function">PersonOld</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
    }

    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">name</span>() { <span class="keyword">return</span> name; }
    <span class="keyword">public int</span> <span class="function">age</span>() { <span class="keyword">return</span> age; }

    <span class="annotation">@Override</span>
    <span class="keyword">public boolean</span> <span class="function">equals</span>(<span class="class-name">Object</span> o) { <span class="comment">/* ... */</span> }
    <span class="annotation">@Override</span>
    <span class="keyword">public int</span> <span class="function">hashCode</span>() { <span class="comment">/* ... */</span> }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="class-name">String</span> <span class="function">toString</span>() { <span class="comment">/* ... */</span> }
}

<span class="comment">// After - one line!</span>
<span class="keyword">record</span> <span class="class-name">Person</span>(<span class="class-name">String</span> name, <span class="keyword">int</span> age) { }

<span class="comment">// Usage</span>
<span class="class-name">Person</span> p = <span class="keyword">new</span> <span class="class-name">Person</span>(<span class="string">"Alice"</span>, <span class="number">30</span>);
<span class="class-name">System</span>.out.println(p.name());  <span class="comment">// "Alice"</span>
<span class="class-name">System</span>.out.println(p);         <span class="comment">// "Person[name=Alice, age=30]"</span>

<span class="comment">/*
 * PATTERN MATCHING FOR INSTANCEOF (Java 14-16, standard in 16)
 */</span>
<span class="comment">// Before</span>
<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="class-name">String</span>) {
    <span class="class-name">String</span> s = (<span class="class-name">String</span>) obj;
    <span class="class-name">System</span>.out.println(s.length());
}

<span class="comment">// After - binding variable</span>
<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="class-name">String</span> s) {
    <span class="class-name">System</span>.out.println(s.length());  <span class="comment">// s already cast</span>
}</code></pre>

            <h3>Java 17 (September 2021) - LTS</h3>
            <p>A major LTS release that standardized many preview features:</p>

            <pre><code><span class="comment">/*
 * SEALED CLASSES - Restricted inheritance
 */</span>
<span class="comment">// Only Circle, Rectangle, and Triangle can extend Shape</span>
<span class="keyword">sealed interface</span> <span class="class-name">Shape</span> <span class="keyword">permits</span> <span class="class-name">Circle</span>, <span class="class-name">Rectangle</span>, <span class="class-name">Triangle</span> { }

<span class="keyword">final class</span> <span class="class-name">Circle</span> <span class="keyword">implements</span> <span class="class-name">Shape</span> {
    <span class="keyword">private final double</span> radius;
    <span class="comment">// ...</span>
}

<span class="keyword">final class</span> <span class="class-name">Rectangle</span> <span class="keyword">implements</span> <span class="class-name">Shape</span> {
    <span class="keyword">private final double</span> width, height;
    <span class="comment">// ...</span>
}

<span class="keyword">non-sealed class</span> <span class="class-name">Triangle</span> <span class="keyword">implements</span> <span class="class-name">Shape</span> {
    <span class="comment">// Can be extended by any class</span>
}

<span class="comment">// Compiler knows all possible subtypes - enables exhaustive switch</span>
<span class="keyword">double</span> <span class="function">area</span>(<span class="class-name">Shape</span> shape) {
    <span class="keyword">return switch</span> (shape) {
        <span class="keyword">case</span> <span class="class-name">Circle</span> c -&gt; <span class="class-name">Math</span>.PI * c.radius() * c.radius();
        <span class="keyword">case</span> <span class="class-name">Rectangle</span> r -&gt; r.width() * r.height();
        <span class="keyword">case</span> <span class="class-name">Triangle</span> t -&gt; <span class="number">0.5</span> * t.base() * t.height();
        <span class="comment">// No default needed - compiler knows it's exhaustive!</span>
    };
}</code></pre>

            <h3>Java 21 (September 2023) - LTS - The Modern Era</h3>
            <p>Java 21 brings major features that modernize concurrent programming:</p>

            <pre><code><span class="comment">/*
 * VIRTUAL THREADS (Project Loom) - Lightweight concurrency
 */</span>
<span class="comment">// Before: Platform threads are expensive (1MB stack each)</span>
<span class="class-name">ExecutorService</span> executor = <span class="class-name">Executors</span>.newFixedThreadPool(<span class="number">100</span>);  <span class="comment">// Limited!</span>

<span class="comment">// After: Virtual threads are cheap (few KB each)</span>
<span class="keyword">try</span> (<span class="keyword">var</span> executor = <span class="class-name">Executors</span>.newVirtualThreadPerTaskExecutor()) {
    <span class="comment">// Can handle millions of concurrent tasks!</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) {
        executor.submit(() -&gt; {
            <span class="comment">// Each task gets its own virtual thread</span>
            fetchData();
            processData();
        });
    }
}

<span class="comment">// Simple virtual thread creation</span>
<span class="class-name">Thread</span>.startVirtualThread(() -&gt; <span class="class-name">System</span>.out.println(<span class="string">"Hello from virtual thread!"</span>));

<span class="comment">// Virtual thread factory</span>
<span class="class-name">ThreadFactory</span> factory = <span class="class-name">Thread</span>.ofVirtual().name(<span class="string">"worker-"</span>, <span class="number">0</span>).factory();

<span class="comment">/*
 * RECORD PATTERNS - Destructure records
 */</span>
<span class="keyword">record</span> <span class="class-name">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) { }
<span class="keyword">record</span> <span class="class-name">Line</span>(<span class="class-name">Point</span> start, <span class="class-name">Point</span> end) { }

<span class="keyword">void</span> <span class="function">process</span>(<span class="class-name">Object</span> obj) {
    <span class="comment">// Nested destructuring!</span>
    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="class-name">Line</span>(<span class="class-name">Point</span>(<span class="keyword">var</span> x1, <span class="keyword">var</span> y1), <span class="class-name">Point</span>(<span class="keyword">var</span> x2, <span class="keyword">var</span> y2))) {
        <span class="class-name">System</span>.out.println(<span class="string">"Line from ("</span> + x1 + <span class="string">","</span> + y1 + <span class="string">") to ("</span> + x2 + <span class="string">","</span> + y2 + <span class="string">")"</span>);
    }
}

<span class="comment">// In switch expressions</span>
<span class="class-name">String</span> <span class="function">describe</span>(<span class="class-name">Object</span> obj) {
    <span class="keyword">return switch</span> (obj) {
        <span class="keyword">case</span> <span class="class-name">Point</span>(<span class="keyword">var</span> x, <span class="keyword">var</span> y) <span class="keyword">when</span> x == y -&gt; <span class="string">"Diagonal point"</span>;
        <span class="keyword">case</span> <span class="class-name">Point</span>(<span class="keyword">var</span> x, <span class="keyword">var</span> y) -&gt; <span class="string">"Point at "</span> + x + <span class="string">","</span> + y;
        <span class="keyword">case null</span> -&gt; <span class="string">"null"</span>;
        <span class="keyword">default</span> -&gt; <span class="string">"Unknown"</span>;
    };
}

<span class="comment">/*
 * SEQUENCED COLLECTIONS - First/last element access
 */</span>
<span class="class-name">SequencedCollection</span>&lt;<span class="class-name">String</span>&gt; list = <span class="keyword">new</span> <span class="class-name">ArrayList</span>&lt;&gt;();
list.addFirst(<span class="string">"first"</span>);    <span class="comment">// Add at beginning</span>
list.addLast(<span class="string">"last"</span>);      <span class="comment">// Add at end</span>
<span class="class-name">String</span> first = list.getFirst();
<span class="class-name">String</span> last = list.getLast();
list.removeFirst();
list.removeLast();

<span class="class-name">SequencedCollection</span>&lt;<span class="class-name">String</span>&gt; reversed = list.reversed();  <span class="comment">// Reverse view</span>

<span class="comment">/*
 * STRING TEMPLATES (Preview in 21)
 */</span>
<span class="class-name">String</span> name = <span class="string">"World"</span>;
<span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;
<span class="comment">// String message = STR."Hello, \{name}! Sum is \{x + y}";  // Preview</span></code></pre>
        </section>

        <section class="content-section">
            <h2>Complete Version Reference Table</h2>
            <table>
                <tr>
                    <th>Version</th>
                    <th>Release Date</th>
                    <th>LTS</th>
                    <th>Key Features</th>
                </tr>
                <tr>
                    <td>Java 1.0</td>
                    <td>Jan 1996</td>
                    <td>-</td>
                    <td>Initial release, Applets, AWT</td>
                </tr>
                <tr>
                    <td>Java 1.1</td>
                    <td>Feb 1997</td>
                    <td>-</td>
                    <td>Inner classes, JDBC, Reflection, JavaBeans</td>
                </tr>
                <tr>
                    <td>Java 1.2</td>
                    <td>Dec 1998</td>
                    <td>-</td>
                    <td>Collections Framework, Swing, JIT compiler</td>
                </tr>
                <tr>
                    <td>Java 1.3</td>
                    <td>May 2000</td>
                    <td>-</td>
                    <td>HotSpot JVM, JNDI, Java Sound</td>
                </tr>
                <tr>
                    <td>Java 1.4</td>
                    <td>Feb 2002</td>
                    <td>-</td>
                    <td>assert, regex, NIO, logging, XML</td>
                </tr>
                <tr>
                    <td>Java 5</td>
                    <td>Sep 2004</td>
                    <td>-</td>
                    <td>Generics, enums, annotations, varargs, enhanced for</td>
                </tr>
                <tr>
                    <td>Java 6</td>
                    <td>Dec 2006</td>
                    <td>-</td>
                    <td>Scripting API, JDBC 4.0, Compiler API</td>
                </tr>
                <tr>
                    <td>Java 7</td>
                    <td>Jul 2011</td>
                    <td>-</td>
                    <td>Diamond operator, try-with-resources, multi-catch</td>
                </tr>
                <tr style="background-color: #e8f5e9;">
                    <td><strong>Java 8</strong></td>
                    <td>Mar 2014</td>
                    <td><strong>LTS</strong></td>
                    <td>Lambdas, Streams, Optional, Date/Time API</td>
                </tr>
                <tr>
                    <td>Java 9</td>
                    <td>Sep 2017</td>
                    <td>-</td>
                    <td>Modules, JShell, Collection factories</td>
                </tr>
                <tr>
                    <td>Java 10</td>
                    <td>Mar 2018</td>
                    <td>-</td>
                    <td>var (local variables)</td>
                </tr>
                <tr style="background-color: #e8f5e9;">
                    <td><strong>Java 11</strong></td>
                    <td>Sep 2018</td>
                    <td><strong>LTS</strong></td>
                    <td>HTTP Client, String methods, single-file execution</td>
                </tr>
                <tr>
                    <td>Java 12-16</td>
                    <td>2019-2021</td>
                    <td>-</td>
                    <td>Switch expressions, text blocks, records (preview)</td>
                </tr>
                <tr style="background-color: #e8f5e9;">
                    <td><strong>Java 17</strong></td>
                    <td>Sep 2021</td>
                    <td><strong>LTS</strong></td>
                    <td>Sealed classes, pattern matching, records (standard)</td>
                </tr>
                <tr>
                    <td>Java 18-20</td>
                    <td>2022-2023</td>
                    <td>-</td>
                    <td>Virtual threads preview, pattern matching enhancements</td>
                </tr>
                <tr style="background-color: #e8f5e9;">
                    <td><strong>Java 21</strong></td>
                    <td>Sep 2023</td>
                    <td><strong>LTS</strong></td>
                    <td>Virtual threads, record patterns, sequenced collections</td>
                </tr>
            </table>
        </section>

        <section class="content-section">
            <h2>Common Pitfalls</h2>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 1: Using Non-LTS in Production</div>
                <p><strong>Problem:</strong> Deploying Java 12, 13, or other non-LTS versions to production.</p>
                <p><strong>Why It's Bad:</strong> These versions only receive 6 months of updates. After that, no security patches.</p>
                <p><strong>Solution:</strong> Always use LTS versions (8, 11, 17, 21) in production environments.</p>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 2: Ignoring Deprecation Warnings</div>
                <p><strong>Problem:</strong> Using deprecated APIs that may be removed in future versions.</p>
                <pre><code><span class="comment">// This will be removed!</span>
<span class="annotation">@Deprecated</span>(since = <span class="string">"9"</span>, forRemoval = <span class="keyword">true</span>)
<span class="keyword">public void</span> <span class="function">oldMethod</span>() { }</code></pre>
                <p><strong>Solution:</strong> Compile with <code>-Xlint:deprecation</code> and fix warnings before upgrading.</p>
            </div>

            <div class="info-box warning">
                <div class="info-box-title">Pitfall 3: Assuming Forward Compatibility</div>
                <p><strong>Problem:</strong> Thinking code compiled with Java 17 will run on Java 11.</p>
                <p><strong>Why It's Wrong:</strong> Java is backward compatible (old runs on new), not forward compatible.</p>
                <p><strong>Solution:</strong> Always compile for your minimum target version using <code>--release</code> flag.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Interview Questions</h2>

            <div class="info-box note">
                <div class="info-box-title">Common Interview Questions</div>

                <p><strong>Q: What's the difference between Java SE, EE, and ME?</strong></p>
                <p>A: SE (Standard Edition) is the core platform for general programming. EE (Enterprise Edition, now Jakarta EE) adds APIs for enterprise features like servlets, JPA, and EJB. ME (Micro Edition) is for embedded devices with limited resources.</p>

                <p><strong>Q: What features did Java 8 introduce and why are they significant?</strong></p>
                <p>A: Java 8 introduced lambdas, Stream API, Optional, and the new Date/Time API. These brought functional programming to Java, enabling more concise code, better handling of collections, safer null handling, and finally fixing Java's notoriously bad date handling.</p>

                <p><strong>Q: What is an LTS version and why does it matter?</strong></p>
                <p>A: LTS (Long-Term Support) versions receive security updates and bug fixes for years (typically 8+ years with commercial support). Non-LTS versions only get 6 months of support. Use LTS for production to ensure ongoing security patches.</p>

                <p><strong>Q: What problem do Java modules (Java 9+) solve?</strong></p>
                <p>A: Modules provide strong encapsulation at the package level, reliable configuration (explicit dependencies), and improved security by hiding internal APIs. They solve "JAR hell" and enable the JDK itself to be modular, allowing smaller runtime images.</p>

                <p><strong>Q: What are virtual threads and why are they important?</strong></p>
                <p>A: Virtual threads (Java 21) are lightweight threads managed by the JVM rather than the OS. While platform threads are limited (each uses ~1MB of stack), you can create millions of virtual threads. This simplifies concurrent programming by allowing blocking code to scale like async code.</p>

                <p><strong>Q: What's the class file version number for Java 17?</strong></p>
                <p>A: Java 17 produces class files with major version 61. The JVM uses this to ensure compatibility—older JVMs reject class files with newer version numbers.</p>
            </div>
        </section>

        <section class="content-section">
            <h2>Migration Guide</h2>

            <h3>Upgrading from Java 8 to 11</h3>
            <ul>
                <li><strong>Modules:</strong> Add <code>--add-modules</code> or explicit dependencies for Java EE modules (JAXB, JAX-WS)</li>
                <li><strong>Reflection:</strong> Add <code>--add-opens</code> for illegal reflective access</li>
                <li><strong>Removed APIs:</strong> Replace java.xml.bind with jakarta.xml.bind</li>
                <li><strong>Tools:</strong> Update build tools (Maven 3.5+, Gradle 5+)</li>
            </ul>

            <h3>Upgrading from Java 11 to 17</h3>
            <ul>
                <li><strong>Strong Encapsulation:</strong> Illegal access denied by default</li>
                <li><strong>New Features:</strong> Can start using records, sealed classes, pattern matching</li>
                <li><strong>Security:</strong> Stronger defaults, some algorithms removed</li>
            </ul>

            <h3>Upgrading from Java 17 to 21</h3>
            <ul>
                <li><strong>Virtual Threads:</strong> Can migrate blocking code to virtual threads</li>
                <li><strong>Pattern Matching:</strong> Enhanced patterns in switch</li>
                <li><strong>Sequenced Collections:</strong> New collection interfaces</li>
            </ul>
        </section>

        <section class="related-topics">
            <h3>Related Topics</h3>
            <div class="related-links">
                <a href="jdk-jre-jvm.html" class="related-link">JDK vs JRE vs JVM</a>
                <a href="version-compatibility.html" class="related-link">Version Compatibility</a>
                <a href="source-target-compatibility.html" class="related-link">Source/Target Compatibility</a>
                <a href="backward-compatibility.html" class="related-link">Backward Compatibility</a>
                <a href="../fundamentals/lambda-streams.html" class="related-link">Lambda & Streams</a>
                <a href="../advanced/multithreading.html" class="related-link">Multithreading</a>
            </div>
        </section>

        <section class="content-section">
            <h2>See Also</h2>
            <ul>
                <li><a href="../fundamentals/what-is-java.html">What is Java?</a> - Start here if you're new to Java</li>
                <li><a href="../advanced/jvm-internals.html">JVM Internals</a> - Deep dive into how Java executes</li>
                <li><a href="../tools/ides.html">IDEs</a> - Development environment setup</li>
                <li><a href="../build-tools/maven.html">Maven</a> - Managing Java versions in builds</li>
            </ul>
        </section>
    </main>

    <footer class="site-footer">
        <p>&copy; 2026 JavaDev Bible</p>
    </footer>

    <script src="../../js/navigation.js"></script>
</body>
</html>
